<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="//img.lujinkai.cn/blog/ljk/1607154764582.png">
  <link rel="icon" type="image/png" sizes="32x32" href="//img.lujinkai.cn/blog/ljk/1607154764582.png">
  <link rel="icon" type="image/png" sizes="16x16" href="//img.lujinkai.cn/blog/ljk/1607154764582.png">
  <link rel="mask-icon" href="//img.lujinkai.cn/blog/ljk/1607154764582.png" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//s1.lujinkai.cn/libs/fontawesome-free/5.15.4/css/all.min.css">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.lujinkai.cn","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":10},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"KN3H1V8A6V","apiKey":"c5d73d0dde2dd770ce49b505f938553d","indexName":"hexo","hits":{"per_page":20,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We did not find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}}}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="LJKのBlog">
<meta property="og:url" content="http://blog.lujinkai.cn/index.html">
<meta property="og:site_name" content="LJKのBlog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="像方便面一样的男子">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://blog.lujinkai.cn/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LJKのBlog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">LJKのBlog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">学无止境</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="像方便面一样的男子"
      src="//img.lujinkai.cn/blog/ljk/1607154764582.png">
  <p class="site-author-name" itemprop="name">像方便面一样的男子</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">340</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">73</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ljkk" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ljkk" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/%E5%89%8D%E7%AB%AF/JavaScript/js%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%89%8D%E7%AB%AF/JavaScript/js%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">js函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-29 16:57:05 / 修改时间：16:58:22" itemprop="dateCreated datePublished" datetime="2023-05-29T16:57:05+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>有默认值的参数传入<code>undefined</code>，则会取默认值。如果这个参数位于最后，则可以不传（相当于隐式传入<code>undefined</code>），否则得显式传入 <code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">x = get(), y</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="literal">undefined</span>, <span class="number">2</span>) <span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/%E5%89%8D%E7%AB%AF/React/immer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%89%8D%E7%AB%AF/React/immer/" class="post-title-link" itemprop="url">immer</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-29 16:20:07 / 修改时间：16:58:22" itemprop="dateCreated datePublished" datetime="2023-05-29T16:20:07+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>可变状态：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> objA = &#123; <span class="attr">name</span>: <span class="string">&quot;xiaoming&quot;</span> &#125;</span><br><span class="line"><span class="keyword">let</span> objB = objA</span><br><span class="line">objB.<span class="property">name</span> = <span class="string">&quot;lihua&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objA.<span class="property">name</span>) <span class="comment">// lihua</span></span><br></pre></td></tr></table></figure>

<p>我们只修改了 objB 的 name，发现 ojbA 也发生了改变。这个就是可变状态。</p>
<p>可变状态间接修改了其它对象，会造成代码隐患。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>深度拷贝</li>
<li>使用 immer、immutable-js 等处理不可变数据的库</li>
</ul>
<h2 id="不可变数据-immutable"><a href="#不可变数据-immutable" class="headerlink" title="不可变数据 immutable"></a>不可变数据 immutable</h2><p>当我们使用 deepClone 或 immer &#x2F; immutable-js 创建一个新对象，新对象进行有副作用（side effect）的操作都不会影响到原来的数据。这就是 immutable。</p>
<p>deepClone 虽然实现了 immutable，但是开销太大，因为它完全创建了一个新的对象出来，其实，对于不会进行赋值操作的 value 保持引用也没关系。</p>
<p>所以在 2014 年，facebook 的 immutable-js 横空出世，即保证了 immutable ，在运行时判断数据间的引用情况，又兼顾了性能。</p>
<h2 id="immutable-js"><a href="#immutable-js" class="headerlink" title="immutable.js"></a>immutable.js</h2><p>immutable-js 使用了另一套数据结构的 API ，与我们的常见操作有些许不同，它将所有的原生数据类型（Object， Array 等）都会转化成 immutable-js 的内部对象（Map，List 等），并且任何操作最终都会返回一个新的 immutable 的值。</p>
<h2 id="immer"><a href="#immer" class="headerlink" title="immer"></a>immer</h2><blockquote>
<p><a href="https://link.juejin.cn/?target=https://github.com/mweststrate/immer">Immer</a> 是 mobx 的作者写的一个 immutable 库，核心实现是利用 ES6 的 proxy，几乎以最小的成本实现了 js 的不可变数据结构，简单易用、体量小巧、设计巧妙，满足了我们对 JS 不可变数据结构的需求。</p>
</blockquote>
<p>与 immutable-js 最大的不同，immer 是使用原生数据结构的 API 而不是像 immutable-js 那样转化为内置对象之后使用内置的 API，举个简单例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> produce = <span class="built_in">require</span>(<span class="string">&quot;immer&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line"> <span class="attr">done</span>: <span class="literal">false</span>,</span><br><span class="line"> <span class="attr">val</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有具有副作用的操作，都可以放入 produce 函数的第二个参数内进行</span></span><br><span class="line"><span class="comment">// 最终返回的结果并不影响原来的数据</span></span><br><span class="line"><span class="keyword">const</span> newState = <span class="title function_">produce</span>(state, <span class="function"><span class="params">draft</span> =&gt;</span> &#123;</span><br><span class="line"> draft.<span class="property">done</span> = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">done</span>) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newState.<span class="property">done</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>通过上面的例子我们能发现，所有具有副作用的逻辑都可以放进 produce 的第二个参数的函数内部进行处理。在这个函数内部对原来的数据进行任何操作，都不会对原对象产生任何影响。</p>
<h3 id="immer-原理"><a href="#immer-原理" class="headerlink" title="immer 原理"></a>immer 原理</h3><p>Immer 使用了 ES6 的新特性 Proxy 。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
<p><strong>Proxy</strong> 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p>
<h3 id="immer-中的-proxy"><a href="#immer-中的-proxy" class="headerlink" title="immer 中的 proxy"></a>immer 中的 proxy</h3><p>immer 的做法就是维护一份 state 在内部，劫持所有操作，内部来判断是否有变化从而最终决定如何返回。下面这个例子就是一个构造函数，如果将它的实例传入 Proxy 对象作为第一个参数，后面处理对象时，就可以使用其中的方法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Store</span> &#123;</span><br><span class="line"> <span class="title function_">constructor</span>(<span class="params">state</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">modified</span> = <span class="literal">false</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">source</span> = state</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">copy</span> = <span class="literal">null</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">modified</span>) <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">source</span>[key]</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">copy</span>[key]</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">set</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">modified</span>) <span class="variable language_">this</span>.<span class="title function_">modifing</span>()</span><br><span class="line">  <span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">copy</span>[key] = value)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">modifing</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">modified</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">modified</span> = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 这里使用原生的 API 实现一层 immutable，</span></span><br><span class="line">  <span class="comment">// 数组使用 slice 则会创建一个新数组。对象则使用解构</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">copy</span> = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="variable language_">this</span>.<span class="property">source</span>) ? <span class="variable language_">this</span>.<span class="property">source</span>.<span class="title function_">slice</span>() : &#123; ...<span class="variable language_">this</span>.<span class="property">source</span> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>modified，source，copy 三个属性；get，set，modifing 三个方法。</p>
<p>modified 作为内置的 flag，判断如何进行设置和返回。</p>
<p>里面最关键的就应该是 modifing 这个函数，在第一次 set 的时候，实现一次 copy，copy 后的数据也是 immutable。</p>
<p>对于 Proxy 的第二个参数，简单做一层转发，任何对元素的读取和写入都转发到 store 实例内部方法去处理：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PROXY_FLAG</span> = <span class="string">&quot;@@SYMBOL_PROXY_FLAG&quot;</span></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line"> <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果遇到了这个 flag 我们直接返回我们操作的 target</span></span><br><span class="line">  <span class="keyword">if</span> (key === <span class="variable constant_">PROXY_FLAG</span>) <span class="keyword">return</span> target</span><br><span class="line">  <span class="keyword">return</span> target.<span class="title function_">get</span>(key)</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="title function_">set</span>(<span class="params">target, key, value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> target.<span class="title function_">set</span>(key, value)</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里在 getter 里面加一个 flag 的目的就在于将来从 proxy 对象中获取 store 实例更加方便。</p>
<p>最终我们能够完成这个 produce 函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">produce</span>(<span class="params">state, producer</span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Store</span>(state)</span><br><span class="line"> <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(store, handler)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 执行我们传入的 producer 函数，我们实际操作的都是 proxy 实例，所有有副作用的操作都会在 proxy 内部进行判断，是否最终要对 store 进行改动。</span></span><br><span class="line"> <span class="title function_">producer</span>(proxy)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 处理完成之后，通过 flag 拿到 store 实例</span></span><br><span class="line"> <span class="keyword">const</span> newState = proxy[<span class="variable constant_">PROXY_FLAG</span>]</span><br><span class="line"> <span class="keyword">if</span> (newState.<span class="property">modified</span>) <span class="keyword">return</span> newState.<span class="property">copy</span></span><br><span class="line"> <span class="keyword">return</span> newState.<span class="property">source</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，Store 构造函数、handler 处理对象，produce 处理 state，这三个模块最简版就完成了，将它们组合起来就是一个最 tiny 的 immer。真正的 immer 内部还有其他的功能。</p>
<p>当然，Proxy 作为一个新的 API，并不是所有环境都支持，Proxy 也无法 polyfill，所以 immer 在不支持 Proxy 的环境中，使用 Object.defineProperty 来进行一个兼容。</p>
<h4 id="freeze"><a href="#freeze" class="headerlink" title="freeze"></a>freeze</h4><p>freeze 表示状态树在生成之后就被冻结不可继续操作。对于普通 JS 对象，我们可以使用 Object.freeze 来冻结我们生成的状态树对象，当然像 immer &#x2F; immutable-js 内部自己有冻结的方法和逻辑。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/%E5%89%8D%E7%AB%AF/React/redux/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%89%8D%E7%AB%AF/React/redux/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/" class="post-title-link" itemprop="url">快速开始</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-29 16:14:16 / 修改时间：16:58:22" itemprop="dateCreated datePublished" datetime="2023-05-29T16:14:16+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/React/redux/" itemprop="url" rel="index"><span itemprop="name">redux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li>使用<code>configureStore</code>创建 Redux store<ul>
<li><code>configureStore</code> 接受 <code>reducer</code> 函数作为命名参数</li>
<li><code>configureStore</code> 使用的好用的默认设置自动设置 store</li>
</ul>
</li>
<li>为 React 应用程序组件提供 Redux store<ul>
<li>使用 React-Redux <code>&lt;Provider&gt;</code> 组件包裹你的 <code>&lt;App /&gt;</code></li>
<li>传递 Redux store 如 <code>&lt;Provider store=&#123;store&#125;&gt;</code></li>
</ul>
</li>
<li>使用<code>createSlice</code>创建 Redux “slice” reducer<ul>
<li>使用字符串名称、初始状态和命名的 reducer 函数调用“createSlice”</li>
<li>Reducer 函数可以使用 Immer 来“改变”状态</li>
<li>导出生成的 slice reducer 和 action creators</li>
</ul>
</li>
<li>在 React 组件中使用 React-Redux <code>useSelector/useDispatch</code>钩子<ul>
<li>使用<code>useSelector</code>钩子从 store 中读取数据</li>
<li>使用<code>useDispatch</code>钩子获取<code>dispatch</code>函数，并根据需要 dispatch actions</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/%E5%89%8D%E7%AB%AF/React/redux/7.%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-RTK%20Query%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%89%8D%E7%AB%AF/React/redux/7.%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-RTK%20Query%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">7.基础教程-RTK Query基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-29 16:14:09 / 修改时间：16:58:22" itemprop="dateCreated datePublished" datetime="2023-05-29T16:14:09+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/React/redux/" itemprop="url" rel="index"><span itemprop="name">redux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span> 你将学到</h5></div><div class="admonition-content"><ul class=""><li>RTK Query 如何简化 Redux 应用程序的数据获取</li><li>如何设置 RTK Query</li><li>如何使用 RTK Query 进行基本的数据获取和更新请求</li></ul></div></div>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>RTK Query</strong> 是一个强大的数据获取和缓存工具。它旨在简化在 Web 应用程序中加载数据的常见情况，<strong>无需自己手动编写数据获取和缓存逻辑</strong>。</p>
<p>RTK Query 是<strong>一个包含在 Redux Toolkit 包中的可选插件</strong>，其功能构建在 Redux Toolkit 中的其他 API 之上。</p>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>在过去的几年里，React 社区已经意识到 <strong>“数据获取和缓存” 实际上是一组不同于 “状态管理” 的关注点</strong>。</p>
<p>RTK Query 从其他开创数据获取解决方案的工具中汲取灵感，例如 Apollo Client、React Query、Urql 和 SWR，但在其 API 设计中添加了独特的方法：</p>
<ul>
<li>数据获取和缓存逻辑构建在 Redux Toolkit 的 <code>createSlice</code> 和 <code>createAsyncThunk</code> API 之上</li>
<li>由于 Redux Toolkit 与 UI 无关，因此 RTK Query 的功能可以与任何 UI 层一起使用</li>
<li>API 请求接口是提前定义的，包括如何从参数生成查询参数和转换响应以进行缓存</li>
<li>RTK Query 还可以生成封装整个数据获取过程的 React hooks ，为组件提供 <code>data</code> 和 <code>isFetching</code> 字段，并在组件挂载和卸载时管理缓存数据的生命周期</li>
<li>RTK Query 提供“缓存数据项生命周期函数”选项，支持在获取初始数据后通过 websocket 消息流式传输缓存更新等用例</li>
<li>我们有从 OpenAPI 和 GraphQL 模式生成 API slice 代码的早期工作示例</li>
<li>最后，RTK Query 完全用 TypeScript 编写，旨在提供出色的 TS 使用体验</li>
</ul>
<h3 id="包含"><a href="#包含" class="headerlink" title="包含"></a>包含</h3><p>RTK Query 包含在核心 Redux Toolkit 包的安装中。它可以通过以下两个入口点之一获得：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApi &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit/query&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 自动生成的特定于 React 的入口点 对应于定义请求接口的 hooks  */</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApi &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit/query/react&quot;</span></span><br></pre></td></tr></table></figure>

<p>RTK Query 主要由两个 API 组成：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://redux-toolkit.js.org/rtk-query/api/createApi"><code>createApi()</code></a>：RTK Query 功能的核心。它允许你定义一组请求接口来描述如何从一系列请求接口检索数据，包括如何获取和转换该数据的配置。在大多数情况下，你应该在每个应用程序中使用一次，根据经验，“每个基本 URL 一个 API slice”。</li>
<li><a target="_blank" rel="noopener" href="https://redux-toolkit.js.org/rtk-query/api/fetchBaseQuery"><code>fetchBaseQuery()</code></a>: <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en"><code>fetch</code></a> 的一个小包装 -US&#x2F;docs&#x2F;Web&#x2F;API&#x2F;Fetch_API），旨在简化请求。旨在为大多数用户在 <code>createApi</code> 中使用推荐的 <code>baseQuery</code>。</li>
</ul>
<h3 id="RTK-Query-缓存的设计思想"><a href="#RTK-Query-缓存的设计思想" class="headerlink" title="RTK Query 缓存的设计思想"></a>RTK Query 缓存的设计思想</h3><p>Redux 一直强调可预测性和显式行为。Redux 没有“魔法”，<strong>所有 Redux 逻辑都遵循相同的基本模式，即通过 reducers 调度操作和更新状态</strong>。这确实意味着有时你必须编写更多代码才能使事情发生。</p>
<p><strong>Redux Toolkit 核心 API 不会更改 Redux 应用程序中的任何基本数据流</strong> 你仍在调度操作和编写 reducer，只是代码比手动编写所有逻辑要少。 <strong>RTK Query 同理</strong>。这是一个额外的抽象级别，但<strong>在内部，它仍在执行我们已经看到的用于管理异步请求及其响应的完全相同的步骤</strong>。</p>
<p>但是，当你使用 RTK Query 时，会发生思维转变。我们不再考虑“管理状态”本身。相反，<strong>我们现在考虑“管理*缓存数据*”</strong>。与其尝试自己编写 reducer，我们现在将专注于定义 <strong>“这些数据来自哪里？”、“这个更新应该如何发送？”、“这个缓存的数据应该什么时候重新获取？”，以及“缓存的数据应该如何更新？”</strong>。如何获取、存储和检索这些数据成为我们不再需要担心的实现细节。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/%E5%89%8D%E7%AB%AF/React/redux/6.%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%8C%83%E5%BC%8F%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%89%8D%E7%AB%AF/React/redux/6.%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E6%80%A7%E8%83%BD%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%8C%83%E5%BC%8F%E5%8C%96/" class="post-title-link" itemprop="url">6.基础教程-性能与数据范式化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-29 16:14:03 / 修改时间：16:58:22" itemprop="dateCreated datePublished" datetime="2023-05-29T16:14:03+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/React/redux/" itemprop="url" rel="index"><span itemprop="name">redux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fetchNotifications = <span class="title function_">createAsyncThunk</span>(<span class="string">&quot;notifications/fetchNotifications&quot;</span>, <span class="keyword">async</span> (_, &#123; getState &#125;) =&gt; &#123;</span><br><span class="line"> <span class="keyword">const</span> allNotifications = <span class="title function_">selectAllNotifications</span>(<span class="title function_">getState</span>())</span><br><span class="line"> <span class="keyword">const</span> [latestNotification] = allNotifications</span><br><span class="line"> <span class="keyword">const</span> latestTimestamp = latestNotification ? latestNotification.<span class="property">date</span> : <span class="string">&quot;&quot;</span></span><br><span class="line"> <span class="keyword">const</span> response = <span class="keyword">await</span> client.<span class="title function_">get</span>(<span class="string">`/fakeApi/notifications?since=<span class="subst">$&#123;latestTimestamp&#125;</span>`</span>)</span><br><span class="line"> <span class="keyword">return</span> response.<span class="property">data</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Thunk-参数"><a href="#Thunk-参数" class="headerlink" title="Thunk 参数"></a>Thunk 参数</h3><p>payload creator 的第二个参数是一个’ thunkAPI ‘对象，包含几个有用的函数和信息：</p>
<ul>
<li><code>dispatch</code> 和 <code>getState</code>：<code>dispatch</code> 和 <code>getState</code> 方法由 Redux store 提供。你可以在 thunk 中使用这些来发起 action，或者从最新的 Redux store 中获取 state （例如在发起 另一个 action 后获取更新后的值）。</li>
<li><code>extra</code>：当创建 store 时，用于传递给 thunk 中间件的“额外参数”。这通常时某种 API 的包装器，比如一组知道如何对应用程序的服务器进行 API 调用并返回数据的函数，这样你的 thunk 就不必直接包含所有的 URL 和查询逻辑。</li>
<li><code>requestId</code>：该 thunk 调用的唯一随机 ID ，用于跟踪单个请求的状态。</li>
<li><code>signal</code>：一个<code>AbortController.signal</code> 函数，可用于取消正在进行的请求。</li>
<li><code>rejectWithValue</code>：一个用于当 thunk 收到一个错误时帮助自定义 <code>rejected</code> action 内容的工具。</li>
</ul>
<p>（如果你要手写 thunk 而不是使用 <code>createAsyncThunk</code>，则 thunk 函数将获取 <code>(dispatch, getState)</code> 作为单独的参数，而不是将他们放在一个对象中。）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/%E5%89%8D%E7%AB%AF/React/redux/5.%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E5%BC%82%E6%AD%A5%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%89%8D%E7%AB%AF/React/redux/5.%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E5%BC%82%E6%AD%A5%E9%80%BB%E8%BE%91%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/" class="post-title-link" itemprop="url">5.基础教程-异步逻辑与数据请求</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-29 16:13:56 / 修改时间：16:58:22" itemprop="dateCreated datePublished" datetime="2023-05-29T16:13:56+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/React/redux/" itemprop="url" rel="index"><span itemprop="name">redux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<div class="admonition admonition-tip alert alert--success"><div class="admonition-heading"><h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="16" viewBox="0 0 12 16"><path fill-rule="evenodd" d="M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"></path></svg></span> 你将学到</h5></div><div class="admonition-content"><ul class=""><li>如何使用 Redux “thunk” middleware 处理异步逻辑</li><li>处理异步请求状态的开发模式</li><li>如何使用 Redux Toolkit <code>createAsyncThunk</code> API 来简化异步调用</li></ul></div></div>
</blockquote>
<h2 id="thunks-与异步逻辑"><a href="#thunks-与异步逻辑" class="headerlink" title="thunks 与异步逻辑"></a>thunks 与异步逻辑</h2><h3 id="使用-Middleware-处理异步逻辑"><a href="#使用-Middleware-处理异步逻辑" class="headerlink" title="使用 Middleware 处理异步逻辑"></a>使用 Middleware 处理异步逻辑</h3><p>就其本身而言，Redux store 对异步逻辑一无所知，任何异步都必须发生在 store 之外。</p>
<p><a target="_blank" rel="noopener" href="https://cn.redux.js.org/tutorials/fundamentals/part-4-store#middleware">Redux middleware</a> 扩展了 store，它允许：</p>
<ul>
<li>dispatch action 时执行额外的逻辑（例如打印 action 的日志和状态）</li>
<li>暂停、修改、延迟、替换或停止 dispatch 的 action</li>
<li>编写可以访问 <code>dispatch</code> 和 <code>getState</code> 的额外代码</li>
<li>教 <code>dispatch</code> 如何接受除普通 action 对象之外的其他值，例如函数和 promise，通过拦截它们并 dispatch 实际 action 对象来代替</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cn.redux.js.org/faq/actions#how-can-i-represent-side-effects-such-as-ajax-calls-why-do-we-need-things-like-action-creators-thunks-and-middleware-to-do-async-behavior">使用 middleware 的最常见原因是允许不同类型的异步逻辑与 store 交互</a>。这允许你编写可以 dispatch action 和检查 store 状态的代码，同时使该逻辑与你的 UI 分开。</p>
<p>Redux 有多种异步 middleware，每一种都允许你使用不同的语法编写逻辑。最常见的异步 middleware 是 <a target="_blank" rel="noopener" href="https://github.com/reduxjs/redux-thunk"><code>redux-thunk</code></a>，它可以让你编写可能直接包含异步逻辑的普通函数。Redux Toolkit 的 <code>configureStore</code> 功能<a target="_blank" rel="noopener" href="https://redux-toolkit.js.org/api/getDefaultMiddleware#included-default-middleware">默认自动设置 thunk middleware</a>，<a target="_blank" rel="noopener" href="https://cn.redux.js.org/style-guide/#use-thunks-for-async-logic">我们推荐使用 thunk 作为 Redux 开发异步逻辑的标准方式</a>。</p>
<p>早些时候，我们看到了<a target="_blank" rel="noopener" href="https://cn.redux.js.org/tutorials/essentials/part-1-overview-concepts#redux-application-data-flow">Redux 的同步数据流是什么样子</a>。当引入异步逻辑时，我们添加了一个额外的步骤，middleware 可以运行像 AJAX 请求这样的逻辑，然后 dispatch action。这使得异步数据流看起来像这样：</p>
<img data-src="https://img.to2b.cn/blog/ljk/ReduxAsyncDataFlowDiagram-d97ff38a0f4da0f327163170ccc13e80.gif" style="zoom:50%;" />

<h3 id="thunk-函数"><a href="#thunk-函数" class="headerlink" title="thunk 函数"></a>thunk 函数</h3><p>将 thunk middleware 添加到 Redux store 后，它允许你将 <em>thunk 函数</em> 直接传递给 <code>store.dispatch</code>。调用 thunk 函数时总是将 <code>(dispatch, getState)</code> 作为它的参数，你可以根据需要在 thunk 中使用它们。</p>
<p>Thunks 通常还可以使用 action creator 再次 dispatch 普通的 action，比如 <code>dispatch(increment())</code>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">configureStore</span>(&#123; <span class="attr">reducer</span>: counterReducer &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// thunk 函数：</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">exampleThunkFunction</span> = (<span class="params">dispatch, getState</span>) =&gt; &#123;</span><br><span class="line"> <span class="keyword">const</span> stateBefore = <span class="title function_">getState</span>()</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Counter before: <span class="subst">$&#123;stateBefore.counter&#125;</span>`</span>)</span><br><span class="line"> <span class="title function_">dispatch</span>(<span class="title function_">increment</span>()) <span class="comment">//  dispatch 普通的 action</span></span><br><span class="line"> <span class="keyword">const</span> stateAfter = <span class="title function_">getState</span>()</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Counter after: <span class="subst">$&#123;stateAfter.counter&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">dispatch</span>(exampleThunkFunction) <span class="comment">// 将 thunk 函数 直接传递给 store.dispatch</span></span><br></pre></td></tr></table></figure>

<p>为了与 dispatch 普通 action 对象保持一致，我们通常将它们写为 _thunk action creators_，它返回 thunk 函数。这些 action creator 可以接受可以在 thunk 中使用的参数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">logAndAdd</span> = amount =&gt; &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> stateBefore = <span class="title function_">getState</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Counter before: <span class="subst">$&#123;stateBefore.counter&#125;</span>`</span>)</span><br><span class="line">  <span class="title function_">dispatch</span>(<span class="title function_">incrementByAmount</span>(amount))</span><br><span class="line">  <span class="keyword">const</span> stateAfter = <span class="title function_">getState</span>()</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Counter after: <span class="subst">$&#123;stateAfter.counter&#125;</span>`</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">dispatch</span>(<span class="title function_">logAndAdd</span>(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>Thunk 通常写在 “slice” 文件中。<code>createSlice</code> 本身对定义 thunk 没有任何特殊支持，因此你应该将它们作为单独的函数编写在同一个 slice 文件中。这样，他们就可以访问该 slice 的普通 action creator，并且很容易找到 thunk 的位置。</p>
<blockquote>
<p>“thunk” 这个词是一个编程术语，意思是 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Thunk">“一段做延迟工作的代码”</a>.</p>
</blockquote>
<h3 id="编写异步-Thunks"><a href="#编写异步-Thunks" class="headerlink" title="编写异步 Thunks"></a>编写异步 Thunks</h3><p>Thunk 内部可能有异步逻辑，例如 <code>setTimeout</code>、<code>Promise</code> 和 <code>async/await</code>。这使它们成为使用 AJAX 发起 API 请求的好地方。</p>
<p>Redux 的数据请求逻辑通常遵循以下可预测的模式：</p>
<ul>
<li>在请求之前 dispatch 请求“开始”的 action，以指示请求正在进行中。这可用于跟踪加载状态以允许跳过重复请求或在 UI 中显示加载中提示。</li>
<li>发出异步请求</li>
<li>根据请求结果，异步逻辑 dispatch 包含结果数据的“成功” action 或包含错误详细信息的 “失败” action。在这两种情况下，reducer 逻辑都会清除加载状态，并且要么展示成功案例的结果数据，要么保存错误值并在需要的地方展示。</li>
</ul>
<p><img data-src="//img.to2b.cn/blog/ljk/1681098219050.png"></p>
<p>这些步骤不是 _必需的_，而是常用的。（如果你只关心一个成功的结果，你可以在请求完成时发送一个“成功” action ，并跳过“开始”和“失败” action 。）</p>
<p>Redux Toolkit 提供了一个 <code>createAsyncThunk</code> API 来实现这些 action 的创建和 dispatch，我们很快就会看看如何使用它。</p>
<h4 id="细节说明"><a href="#细节说明" class="headerlink" title="细节说明"></a>细节说明</h4><p>如果我们手动编写一个典型的 async thunk 的代码，它可能看起来像这样：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getRepoDetailsStarted</span> = (<span class="params"></span>) =&gt; (&#123;</span><br><span class="line"> <span class="attr">type</span>: <span class="string">&quot;repoDetails/fetchStarted&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getRepoDetailsSuccess</span> = repoDetails =&gt; (&#123;</span><br><span class="line"> <span class="attr">type</span>: <span class="string">&quot;repoDetails/fetchSucceeded&quot;</span>,</span><br><span class="line"> <span class="attr">payload</span>: repoDetails,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getRepoDetailsFailed</span> = error =&gt; (&#123;</span><br><span class="line"> <span class="attr">type</span>: <span class="string">&quot;repoDetails/fetchFailed&quot;</span>,</span><br><span class="line"> error,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fetchIssuesCount</span> = (<span class="params">org, repo</span>) =&gt; <span class="keyword">async</span> dispatch =&gt; &#123;</span><br><span class="line"> <span class="title function_">dispatch</span>(<span class="title function_">getRepoDetailsStarted</span>())</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> repoDetails = <span class="keyword">await</span> <span class="title function_">getRepoDetails</span>(org, repo)</span><br><span class="line">  <span class="title function_">dispatch</span>(<span class="title function_">getRepoDetailsSuccess</span>(repoDetails))</span><br><span class="line"> &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="title function_">dispatch</span>(<span class="title function_">getRepoDetailsFailed</span>(err.<span class="title function_">toString</span>()))</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<p>Redux Toolkit 有一个新的 <a target="_blank" rel="noopener" href="https://redux-toolkit.js.org/rtk-query/overview"><strong>RTK Query data fetching API</strong></a>。 RTK Query 是专门为 Redux 应用程序构建的数据获取和缓存解决方案，<strong>可以不用编写任何 thunk 或 reducer 来处理数据获取</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>可以编写可复用的“selector 选择器”函数来封装从 Redux 状态中读取数据的逻辑</strong></p>
<ul>
<li>选择器是一种函数，它接收 Redux <code>state</code> 作为参数，并返回一些数据</li>
</ul>
<p><strong>Redux 使用叫做“ middleware ”这样的插件模式来开发异步逻辑</strong></p>
<ul>
<li>官方的处理异步 middleware 叫 <code>redux-thunk</code>，包含在 Redux Toolkit 中</li>
<li>Thunk 函数接收 <code>dispatch</code> 和<code>getState</code> 作为参数，并且可以在异步逻辑中使用它们</li>
</ul>
<p><strong>你可以 dispatch 其他 action 来帮助跟踪 API 调用的加载状态</strong></p>
<ul>
<li>典型的模式是在调用之前 dispatch 一个 “pending” 的 action，然后是包含数据的 “sucdess” 或包含错误的 “failure” action</li>
<li>加载状态通常应该使用枚举类型，如 <code>&#39;idle&#39; | &#39;loading&#39; | &#39;succeeded&#39; | &#39;failed&#39;</code></li>
</ul>
<p><strong>Redux Toolkit 有一个 <code>createAsyncThunk</code> API 可以为你 dispatch 这些 action</strong></p>
<ul>
<li><code>createAsyncThunk</code> 接受一个 “payload creator” 回调函数，它应该返回一个 <code>Promise</code>，并自动生成 <code>pending/fulfilled/rejected</code> action 类型</li>
<li>像 <code>fetchPosts</code> 这样生成的 action creator 根据你返回的 <code>Promise</code> dispatch 这些 action</li>
<li>可以使用 <code>extraReducers</code> 字段在 <code>createSlice</code> 中监听这些 action，并根据这些 action 更新 reducer 中的状态。</li>
<li>action creator 可用于自动填充 <code>extraReducers</code> 对象的键，以便切片知道要监听的 action。</li>
<li>Thunk 可以返回 promise。 具体对于<code>createAsyncThunk</code>，你可以<code>await dispatch(someThunk()).unwrap()</code>来处理组件级别的请求成功或失败。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/%E5%89%8D%E7%AB%AF/React/redux/4.%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%89%8D%E7%AB%AF/React/redux/4.%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE/" class="post-title-link" itemprop="url">4.基础教程-使用数据</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-29 16:13:49 / 修改时间：16:58:22" itemprop="dateCreated datePublished" datetime="2023-05-29T16:13:49+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/React/redux/" itemprop="url" rel="index"><span itemprop="name">redux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>注意</h5>

<p>如果 action 需要包含唯一 ID 或其他一些随机值，请始终先生成该随机值并将其放入 action 对象中。</p>
<p><strong>Reducer 中永远不应该计算随机值</strong>，因为这会使结果不可预测。</p>
</blockquote>
<p>解释：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903842237120519">深入理解 redux 之 reducer 为什么是纯函数</a></p>
<h2 id="不得修改传入的参数"><a href="#不得修改传入的参数" class="headerlink" title="不得修改传入的参数"></a>不得修改传入的参数</h2><p>以下是修改传入参数的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> params = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params">params</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(params)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">log</span>(params) <span class="comment">// &#123;a: 1&#125;</span></span><br><span class="line">params.<span class="property">a</span> = <span class="number">2</span></span><br><span class="line"><span class="title function_">log</span>(params) <span class="comment">// &#123;a: 2&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="不得调用非纯函数"><a href="#不得调用非纯函数" class="headerlink" title="不得调用非纯函数"></a>不得调用非纯函数</h2><p>redux 的核心提供可预测化的状态管理，即无论何时特定的 action 触发的行为永远保持一致，试想如果 reducer 中有 Date.now()等非纯函数，即使同样的 action,那么 reducer 处理过程中也是有所不同的，不再能保证可预测性。</p>
<h2 id="执行有副作用的操作"><a href="#执行有副作用的操作" class="headerlink" title="执行有副作用的操作"></a>执行有副作用的操作</h2><p>同样，副作用的操作也会带来不可预测性。</p>
<h3 id="api-请求该如何执行"><a href="#api-请求该如何执行" class="headerlink" title="api 请求该如何执行"></a>api 请求该如何执行</h3><p>显然 api 操作是不可避免的，因为总要向后台请求数据，那么 api 请求应该如何做呢？这里有两个办法：</p>
<ul>
<li>在 dispatch 方法之前进行 api 请求：在 dispatch 之外先进行 api 异步请求，当收到请求结果后，根据结果的不同选择 dispatch 不同的 action；</li>
<li>应用 redux-thunk、redux-promise 等中间件，就可以在 dispatch 函数中直接执行 api 请求等异步操作了。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Redux action creators 可以使用一个正确的内容模板去构造（prepare）action 对象</strong></p>
<ul>
<li><code>createSlice</code> 和 <code>createAction</code> 可以接受一个返回 action payload 的 “prepare callback”</li>
<li>诸如唯一的 ID 和一些随机值应该放在 action 里，而不是在 reducer 中去计算</li>
</ul>
<p><strong>Reducers 内（仅）应该包含 state 的更新逻辑</strong></p>
<ul>
<li>Reducers 内可以包含计算新 state 所需的任意逻辑</li>
<li>Action 对象内应该包含足够描述即将发生什么事的信息</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/%E5%89%8D%E7%AB%AF/React/redux/3.%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%89%8D%E7%AB%AF/React/redux/3.%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">3.基础教程-数据流基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-29 16:13:40 / 修改时间：16:58:22" itemprop="dateCreated datePublished" datetime="2023-05-29T16:13:40+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/React/redux/" itemprop="url" rel="index"><span itemprop="name">redux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/%E5%89%8D%E7%AB%AF/React/redux/2.%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E5%BA%94%E7%94%A8%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%89%8D%E7%AB%AF/React/redux/2.%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B-%E5%BA%94%E7%94%A8%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">2.基础教程-应用结构</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-29 16:13:25 / 修改时间：16:58:22" itemprop="dateCreated datePublished" datetime="2023-05-29T16:13:25+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/React/redux/" itemprop="url" rel="index"><span itemprop="name">redux</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="创建-Redux-Store"><a href="#创建-Redux-Store" class="headerlink" title="创建 Redux Store"></a>创建 Redux Store</h2><h3 id="Redux-Slice"><a href="#Redux-Slice" class="headerlink" title="Redux Slice"></a>Redux Slice</h3><p><strong>“slice” 是应用中单个功能的 Redux reducer 逻辑和 action 的集合</strong>, 通常一起定义在一个文件中。</p>
<p>比如，在一个博客应用中，store 的配置大致长这样：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; configureStore &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span></span><br><span class="line"><span class="keyword">import</span> usersReducer <span class="keyword">from</span> <span class="string">&quot;../features/users/usersSlice&quot;</span></span><br><span class="line"><span class="keyword">import</span> postsReducer <span class="keyword">from</span> <span class="string">&quot;../features/posts/postsSlice&quot;</span></span><br><span class="line"><span class="keyword">import</span> commentsReducer <span class="keyword">from</span> <span class="string">&quot;../features/comments/commentsSlice&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">configureStore</span>(&#123;</span><br><span class="line"> <span class="attr">reducer</span>: &#123;</span><br><span class="line">  <span class="attr">users</span>: usersReducer,</span><br><span class="line">  <span class="attr">posts</span>: postsReducer,</span><br><span class="line">  <span class="attr">comments</span>: commentsReducer,</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="创建-Slice-Reducer-和-Action"><a href="#创建-Slice-Reducer-和-Action" class="headerlink" title="创建 Slice Reducer 和 Action"></a>创建 Slice Reducer 和 Action</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createSlice &#125; <span class="keyword">from</span> <span class="string">&quot;@reduxjs/toolkit&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> counterSlice = <span class="title function_">createSlice</span>(&#123;</span><br><span class="line"> <span class="attr">name</span>: <span class="string">&quot;counter&quot;</span>,</span><br><span class="line"> <span class="attr">initialState</span>: &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">reducers</span>: &#123;</span><br><span class="line">  <span class="attr">increment</span>: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// Redux Toolkit 允许我们在 reducers 写 &quot;可变&quot; 逻辑。</span></span><br><span class="line">   <span class="comment">// 并不是真正的改变 state 因为它使用了 immer 库</span></span><br><span class="line">   <span class="comment">// 当 immer 检测到 &quot;draft state&quot; 改变时，会基于这些改变去创建一个新的不可变的 state</span></span><br><span class="line">   state.<span class="property">value</span> += <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">decrement</span>: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">   state.<span class="property">value</span> -= <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">incrementByAmount</span>: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">   state.<span class="property">value</span> += action.<span class="property">payload</span></span><br><span class="line">  &#125;,</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; increment, decrement, incrementByAmount &#125; = counterSlice.<span class="property">actions</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> counterSlice.<span class="property">reducer</span></span><br></pre></td></tr></table></figure>

<p>Redux Toolkit 有一个名为 <code>createSlice</code> 的函数，它负责生成 action 类型字符串、action creator 函数和 action 对象。</p>
<p><code>createSlice</code> 内部使用了一个名为 <a target="_blank" rel="noopener" href="https://immerjs.github.io/immer/">Immer</a> 的库。 Immer 使用一种 “Proxy” 包装你提供的数据，当你尝试 ”mutate“ 这些数据的时候，<strong>Immer 会跟踪你尝试进行的所有更改，然后使用该更改列表返回一个安全的、不可变的更新值</strong>，就好像你手动编写了所有不可变的更新逻辑一样。</p>
<h2 id="Reducer-的规则"><a href="#Reducer-的规则" class="headerlink" title="Reducer 的规则"></a>Reducer 的规则</h2><ul>
<li>仅使用 <code>state</code> 和 <code>action</code> 参数计算新的状态值</li>
<li>禁止直接修改 <code>state</code>。必须通过复制现有的 <code>state</code> 并对复制的值进行更改的方式来做 _不可变更新（immutable updates）_。</li>
<li>禁止任何异步逻辑、依赖随机值或导致其他“副作用”的代码</li>
</ul>
<p>“不可变更新（Immutable Updates）” 这个规则尤其重要，值得进一步讨论。</p>
<h2 id="Reducer-与-Immutable-更新"><a href="#Reducer-与-Immutable-更新" class="headerlink" title="Reducer 与 Immutable 更新"></a>Reducer 与 Immutable 更新</h2><p>在 Redux 中，**<em>永远</em> 不允许在 reducer 中直接更改 state 的原始对象！**</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ❌ 非法 - 默认情况下，这将更改 state！</span></span><br><span class="line">state.<span class="property">value</span> = <span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>这就是为什么 Redux Toolkit 的 createSlice 函数可以让你以更简单的方式编写不可变更新！</strong></p>
<blockquote>
<h5><span class="admonition-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span> 警告</h5>

<p><strong>你 <em>只能</em> 在 Redux Toolkit 的 <code>createSlice</code> 和 <code>createReducer</code> 中编写 “mutation” 逻辑，因为它们在内部使用 Immer！如果你在没有 Immer 的 reducer 中编写 mutation 逻辑，它 <em>将</em> 改变状态并导致错误！</strong></p>
</blockquote>
<h2 id="用-Thunk-编写异步逻辑"><a href="#用-Thunk-编写异步逻辑" class="headerlink" title="用 Thunk 编写异步逻辑"></a>用 Thunk 编写异步逻辑</h2><p>到目前为止，我们应用程序中的所有逻辑都是同步的：</p>
<ol>
<li>dispatch action</li>
<li>store 调用 reducer 来计算新状态</li>
<li>dispatch 函数完成并结束</li>
</ol>
<p>但是，我们的应用程序通常具有异步逻辑，我们需要一个地方在我们的 Redux 应用程序中放置异步逻辑。</p>
<p><strong>thunk</strong> 是一种特定类型的 Redux 函数，可以包含异步逻辑。Thunk 是使用两个函数编写的：</p>
<ul>
<li>一个内部 thunk 函数，它以 <code>dispatch</code> 和 <code>getState</code> 作为参数</li>
<li>外部创建者函数，它创建并返回 thunk 函数</li>
</ul>
<p>示例：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部的 thunk creator 函数, 它使我们可以执行异步逻辑</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">incrementAsync</span> = amount =&gt; &#123;</span><br><span class="line"> <span class="comment">// 内部的 thunk 函数</span></span><br><span class="line"> <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="title function_">dispatch</span>(<span class="title function_">incrementByAmount</span>(amount)) <span class="comment">// 调用dispatch修改store</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显然，<code>incrementAsync()</code> 返回的不是 action（action 是具有<code>type</code>字段的纯函数），而是一个函数，但它的使用方式和普通的 action 是一样的：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> dispatch = <span class="title function_">useAppDispatch</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">   	<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">()</span>=&gt;</span>dispatch(increment()) &gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   	<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">()</span>=&gt;</span>dispatch(incrementAsync()) &gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是依赖 “<strong>middleware</strong>” 机制实现的，Redux 的 store 可以使用 “middleware” 进行扩展，中间件是一种可以添加额外功能的附加组件或插件。其最常见的用途就是实现异步逻辑，同时仍能与 store 对话。</p>
<p>Redux Thunk 中间件，代码很短：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">thunkMiddleware</span> =</span><br><span class="line"> (<span class="params">&#123; dispatch, getState &#125;</span>) =&gt;</span><br><span class="line"> <span class="function"><span class="params">next</span> =&gt;</span></span><br><span class="line"> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title function_">action</span>(dispatch, getState) <span class="comment">// 这里面允许调用dispatch修改store</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">next</span>(action)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>它先判断传入 <code>dispatch</code> 的 action 是函数还是对象。如果是一个函数，则调用函数，并返回结果。否则，传入的是普通 action 对象，就把这个 action 传递给 store 处理。</p>
<h2 id="React-Counter-组件"><a href="#React-Counter-组件" class="headerlink" title="React Counter 组件"></a>React Counter 组件</h2><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useSelector, useDispatch &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; decrement, increment, incrementByAmount, incrementAsync, selectCount &#125; <span class="keyword">from</span> <span class="string">&quot;./counterSlice&quot;</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&quot;./Counter.module.css&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> count = <span class="title function_">useSelector</span>(selectCount)</span><br><span class="line"> <span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>()</span><br><span class="line"> <span class="keyword">const</span> [incrementAmount, setIncrementAmount] = <span class="title function_">useState</span>(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;styles.row&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&#123;styles.button&#125;</span> <span class="attr">aria-label</span>=<span class="string">&quot;Increment value&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(increment())&#125;&gt;</span></span><br><span class="line"><span class="language-xml">     +</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;styles.value&#125;</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&#123;styles.button&#125;</span> <span class="attr">aria-label</span>=<span class="string">&quot;Decrement value&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(decrement())&#125;&gt;</span></span><br><span class="line"><span class="language-xml">     -</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   &#123;/* 这里省略了额外的 render 代码 */&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-useSelector-提取数据"><a href="#使用-useSelector-提取数据" class="headerlink" title="使用 useSelector 提取数据"></a>使用 useSelector 提取数据</h3><p><code>useSelector</code> 这个 hook 让我们的组件从 Redux 的 store 状态树中提取它需要的任何数据。</p>
<p>我们默认 组件中不能引入 store。所以<code>useSelector</code>负责在幕后与 Redux store 对话。</p>
<p>示例：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> countPlusTwo = <span class="title function_">useSelector</span>(<span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">counter</span>.<span class="property">value</span> + <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><code>useSelector</code> 会调用 <code>store.getState()</code> 获取 state，然后返回 <code>state.counter.value + 2</code> 的值。</p>
<p>每当一个 action 被 dispatch 并且 Redux store 被更新时，<code>useSelector</code> 将重新运行我们的选择器函数。如果选择器返回的值与上次不同，<code>useSelector</code> 将确保我们的组件使用新值重新渲染。</p>
<h3 id="使用-useDispatch-来-dispatch-action"><a href="#使用-useDispatch-来-dispatch-action" class="headerlink" title="使用 useDispatch 来 dispatch action"></a>使用 useDispatch 来 dispatch action</h3><p>类似地，我们知道如果我们可以访问 Redux store，可以 <code>store.dispatch(increment())</code>。</p>
<p>由于我们无法访问 store 本身，因此我们需要某种方式来访问 <code>dispatch</code> 方法。</p>
<p><code>useDispatch</code> hook 为我们完成了这项工作，并从 Redux store 中为我们提供了实际的 <code>dispatch</code> 方法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>()</span><br></pre></td></tr></table></figure>

<h2 id="组件-State-与表单"><a href="#组件-State-与表单" class="headerlink" title="组件 State 与表单"></a>组件 State 与表单</h2><p><strong>在 React + Redux 应用中，你的全局状态应该放在 Redux store 中，你的本地状态应该保留在 React 组件中。</strong></p>
<p><strong>大多数表单的 state 不应该保存在 Redux 中。</strong> 相反，在编辑表单的时候把数据存到表单组件中，当用户提交表单的时候再 dispatch action 来更新 store。</p>
<h2 id="Providing-the-Store"><a href="#Providing-the-Store" class="headerlink" title="Providing the Store"></a>Providing the Store</h2><p>我们已经看到我们的组件可以使用 <code>useSelector</code> 和 <code>useDispatch</code> 这两个 hook 与 Redux 的 store 通信。奇怪的是，我们并没有导入 store，那么这些 hooks 怎么知道要与哪个 Redux store 对话呢？</p>
<p>答案是使用 <code>Context</code>：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRoot &#125; <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; store &#125; <span class="keyword">from</span> <span class="string">&quot;app/store&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>)!</span><br><span class="line"><span class="keyword">const</span> root = <span class="title function_">createRoot</span>(container)</span><br><span class="line"></span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>我们可以使用 Redux Toolkit configureStore API 创建一个 Redux store</p>
<ul>
<li><code>configureStore</code> 接收 <code>reducer</code> 函数来作为命名参数</li>
<li><code>configureStore</code> 自动使用默认值来配置 store</li>
</ul>
</li>
<li><p>在 slice 文件中编写 Redux 逻辑</p>
<ul>
<li>一个 slice 包含一个特定功能或部分的 state 相关的 reducer 逻辑和 action</li>
<li>Redux Toolkit 的 <code>createSlice</code> API 为你提供的每个 reducer 函数生成 action creator 和 action 类型</li>
</ul>
</li>
<li><p>Redux reducer 必须遵循以下原则</p>
<ul>
<li>必须依赖 <code>state</code> 和 <code>action</code> 参数去计算出一个新 state</li>
<li>如果要修改 state，只能先拷贝 state 副本，然后去修改副本</li>
<li>不能包含任何异步逻辑或其他副作用</li>
<li>Redux Toolkit 的 <code>createSlice</code> API 内部使用了 Immer 库才达到表面上直接修改（”mutating”）state 也实现不可变更新（_immutable updates_）的效果</li>
</ul>
</li>
<li><p>一般使用 “thunks” 来开发特定的异步逻辑</p>
<ul>
<li>Thunks 接收 <code>dispatch</code> 和 <code>getState</code> 作为参数</li>
<li>Redux Toolkit 内置并默认启用了 <code>redux-thunk</code> 中间件</li>
</ul>
</li>
<li><p>使用 React-Redux 来做 React 组件和 Redux store 的通信</p>
<ul>
<li>在应用程序根组件包裹 <code>&lt;Provider store=&#123;store&#125;&gt;</code> 使得所有组件都能访问到 store</li>
<li>全局状态应该维护在 Redux store 内，局部状态应该维护在局部 React 组件内</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/%E5%B7%A5%E5%85%B7/ubuntu/ubuntu2022.04%E5%AE%89%E8%A3%85SecureCRT9.3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%B7%A5%E5%85%B7/ubuntu/ubuntu2022.04%E5%AE%89%E8%A3%85SecureCRT9.3/" class="post-title-link" itemprop="url">ubuntu2022.04安装SecureCRT9.3</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-29 16:13:10 / 修改时间：16:58:22" itemprop="dateCreated datePublished" datetime="2023-05-29T16:13:10+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7/ubuntu/" itemprop="url" rel="index"><span itemprop="name">ubuntu</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <ol>
<li><p>官网下载 SecureCRT 9.3.2：<a target="_blank" rel="noopener" href="https://www.vandyke.com/cgi-bin/account_login.php?pid=scrt_ubuntu2264_deb_932">https://www.vandyke.com/cgi-bin/account_login.php?pid=scrt_ubuntu2264_deb_932</a></p>
</li>
<li><p>安装：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i scrt-9.3.2-2978.ubuntu22-64.x86_64.deb</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>securecrt_linux_crack.pl</code> 文件：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/perl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> strict;</span><br><span class="line"><span class="keyword">use</span> warnings;</span><br><span class="line"><span class="keyword">use</span> File::Copy <span class="string">qw(move)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">license</span> </span>&#123;</span><br><span class="line"> <span class="keyword">print</span> <span class="string">&quot;\n&quot;</span>.</span><br><span class="line"> <span class="string">&quot;License:\n\n&quot;</span>.</span><br><span class="line"> <span class="string">&quot;\tName:\t\tygeR\n&quot;</span>.</span><br><span class="line"> <span class="string">&quot;\tCompany:\tTEAM ZWT\n&quot;</span>.</span><br><span class="line"> <span class="string">&quot;\tSerial Number:\t03-69-167482\n&quot;</span>.</span><br><span class="line"> <span class="string">&quot;\tLicense Key:\tACM9SP KG5KUX E276JS N3NEMG ACM2M3 Q9FSC4 116U6V GDEPA2\n&quot;</span>.</span><br><span class="line"> <span class="string">&quot;\tIssue Date:\t04-24-2023\n\n\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">usage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">print</span> <span class="string">&quot;\n&quot;</span>.</span><br><span class="line"> <span class="string">&quot;help:\n\n&quot;</span>.</span><br><span class="line"> <span class="string">&quot;\tperl securecrt_forgeek_crack.pl &lt;file&gt;\n\n\n&quot;</span>.</span><br><span class="line"> <span class="string">&quot;\tperl securecrt_forgeek_crack.pl /usr/bin/SecureCRT\n\n\n&quot;</span>.</span><br><span class="line">    <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"> &amp;license;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br><span class="line">&amp;usage() <span class="keyword">if</span> ! <span class="keyword">defined</span> $ARGV[<span class="number">0</span>] ;</span><br></pre></td></tr></table></figure>


<p>my $file &#x3D; $ARGV[0];</p>
<p>open FP, $file or die “can not open file $!”;<br>binmode FP;</p>
<p>open TMPFP, ‘&gt;’, ‘&#x2F;tmp&#x2F;.securecrt.tmp’ or die “can not open file $!”;</p>
<p>my $buffer;<br>my $unpack_data;<br>my $crack &#x3D; 0;</p>
<p>while(read(FP, $buffer, 1024)) {<br>$unpack_data &#x3D; unpack(‘H*’, $buffer);<br>if ($unpack_data &#x3D;~ m&#x2F;785782391ad0b9169f17415dd35f002790175204e3aa65ea10cff20818&#x2F;) {<br>    $crack &#x3D; 1;<br>    last;<br>}<br>if ($unpack_data &#x3D;~ s&#x2F;6e533e406a45f0b6372f3ea10717000c7120127cd915cef8ed1a3f2c5b&#x2F;785782391ad0b9169f17415dd35f002790175204e3aa65ea10cff20818&#x2F; ){<br>    $buffer &#x3D; pack(‘H*’, $unpack_data);<br>    $crack &#x3D; 2;<br>}<br>syswrite(TMPFP, $buffer, length($buffer));<br>}</p>
<p>close(FP);<br>close(TMPFP);</p>
<p>if ($crack &#x3D;&#x3D; 1) {<br>    unlink ‘&#x2F;tmp&#x2F;.securecrt.tmp’ or die “can not delete files $!”;<br>    print “It has been cracked\n”;<br>    &amp;license;<br>    exit 1;<br>} elsif ($crack &#x3D;&#x3D; 2) {<br>    move ‘&#x2F;tmp&#x2F;.securecrt.tmp’, $file or die ‘Insufficient privileges, please switch the root account.’;<br>    chmod 0755, $file or die ‘Insufficient privileges, please switch the root account.’;<br>    print “crack successful\n”;<br>    &amp;license;<br>} else {<br>die ‘error’;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 破解：</span><br><span class="line"></span><br><span class="line">   ```sh</span><br><span class="line">   sudo chmod +x securecrt_linux_crack.pl</span><br><span class="line">   cp /usr/bin/SecureCRT /tmp/       # 拷贝SecureCRT到/tmp</span><br><span class="line">   ./securecrt_linux_crack.pl /tmp/SecureCRT   # 开始破解，如果破解成功，会提示 crack successful 并输出license信息</span><br><span class="line">   cp /tmp/SecureCRT /usr/bin/       # 将破解后的SecureCRT覆盖原SecureCRT</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 SecureCRT 并输入 license，如果不成功，则随便百度一个 SecureCRT9.3.2 的 license 填上就行，如果百度搜不到，就用 windows 系统生成一个，因为 license 是通用的。</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/%E5%B7%A5%E5%85%B7/ubuntu/%E5%AE%89%E8%A3%85sublime-text4143/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%B7%A5%E5%85%B7/ubuntu/%E5%AE%89%E8%A3%85sublime-text4143/" class="post-title-link" itemprop="url">安装sublime-text4143</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-29 16:13:01 / 修改时间：16:58:22" itemprop="dateCreated datePublished" datetime="2023-05-29T16:13:01+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7/ubuntu/" itemprop="url" rel="index"><span itemprop="name">ubuntu</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>注意：不要直接用系统自带的应用商店安装。</p>
<p><a target="_blank" rel="noopener" href="http://www.sublimetext.com/docs/linux_repositories.html#apt">http://www.sublimetext.com/docs/linux_repositories.html#apt</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gpg --dearmor | sudo <span class="built_in">tee</span> /etc/apt/trusted.gpg.d/sublimehq-archive.gpg &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://download.sublimetext.com/ apt/stable/&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/sublime-text.list</span><br><span class="line"></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install sublime-text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果安装失败</span></span><br><span class="line">sudo apt install apt-transport-https</span><br></pre></td></tr></table></figure>

<h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><ol>
<li>打开页面：<a target="_blank" rel="noopener" href="https://hexed.it/">https://hexed.it/</a></li>
<li>打开文件：<code>/opt/sublime_text/sublime_text</code></li>
<li>搜索 <code>80 78 05 00 0F 94 C1</code> 并替换为 <code>C6 40 05 01 48 85 C9</code></li>
<li>导出 并 覆盖 <code>/opt/sublime_text/sublime_text</code></li>
<li>不出意外的话，破解成功</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/%E5%B7%A5%E5%85%B7/ubuntu/%E5%AE%89%E8%A3%85navicat16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%B7%A5%E5%85%B7/ubuntu/%E5%AE%89%E8%A3%85navicat16/" class="post-title-link" itemprop="url">安装navicat16</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2023-05-29 16:12:37 / 修改时间：16:58:22" itemprop="dateCreated datePublished" datetime="2023-05-29T16:12:37+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B7%A5%E5%85%B7/ubuntu/" itemprop="url" rel="index"><span itemprop="name">ubuntu</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://notabug.org/doublesine/navicat-keygen/src/linux/doc/how-to-use.zh-CN.md">https://notabug.org/doublesine/navicat-keygen/src/linux/doc/how-to-use.zh-CN.md</a></p>
<h2 id="编译安装-navicat-keygen"><a href="#编译安装-navicat-keygen" class="headerlink" title="编译安装 navicat-keygen"></a>编译安装 navicat-keygen</h2><p><a target="_blank" rel="noopener" href="https://notabug.org/doublesine/navicat-keygen/src/linux/doc/how-to-build.zh-CN.md">https://notabug.org/doublesine/navicat-keygen/src/linux/doc/how-to-build.zh-CN.md</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cmake</span><br><span class="line">sudo apt-get install libfmt-dev libssl-dev rapidjson-dev</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> -b linux --single-branch https://notabug.org/doublesine/navicat-keygen.git</span><br><span class="line"><span class="built_in">cd</span> navicat-keygen</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release ..</span><br><span class="line">cmake --build . -- -j12</span><br></pre></td></tr></table></figure>

<h2 id="官网下载-navicat"><a href="#官网下载-navicat" class="headerlink" title="官网下载 navicat"></a>官网下载 navicat</h2><p><a target="_blank" rel="noopener" href="https://www.navicat.com/en/download/navicat-premium">https://www.navicat.com/en/download/navicat-premium</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.navicat.com/download/direct-download?product=navicat16-premium-en.AppImage&amp;location=1</span><br></pre></td></tr></table></figure>

<h2 id="开始注册"><a href="#开始注册" class="headerlink" title="开始注册"></a>开始注册</h2><p><a target="_blank" rel="noopener" href="https://notabug.org/doublesine/navicat-keygen/src/linux/doc/how-to-use.zh-CN.md">https://notabug.org/doublesine/navicat-keygen/src/linux/doc/how-to-use.zh-CN.md</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前位于~/opt目录下</span></span><br><span class="line"><span class="built_in">mkdir</span> navicat16-premium-cs</span><br><span class="line">sudo mount -o loop ~/navicat16-premium-cs.AppImage ~/navicat16-premium-cs</span><br><span class="line"><span class="built_in">cp</span> -r navicat16-premium-cs navicat16-premium-cs-patched</span><br><span class="line">sudo umount navicat16-premium-cs</span><br><span class="line"><span class="built_in">rm</span> -rf navicat16-premium-cs</span><br></pre></td></tr></table></figure>

<p>进入刚才编译安装好的 navicat-keygen&#x2F;build 目录，使用 <code>navicat-patcher</code> 替换官方公钥：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./navicat-patcher ~/opt/navicat16-premium-cs-patched</span><br></pre></td></tr></table></figure>

<p>将文件重新打包成 AppImage：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget <span class="string">&#x27;https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage&#x27;</span></span><br><span class="line"><span class="built_in">chmod</span> +x appimagetool-x86_64.AppImage</span><br><span class="line">./appimagetool-x86_64.AppImage ~/opt/navicat16-premium-cs-patched ~/opt/navicat16-premium-cs-patched.AppImage</span><br></pre></td></tr></table></figure>

<p>运行刚生成的 AppImage：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x ~/opt/navicat16-premium-en-patched.AppImage</span><br><span class="line">~/opt/navicat16-premium-en-patched.AppImage</span><br></pre></td></tr></table></figure>

<p>还是在 navicat-keygen&#x2F;build 目录，<code>navicat-keygen</code> 来生成 <strong>序列号</strong> 和 <strong>激活码</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./navicat-keygen --text ./RegPrivateKey.pem</span><br></pre></td></tr></table></figure>

<p>你会被要求选择 Navicat 产品类别、Navicat 语言版本和填写主版本号。之后一个随机生成的 <strong>序列号</strong> 将会给出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">***************************************************</span><br><span class="line">*       navicat-keygen by @DoubleLabyrinth        *</span><br><span class="line">*                version: 16.0.7.0                *</span><br><span class="line">***************************************************</span><br><span class="line"></span><br><span class="line">[*] Select Navicat product:</span><br><span class="line">0. DataModeler</span><br><span class="line">1. Premium</span><br><span class="line">2. MySQL</span><br><span class="line">3. PostgreSQL</span><br><span class="line">4. Oracle</span><br><span class="line">5. SQLServer</span><br><span class="line">6. SQLite</span><br><span class="line">7. MariaDB</span><br><span class="line">8. MongoDB</span><br><span class="line">9. ReportViewer</span><br><span class="line"></span><br><span class="line">(Input index)&gt; 1</span><br><span class="line"></span><br><span class="line">[*] Select product language:</span><br><span class="line">0. English</span><br><span class="line">1. Simplified Chinese</span><br><span class="line">2. Traditional Chinese</span><br><span class="line">3. Japanese</span><br><span class="line">4. Polish</span><br><span class="line">5. Spanish</span><br><span class="line">6. French</span><br><span class="line">7. German</span><br><span class="line">8. Korean</span><br><span class="line">9. Russian</span><br><span class="line">10. Portuguese</span><br><span class="line"></span><br><span class="line">(Input index)&gt; 1</span><br><span class="line"></span><br><span class="line">[*] Input major version number:</span><br><span class="line">(range: 11 ~ 16, default: 16)&gt; 16</span><br><span class="line"></span><br><span class="line">[*] Serial number:</span><br><span class="line">NAVB-EZF4-7T7X-9MPG</span><br><span class="line"></span><br><span class="line">[*] Your name:</span><br></pre></td></tr></table></figure>

<p>你可以使用这个 <strong>序列号</strong> 来暂时激活 Navicat。</p>
<p>之后你会被要求填写 <strong>用户名</strong> 和 <strong>组织名</strong>。你可以随意填写，但别太长。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[*] Your name: Double Sine</span><br><span class="line">[*] Your organization: PremiumSoft CyberTech Ltd.</span><br><span class="line"></span><br><span class="line">[*] Input request code in Base64: (Double press ENTER to end)</span><br></pre></td></tr></table></figure>

<p>之后你会被要求填写请求码。<strong>注意不要关闭 keygen。</strong></p>
<ol>
<li><strong>断开网络</strong>. 找到注册窗口，填写 keygen 给你的 <strong>序列号</strong>，然后点击 <code>激活</code>。</li>
<li>通常在线激活会失败，所以在弹出的提示中选择 <code>手动激活</code>。</li>
<li>复制 <strong>请求码</strong> 到 keygen，连按两次回车结束。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[*] Input request code in Base64: (Double press ENTER to end)</span><br><span class="line">ds7CnjEnNL+8Rme9Q5iD+3t9Tfuq9W6FzVN/3UZwC5zzecmM9EwyHJuZSovKJNSBTzL6AiGyxliTuKPWmLqAdwiKGLuD+mSaZ0syk0jTakVbXmbAk9maFkTz8SK5jMwnQVM/WBZcI0z2Jg1GnOCZVClu/Lo3/WF+XncS+alc2gshG9dUaI44Cqfvp/u1/EYso5fX/bjeBXaFW1/zj+uuRjVv5l0gt7JsTh9byGVxSDTO4zI64Iz9+58QYCbI9zKM+3G9Gou0UlNKjDYw4gN5+4dpiWAjitVTcL3oQzvflgAXjGlT/P6MA+8Xb5PEPJrEdxsErJObxBhO4cTH52wKoQ==</span><br><span class="line"></span><br><span class="line">[*] Request Info:</span><br><span class="line">&#123;&quot;K&quot;:&quot;NAVBEZF47T7X9MPG&quot;, &quot;DI&quot;:&quot;AFCFB038A240942D8776&quot;, &quot;P&quot;:&quot;linux&quot;&#125;</span><br><span class="line"></span><br><span class="line">[*] Response Info:</span><br><span class="line">&#123;&quot;K&quot;:&quot;NAVBEZF47T7X9MPG&quot;,&quot;DI&quot;:&quot;AFCFB038A240942D8776&quot;,&quot;N&quot;:&quot;Double Sine&quot;,&quot;O&quot;:&quot;PremiumSoft CyberTech Ltd.&quot;,&quot;T&quot;:1644837835&#125;</span><br><span class="line"></span><br><span class="line">[*] Activation Code:</span><br><span class="line">OY8Ib0brsepeS99it4s4WTDPQuKgu93WembLJ0bzr6M30Wh24reH1/ocaZ2Ek1bRBi5lqu2xBv/MpAcFUlstJANtavArkFnXYv0ZZiF3VF70De5GMe/VjkreNhjCGtTZcQKr8fabBTPjJuN0P+Hi1xWwMs9zJMuH+MJTmCQpbM4gu86YrFK/EDcdHtA4ZFgUI0SgYW8lwFausLFHp7C4uIQNbjtv4KP3XolDUrAx4lqg6bklgZ9C8ZjUpg28VVR9Ym37b1Fup7Y7C8OjmmMiAp8N5z8m6cA/EjcSLfLOMGf8jsAK0GHz5/AGUqAXWifv9h9cxPA35UgytqI9F2IH/Q==</span><br></pre></td></tr></table></figure>

<p>最终你会得到一个 base64 编码的 <strong>激活码</strong>。</p>
<p>将之复制到 <code>手动激活</code> 的窗口，然后点击 <code>激活</code>。</p>
<p>如果没有什么意外，应该可以成功激活。</p>
<p>最后清理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rm ~/opt/navicat16-premium-cs.AppImage</span><br><span class="line">$ rm -rf ~/opt/navicat16-premium-cs-patched</span><br><span class="line">$ mv ~/opt/navicat16-premium-cs-patched.AppImage ~/opt/navicat16-premium-cs.AppImage</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/%E5%89%8D%E7%AB%AF/Vue3/Proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%89%8D%E7%AB%AF/Vue3/Proxy/" class="post-title-link" itemprop="url">Proxy</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-23 15:45:17" itemprop="dateCreated datePublished" datetime="2023-02-23T15:45:17+08:00">2023-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-29 16:58:22" itemprop="dateModified" datetime="2023-05-29T16:58:22+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/Vue3/" itemprop="url" rel="index"><span itemprop="name">Vue3</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>MDN：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
<p><strong>Proxy</strong> 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>target</code>：要使用<code>Proxy</code>包装的目标对象（可以是任何类型的对象，包括原生数组、函数、甚至另一个代理）。</li>
<li><code>handler</code>：一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理<code>p</code>的行为。</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Proxy</span>.<span class="title function_">revocable</span>()</span><br></pre></td></tr></table></figure>

<p>创建一个可撤销的<code>Proxy</code>对象。</p>
<h2 id="handler对象的方法"><a href="#handler对象的方法" class="headerlink" title="handler对象的方法"></a>handler对象的方法</h2><p><code>handler</code>对象是一个容纳一批特定属性的占位符对象。它包含有<code>Proxy</code>的各个捕获器（trap）。</p>
<p>所有的捕获器是可选的。如果没有定义某个捕获器，那么就会保留源对象的默认行为。</p>
<h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h3><p><strong><code>handler.getPrototypeOf()</code></strong> 是一个代理（Proxy）方法，当读取代理对象的原型时，该方法就会被调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> monster1 = &#123;</span><br><span class="line">  <span class="attr">eyeCount</span>: <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> monsterPrototype = &#123;</span><br><span class="line">  <span class="attr">eyeCount</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="title function_">getPrototypeOf</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> monsterPrototype;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy1 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(monster1, handler);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proxy1) === monsterPrototype);</span><br><span class="line"><span class="comment">// Expected output: true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proxy1).<span class="property">eyeCount</span>);</span><br><span class="line"><span class="comment">// Expected output: 2</span></span><br></pre></td></tr></table></figure>

<h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h3><p><strong><code>handler.setPrototypeOf()</code></strong> 方法主要用来拦截 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf()</code></a>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">setPrototypeOf</span>: <span class="keyword">function</span>(<span class="params">target, prototype</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h3><p><strong>handler.isExtensible()</strong> 方法用于拦截对对象的 Object.isExtensible()。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> monster1 = &#123;</span><br><span class="line">  <span class="attr">canEvolve</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler1 = &#123;</span><br><span class="line">  <span class="title function_">isExtensible</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">isExtensible</span>(target);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">preventExtensions</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    target.<span class="property">canEvolve</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">preventExtensions</span>(target);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy1 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(monster1, handler1);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(proxy1));    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(monster1.<span class="property">canEvolve</span>);      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(proxy1);      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(proxy1));    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(monster1.<span class="property">canEvolve</span>);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h3><p><strong><code>handler.preventExtensions()</code></strong> 方法用于设置对<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions"><code>Object.preventExtensions()</code></a>的拦截。</p>
<p><code>Object.preventExtensions()</code>方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">preventExtensions</span>: <span class="keyword">function</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> monster1 = &#123;</span><br><span class="line">  <span class="attr">canEvolve</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler1 = &#123;</span><br><span class="line">  <span class="title function_">preventExtensions</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    target.<span class="property">canEvolve</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(target);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy1 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(monster1, handler1);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(monster1.<span class="property">canEvolve</span>);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(proxy1);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(monster1.<span class="property">canEvolve</span>);    <span class="comment">// fasle</span></span><br></pre></td></tr></table></figure>

<h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h3><p><strong><code>handler.getOwnPropertyDescriptor()</code></strong> 方法是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor"><code>Object.getOwnPropertyDescriptor()</code></a> 的钩子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">getOwnPropertyDescriptor</span>: <span class="keyword">function</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123; <span class="attr">a</span>: <span class="number">20</span> &#125;, &#123;</span><br><span class="line">    <span class="title function_">getOwnPropertyDescriptor</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;called: &#x27;</span> + prop)</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="number">10</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(p, <span class="string">&#x27;a&#x27;</span>).<span class="property">value</span>)</span><br><span class="line"><span class="comment">// called: a</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h3><p><strong><code>handler.defineProperty()</code></strong> 用于拦截对象的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty()</code></a> 操作。</p>
<p>vue2的双向绑定就是通过 <code>Object.defineProperty()</code> 实现的。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">defineProperty</span>: <span class="keyword">function</span>(<span class="params">target, property, descriptor</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p><strong><code>handler.has()</code></strong> 方法是针对 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in"><code>in</code></a> 操作符的代理方法。</p>
<p>示例，<code>_</code>开头的属性为私有属性，使用<code>in</code>判断的时候返回<code>false</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler1 = &#123;</span><br><span class="line">  <span class="title function_">has</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> monster1 = &#123;</span><br><span class="line">  <span class="attr">_secret</span>: <span class="string">&#x27;easily scared&#x27;</span>,</span><br><span class="line">  <span class="attr">eyeCount</span>: <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy1 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(monster1, handler1);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;eyeCount&#x27;</span> <span class="keyword">in</span> proxy1);     <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;_secret&#x27;</span> <span class="keyword">in</span> proxy1);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;_secret&#x27;</span> <span class="keyword">in</span> monster1);     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p><strong><code>handler.get()</code></strong> 方法用于拦截对象的读取属性操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, property, receiver</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(&#123; <span class="attr">a</span>: <span class="number">10</span> &#125;, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, prop, receiver</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> target[prop] * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">a</span>)   <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><p><strong><code>handler.set()</code></strong> 方法是设置属性值操作的捕获器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">target, property, value, receiver</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> monster1 = &#123; <span class="attr">eyeCount</span>: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler1 = &#123;</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">obj, prop, value</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((prop === <span class="string">&#x27;eyeCount&#x27;</span>) &amp;&amp; ((value % <span class="number">2</span>) !== <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;必须是偶数&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy1 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(monster1, handler1);</span><br><span class="line"></span><br><span class="line">proxy1.<span class="property">eyeCount</span> = <span class="number">1</span>;    <span class="comment">// 必须是偶数</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy1.<span class="property">eyeCount</span>);  <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">proxy1.<span class="property">eyeCount</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy1.<span class="property">eyeCount</span>);  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><p><strong><code>handler.deleteProperty()</code></strong> 方法用于拦截对对象属性的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete"><code>delete</code></a> 操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">deleteProperty</span>: <span class="keyword">function</span>(<span class="params">target, property</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h3><p><strong><code>handler.ownKeys()</code></strong> 方法用于拦截 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys"><code>Reflect.ownKeys()</code></a>.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> monster1 = &#123;</span><br><span class="line">    <span class="attr">_age</span>: <span class="number">111</span>,</span><br><span class="line">    [<span class="title class_">Symbol</span>(<span class="string">&#x27;secret&#x27;</span>)]: <span class="string">&#x27;I am scared!&#x27;</span>,</span><br><span class="line">    <span class="attr">eyeCount</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy1 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(monster1, &#123;</span><br><span class="line">    <span class="title function_">ownKeys</span>(<span class="params">target</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(target)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(proxy1)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key)</span><br><span class="line">    <span class="comment">// Expected output: &quot;_age&quot;</span></span><br><span class="line">    <span class="comment">// Expected output: &quot;eyeCount&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><p><code>handler.apply()</code> 方法用于拦截函数的调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; a + b</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="attr">apply</span>: <span class="function">(<span class="params">target, _, args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">target</span>(...args) * <span class="number">10</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(sum, handler)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>))      <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">proxy</span>(<span class="number">1</span>, <span class="number">2</span>))     <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<h3 id="construct"><a href="#construct" class="headerlink" title="construct()"></a>construct()</h3><p><strong><code>handler.construct()</code></strong> 方法用于拦截 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new"><code>new</code></a> 操作符。为了使 new 操作符在生成的 Proxy 对象上生效，用于初始化代理的目标对象自身必须具有 [[Construct]] 内部方法（即 <code>new target</code> 必须是有效的）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; a, b &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="attr">construct</span>: <span class="function">(<span class="params">target, args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; args.<span class="property">length</span>; index++) &#123;</span><br><span class="line">            args[index] += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">target</span>(...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(sum, handler)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title function_">proxy</span>(<span class="number">1</span>, <span class="number">2</span>))                <span class="comment">// &#123;a: 2, b: 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>上例中，sum不能是只能是普通函数，不能是箭头函数，因为箭头函数不能new。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/%E5%89%8D%E7%AB%AF/Vue3/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E5%89%8D%E7%AB%AF/Vue3/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/" class="post-title-link" itemprop="url">快速开始</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-23 15:45:05" itemprop="dateCreated datePublished" datetime="2023-02-23T15:45:05+08:00">2023-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-29 16:58:22" itemprop="dateModified" datetime="2023-05-29T16:58:22+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/Vue3/" itemprop="url" rel="index"><span itemprop="name">Vue3</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><h4 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a>attribute</h4><p><code>&#123;&#123;&#125;&#125;</code>不能在 HTML attributes 中使用。想要响应式的绑定一个 attribute，应该使用<code>v-bind</code>指令是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>因为<code>v-bind</code>非常常用，我们提供了特定的简写语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="使用-js-表达式"><a href="#使用-js-表达式" class="headerlink" title="使用 js 表达式"></a>使用 js 表达式</h4><p>实际上，vue 在所有的数据绑定中都支持完整的 js 表达式。</p>
<p>每个帮顶仅支持<strong>单一表达式</strong>，也就是一段能够被求值的 js 代码。一个简单的判断是是否可以合法的写在<code>return</code>后面。</p>
<blockquote>
<p>绑定在表达式中的方法在组件每次更新时都会被重新调用，因此<strong>不</strong>应该产生任何副作用，比如改变数据或触发异步操作。</p>
</blockquote>
<p><strong>受限的全局访问：</strong></p>
<p>模板中的表达式将被沙盒化，仅能够访问到<a target="_blank" rel="noopener" href="https://github.com/vuejs/core/blob/main/packages/shared/src/globalsWhitelist.ts#L3">有限的全局对象列表</a>。该列表中会暴露常用的内置全局对象，比如 <code>Math</code> 和 <code>Date</code>。</p>
<p>没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在 <code>window</code> 上的属性。然而，你也可以自行在 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/application.html#app-config-globalproperties"><code>app.config.globalProperties</code></a> 上显式地添加它们，供所有的 Vue 表达式使用。</p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>指令是带有<code>v-</code>前缀的特殊 attribute，vue 提供了许多<a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/built-in-directives.html">内置指令</a>，包括上面提到的<code>v-bind</code>。</p>
<p>指令 attribute 的期望值是一个 js 表达式（除了<code>v-for</code>、<code>v-on</code>、<code>v-slot</code> 这几个少数的例外）。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。</p>
<p>以<code>v-if</code>为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>这里，<code>v-if</code> 指令会基于表达式 <code>seen</code> 的值的真假来移除&#x2F;插入该 <code>&lt;p&gt;</code> 元素。</p>
<h3 id="响应式基础"><a href="#响应式基础" class="headerlink" title="响应式基础"></a>响应式基础</h3><h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive()"></a><code>reactive()</code></h4><p>我们可以使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-core.html#reactive"><code>reactive()</code></a> 函数创建一个响应式对象或数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="lt-script-setup-gt"><a href="#lt-script-setup-gt" class="headerlink" title="&lt;script setup&gt;"></a><code>&lt;script setup&gt;</code></h4><p>要在组件模板中使用响应式状态，需要在 <code>setup()</code> 函数中定义并返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; reactive &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line"> setup() &#123;</span><br><span class="line">  const state = reactive(&#123; count: 0 &#125;)</span><br><span class="line"></span><br><span class="line">  function increment() &#123;</span><br><span class="line">   state.count++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 不要忘记同时暴露 increment 函数</span><br><span class="line">  return &#123;</span><br><span class="line">   state,</span><br><span class="line">   increment,</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在 setup() 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用构建工具来简化该操作。当使用单文件组件（SFC）时，我们可以使用 <code>&lt;script setup&gt;</code> 来大幅度地简化代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const state = reactive(&#123; count: 0 &#125;)</span><br><span class="line"></span><br><span class="line">function increment() &#123;</span><br><span class="line"> state.count++</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;script setup&gt;</code> 中的顶层的导入和变量声明可在同一组件的模板中直接使用。你可以理解为模板中的表达式和 <code>&lt;script setup&gt;</code> 中的代码处在同一个作用域中。</p>
<h4 id="DOM-更新时机"><a href="#DOM-更新时机" class="headerlink" title="DOM 更新时机"></a>DOM 更新时机</h4><p>当你更改响应式状态后，DOM 会自动更新。然而，你得注意 DOM 的更新并不是同步的。相反，Vue 将缓冲它们直到更新周期的 “下个时机” 以确保无论你进行了多少次状态更改，每个组件都只更新一次。</p>
<p>若要等待一个状态改变后的 DOM 更新完成，你可以使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/general.html#nexttick">nextTick()</a> 这个全局 API：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line"> state.<span class="property">count</span>++</span><br><span class="line"> <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// DOM更新后执行...</span></span><br><span class="line">  <span class="comment">// 访问更新后的DOM</span></span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="深层响应性"><a href="#深层响应性" class="headerlink" title="深层响应性"></a>深层响应性</h4><p>在 Vue 中，状态都是默认深层响应式的。这意味着即使在更改深层次的对象或数组，你的改动也能被检测到。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123;</span><br><span class="line"> <span class="attr">nested</span>: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</span><br><span class="line"> <span class="attr">arr</span>: [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mutateDeeply</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">// 以下都会按照期望工作</span></span><br><span class="line"> obj.<span class="property">nested</span>.<span class="property">count</span>++</span><br><span class="line"> obj.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="string">&quot;baz&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以直接创建一个<a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive">浅层响应式对象</a>。它们仅在顶层具有响应性，一般仅在某些特殊场景中需要。</p>
<h4 id="响应式代理-vs-原始对象"><a href="#响应式代理-vs-原始对象" class="headerlink" title="响应式代理 vs 原始对象"></a>响应式代理 vs 原始对象</h4><p>值得注意的是，reactive() 返回的是一个原始对象的 Proxy，它和原始对象是不相等的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> raw = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="title function_">reactive</span>(raw)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象和原始对象不是全等的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy === raw) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>只有代理对象是响应式的，更改原始对象不会触发更新。因此，使用 vue 的响应式系统的最佳实践是 <strong>仅使用你声明对象的代理版本</strong>。</p>
<p>为保证访问代理的一致性，对同一个原始对象调用<code>reactive()</code>总是返回同样的代理对象，而对一个已存在的代理对象调用<code>reactive()</code>会返回其本身：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在同一个对象上调用 reactive() 会返回相同的代理</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reactive</span>(raw) === proxy) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个代理上调用 reactive() 会返回它自己</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reactive</span>(proxy) === proxy) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这个规则对嵌套对象也适用。依靠深层响应性，<strong>响应式对象内的嵌套对象依然是代理</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="title function_">reactive</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> raw = &#123;&#125;</span><br><span class="line">proxy.<span class="property">nested</span> = raw</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">nested</span> === raw) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="reactive-的局限性"><a href="#reactive-的局限性" class="headerlink" title="reactive()的局限性"></a><code>reactive()</code>的局限性</h4><p>因为 js 没有可以作用于所有值类型的“引用”机制。所以<code>reactive()</code> API 有两条限制：</p>
<ol>
<li>仅对对象类型有效（对象、数组和 <code>Map</code>、<code>Set</code> 这样的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects#%E4%BD%BF%E7%94%A8%E9%94%AE%E7%9A%84%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1">集合类型</a>），而对 <code>string</code>、<code>number</code> 和 <code>boolean</code> 这样的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive">原始类型</a> 无效。</li>
<li>必须始终保持对响应式对象的相同引用。不可以随意地“替换”一个响应式对象，因为这将导致对初始引用的响应性连接丢失：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的引用(&#123;&#123;count: 0&#125;)将不再被追踪（响应性连接已丢失！）</span></span><br><span class="line">state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>同时这也意味着当我们将响应式对象的属性赋值或解构至本地变量时，或是将该属性传入一个函数时，我们会失去响应性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = state.<span class="property">count</span> <span class="comment">// n是一个局部变量，同 state.count 失去响应性连接</span></span><br><span class="line">n++ <span class="comment">// 不影响原始的state.count</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; count &#125; = state <span class="comment">// count也和state.count失去了响应性连接</span></span><br><span class="line">count++ <span class="comment">// 不会影响到原始的state</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">callSomeFunction</span>(state.<span class="property">count</span>) <span class="comment">// 该函数接收一个普通数字，并且将无法跟踪state.count的变化</span></span><br></pre></td></tr></table></figure>

<h4 id="ref"><a href="#ref" class="headerlink" title="ref()"></a><code>ref()</code></h4><p>js 没有可以作用于所有值类型的“引用”机制，为此，vue 提供了一个<code>ref()</code>方法来允许我们创建可以使用任何值类型的响应式 ref：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><code>ref()</code>将传入参数的值包装为一个带<code>.value</code>属性的 ref 对象：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">count</span>: <span class="title class_">Ref</span>&lt;<span class="built_in">number</span>&gt; = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count) <span class="comment">// &#123; value: 0 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">count.<span class="property">value</span>++</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>和响应式对象的属性类似，ref 的 <code>.value</code> 属性也是响应式的。同时，当值为对象类型时，会用 <code>reactive()</code> 自动转换它的 <code>.value</code>。</p>
<p>一个包含对象类型值的 ref 可以响应式地替换整个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> objectRef = <span class="title function_">ref</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是响应式的替换</span></span><br><span class="line">objectRef.<span class="property">value</span> = &#123; <span class="attr">count</span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>ref 被传递给函数或是从一般对象上被解构时，不会丢失响应性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="title function_">ref</span>(<span class="number">1</span>),</span><br><span class="line"> <span class="attr">bar</span>: <span class="title function_">ref</span>(<span class="number">2</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数接收一个 ref</span></span><br><span class="line"><span class="comment">// 需要通过 .value 取值</span></span><br><span class="line"><span class="comment">// 但它会保持响应性</span></span><br><span class="line"><span class="title function_">callSomeFunction</span>(obj.<span class="property">foo</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仍然是响应式的</span></span><br><span class="line"><span class="keyword">const</span> &#123; foo, bar &#125; = obj</span><br></pre></td></tr></table></figure>

<p>简言之，<code>ref()</code> 让我们能创造一种对任意值的 “引用”，并能够在不丢失响应性的前提下传递这些引用。这个功能很重要，因为它经常用于将逻辑提取到 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/reusability/composables.html">组合函数</a> 中。</p>
<h4 id="ref-在模板中的解包"><a href="#ref-在模板中的解包" class="headerlink" title="ref 在模板中的解包"></a>ref 在模板中的解包</h4><p>当 ref 在模板中作为顶层属性被访问时，它们会自动“解包”，所以不需要使用<code>.value</code>，示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const count = ref(0)</span><br><span class="line"></span><br><span class="line">function increment() &#123;</span><br><span class="line"> count.value++</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;button @click=&quot;increment&quot;&gt;</span><br><span class="line">  &#123;&#123; count &#125;&#125;</span><br><span class="line">  &lt;!-- 无需 .value --&gt;</span><br><span class="line"> &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>请注意，仅当 ref 是模板渲染上下文的顶层属性时才适用自动“解包”。 例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">foo</span>: <span class="title function_">ref</span>(<span class="number">1</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>下面的表达式将<strong>不会</strong>像预期的那样工作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &#123;</span><br><span class="line">  object.<span class="property">foo</span> + <span class="number">1</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为此时 ref 所在的上下文是<code>object</code>而不是模板。我们可以将<code>foo</code>提取出来，这样 ref 的上下文就是模板了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; foo &#125; = object</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &#123;</span><br><span class="line">  foo + <span class="number">1</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果是下面这种情况，直接渲染，不参与计算，则也会被自动解包：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &#123;</span><br><span class="line">  object.<span class="property">foo</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="comment">// 相当于 &#123;&#123; object.foo.value &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="ref-在响应式对象中的解包"><a href="#ref-在响应式对象中的解包" class="headerlink" title="ref 在响应式对象中的解包"></a>ref 在响应式对象中的解包</h4><p>当一个<code>ref</code>被嵌套在一个响应式对象中，作为属性被访问或更改时，它会自动解包，因此会表现的和一般属性一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line"> count,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">count</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">state.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>如果将一个新的 ref 赋值给一个关联了已有 ref 的属性，那么它会替换掉旧的 ref：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> otherCount = <span class="title function_">ref</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">state.<span class="property">count</span> = otherCount</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">count</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 原始 ref 现在已经和 state.count 失去了联系</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>只有当嵌套在一个深层响应式对象内时，才会发生 ref 解包，当其作为<a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive">浅层响应式对象</a>的属性被访问时不会解包。</p>
<h4 id="数组和集合类型的-ref-解包"><a href="#数组和集合类型的-ref-解包" class="headerlink" title="数组和集合类型的 ref 解包"></a>数组和集合类型的 ref 解包</h4><p>跟响应式对象不同，当 ref 作为响应式数组或像 <code>Map</code> 这种原生集合类型的元素被访问时，不会进行解包。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> books = <span class="title function_">reactive</span>([<span class="title function_">ref</span>(<span class="string">&quot;Vue 3 Guide&quot;</span>)])</span><br><span class="line"><span class="comment">// 这里需要 .value</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(books[<span class="number">0</span>].<span class="property">value</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="title function_">reactive</span>(<span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&quot;count&quot;</span>, <span class="title function_">ref</span>(<span class="number">0</span>)]]))</span><br><span class="line"><span class="comment">// 这里需要 .value</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="string">&quot;count&quot;</span>).<span class="property">value</span>)</span><br></pre></td></tr></table></figure>

<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; reactive, computed &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const author = reactive(&#123;</span><br><span class="line"> name: &quot;John Doe&quot;,</span><br><span class="line"> books: [&quot;Vue 2 - Advanced Guide&quot;, &quot;Vue 3 - Basic Guide&quot;, &quot;Vue 4 - The Mystery&quot;],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 一个计算属性 ref</span><br><span class="line">const publishedBooksMessage = computed&lt;&quot;Yes&quot; | &quot;No&quot;&gt;(() =&gt; &#123;</span><br><span class="line"> return author.books.length &gt; 0 ? &quot;Yes&quot; : &quot;No&quot;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;p&gt;Has published books:&lt;/p&gt;</span><br><span class="line"> &lt;span&gt;&#123;&#123; publishedBooksMessage &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>我们在这里定义了一个计算属性 <code>publishedBooksMessage</code>。<code>computed()</code> 方法期望接收一个 getter 函数，返回值为一个<strong>计算属性 ref</strong>。和其他一般的 ref 类似，你可以通过 <code>publishedBooksMessage.value</code> 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 <code>.value</code>。</p>
<p>vue 的计算属性会自动追踪响应式依赖。它会检测到 <code>publishedBooksMessage</code> 依赖于 <code>author.books</code>，所以当 <code>author.books</code> 改变时，任何依赖于 <code>publishedBooksMessage</code> 的绑定都会同时更新。</p>
<h4 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h4><p>你可能注意到我们在表达式中像这样调用一个函数也会获得和计算属性相同的结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; <span class="title function_">calculateBooksMessage</span>() &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateBooksMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> author.<span class="property">books</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于<strong>计算属性值会基于其响应式依赖被缓存</strong>。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 <code>author.books</code> 不改变，无论多少次访问 <code>publishedBooksMessage</code> 都会立即返回先前的计算结果，而不用重复执行 getter 函数。</p>
<p>这也解释了为什么下面的计算属性永远不会更新，因为 <code>Date.now()</code> 并不是一个响应式依赖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> now = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> <span class="title class_">Date</span>.<span class="title function_">now</span>())</span><br></pre></td></tr></table></figure>

<p>相比之下，方法调用<strong>总是</strong>会在重渲染发生时再次执行函数。</p>
<p>为什么需要缓存呢？想象一下我们有一个非常耗性能的计算属性 <code>list</code>，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于 <code>list</code>。没有缓存的话，我们会重复执行非常多次 <code>list</code> 的 getter，然而这实际上没有必要！如果你确定不需要缓存，那么也可以使用方法调用。</p>
<h4 id="可写计算属性"><a href="#可写计算属性" class="headerlink" title="可写计算属性"></a>可写计算属性</h4><p>计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> firstName = <span class="title function_">ref</span>(<span class="string">&#x27;John&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> lastName = <span class="title function_">ref</span>(<span class="string">&#x27;Doe&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">  <span class="comment">// getter</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName.<span class="property">value</span> + <span class="string">&#x27; &#x27;</span> + lastName.<span class="property">value</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// setter</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="comment">// 注意：我们这里使用的是解构赋值语法</span></span><br><span class="line">    [firstName.<span class="property">value</span>, lastName.<span class="property">value</span>] = newValue.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>现在当你再运行 <code>fullName.value = &#39;John Doe&#39;</code> 时，setter 会被调用而 <code>firstName</code> 和 <code>lastName</code> 会随之更新。</p>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><h5 id="Getter-不应有副作用"><a href="#Getter-不应有副作用" class="headerlink" title="Getter 不应有副作用"></a>Getter 不应有副作用</h5><p>计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。举例来说，<strong>不要在 getter 中做异步请求或者更改 DOM</strong>！一个计算属性的声明中描述的是如何根据其他值派生一个值。因此 getter 的职责应该仅为计算和返回该值。在之后的指引中我们会讨论如何使用<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/watchers.html">监听器</a>根据其他响应式状态的变更来创建副作用。</p>
<h5 id="避免直接修改计算属性值"><a href="#避免直接修改计算属性值" class="headerlink" title="避免直接修改计算属性值"></a>避免直接修改计算属性值</h5><p>从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。</p>
<h3 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h3><p>因为 <code>class</code> 和 <code>style</code> 都是 attribute，我们可以和其他 attribute 一样使用 <code>v-bind</code> 将它们和动态的字符串绑定。但是，在处理比较复杂的绑定时，通过拼接生成字符串是麻烦且易出错的。因此，Vue 专门为 <code>class</code> 和 <code>style</code> 的 <code>v-bind</code> 用法提供了特殊的功能增强。除了字符串外，表达式的值也可以是对象或数组。</p>
<h4 id="绑定-HTML-class"><a href="#绑定-HTML-class" class="headerlink" title="绑定 HTML class"></a>绑定 HTML class</h4><h5 id="绑定对象"><a href="#绑定对象" class="headerlink" title="绑定对象"></a>绑定对象</h5><p><code>:class</code> 是 <code>v-bind:class</code> 的缩写。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以直接绑定一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> classObject = <span class="title function_">reactive</span>(&#123;</span><br><span class="line"> <span class="attr">active</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="string">&quot;text-danger&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;classObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以绑定一个返回对象的<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/computed.html">计算属性</a>。这是一个常见且很有用的技巧：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isActive = <span class="title function_">ref</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">const</span> error = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> classObject = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> (&#123;</span><br><span class="line"> <span class="attr">active</span>: isActive.<span class="property">value</span> &amp;&amp; !error.<span class="property">value</span>,</span><br><span class="line"> <span class="string">&quot;text-danger&quot;</span>: error.<span class="property">value</span> &amp;&amp; error.<span class="property">value</span>.<span class="property">type</span> === <span class="string">&quot;fatal&quot;</span>,</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;classObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="绑定数组"><a href="#绑定数组" class="headerlink" title="绑定数组"></a>绑定数组</h5><p>我们可以给 <code>:class</code> 绑定一个数组来渲染多个 CSS class：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> activeClass = <span class="title function_">ref</span>(<span class="string">&quot;active&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> errorClass = <span class="title function_">ref</span>(<span class="string">&quot;text-danger&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染的结果是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;active text-danger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你也想在数组中有条件地渲染某个 class，你可以使用三元表达式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然而，这可能在有多个依赖条件的 class 时会有些冗长。因此也可以在数组中嵌套对象：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[&#123; active: isActive &#125;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="在组件上使用"><a href="#在组件上使用" class="headerlink" title="在组件上使用"></a>在组件上使用</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;foo bar&quot;</span>&gt;</span>Hi!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在使用组件时 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">class</span>=<span class="string">&quot;baz boo&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 渲染出的 HTML 为 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;foo bar baz boo&quot;</span>&gt;</span>Hi<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h4><h5 id="绑定对象-1"><a href="#绑定对象-1" class="headerlink" title="绑定对象"></a>绑定对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> activeColor = <span class="title function_">ref</span>(<span class="string">&quot;red&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> fontSize = <span class="title function_">ref</span>(<span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; &#x27;font-size&#x27;: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>直接绑定一个样式对象通常是一个好主意，这样可以使模板更加简洁：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> styleObject = <span class="title function_">reactive</span>(&#123;</span><br><span class="line"> <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line"> <span class="attr">fontSize</span>: <span class="string">&quot;13px&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;styleObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同样的，如果样式对象需要更复杂的逻辑，也可以使用返回样式对象的计算属性。</p>
<h5 id="绑定数组-1"><a href="#绑定数组-1" class="headerlink" title="绑定数组"></a>绑定数组</h5><p>我们还可以给 <code>:style</code> 绑定一个包含多个样式对象的数组。这些对象会被合并后渲染到同一元素上：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;[baseStyles, overridingStyles]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="自动前缀"><a href="#自动前缀" class="headerlink" title="自动前缀"></a>自动前缀</h5><h5 id="样式多值"><a href="#样式多值" class="headerlink" title="样式多值"></a>样式多值</h5><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a><code>v-if</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span>B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span>C<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>Not A/B/C<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个 <code>v-else</code> 元素必须跟在一个 <code>v-if</code> 或者 <code>v-else-if</code> 元素后面，否则它将不会被识别。</p>
<p><code>v-if</code>、<code>v-else</code> 和 <code>v-else-if</code> 也可以在 <code>&lt;template&gt;</code> 上使用。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;ok&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a><code>v-show</code></h4><p>另一个可以用来按条件显示一个元素的指令是 <code>v-show</code>。其用法基本一样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;ok&quot;</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不同之处在于 <code>v-show</code> 会在 DOM 渲染中保留该元素；<code>v-show</code> 仅切换了该元素上名为 <code>display</code> 的 CSS 属性。</p>
<p><code>v-show</code> 不支持在 <code>&lt;template&gt;</code> 元素上使用，也不能和 <code>v-else</code> 搭配使用。</p>
<h4 id="v-if-和-v-show"><a href="#v-if-和-v-show" class="headerlink" title="v-if 和 v-show"></a><code>v-if</code> 和 <code>v-show</code></h4><p><code>v-if</code> 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。</p>
<p><code>v-if</code> 也是<strong>惰性</strong>的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。</p>
<p>相比之下，<code>v-show</code> 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS <code>display</code> 属性会被切换。</p>
<p><strong>总的来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 <code>v-show</code> 较好；如果在运行时绑定条件很少改变，则 <code>v-if</code> 会更合适。</strong></p>
<h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a><code>v-for</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="title function_">ref</span>([&#123; <span class="attr">message</span>: <span class="string">&quot;Foo&quot;</span> &#125;, &#123; <span class="attr">message</span>: <span class="string">&quot;Bar&quot;</span> &#125;])</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span>&#123;&#123; item.message &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你也可以使用 <code>of</code> 作为分隔符来替代 <code>in</code>，这更接近 JavaScript 的迭代器语法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item of items&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-for-与对象"><a href="#v-for-与对象" class="headerlink" title="v-for 与对象"></a><code>v-for</code> 与对象</h4><p>你也可以使用 <code>v-for</code> 来遍历一个对象的所有属性。遍历的顺序会基于对该对象调用 <code>Object.keys()</code> 的返回值来决定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = <span class="title function_">reactive</span>(&#123;</span><br><span class="line"> <span class="attr">title</span>: <span class="string">&quot;How to do lists in Vue&quot;</span>,</span><br><span class="line"> <span class="attr">author</span>: <span class="string">&quot;Jane Doe&quot;</span>,</span><br><span class="line"> <span class="attr">publishedAt</span>: <span class="string">&quot;2016-04-10&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in myObject&quot;</span>&gt;</span>&#123;&#123; value &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 可以通过提供第二个参数表示属性名 (例如 key) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key) in myObject&quot;</span>&gt;</span>&#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第三个参数表示位置索引 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key, index) in myObject&quot;</span>&gt;</span>&#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="在-v-for-里使用范围值"><a href="#在-v-for-里使用范围值" class="headerlink" title="在 v-for 里使用范围值"></a>在 v-for 里使用范围值</h4><p><code>v-for</code> 可以直接接受一个整数值。在这种用例中，会将该模板基于 <code>1...n</code> 的取值范围重复多次。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;n in 10&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意此处 <code>n</code> 的初值是从 <code>1</code> 开始而非 <code>0</code>。</p>
<h4 id="lt-template-gt-上的-v-for"><a href="#lt-template-gt-上的-v-for" class="headerlink" title="&lt;template&gt; 上的 v-for"></a><code>&lt;template&gt;</code> 上的 <code>v-for</code></h4><p>与模板上的 <code>v-if</code> 类似，你也可以在 <code>&lt;template&gt;</code> 标签上使用 <code>v-for</code> 来渲染一个包含多个元素的块。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; item.msg &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;divider&quot;</span> <span class="attr">role</span>=<span class="string">&quot;presentation&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-for-和-v-if"><a href="#v-for-和-v-if" class="headerlink" title="v-for 和 v-if"></a><code>v-for</code> 和 <code>v-if</code></h4><blockquote>
<p>警告：</p>
<p>同时使用 <code>v-if</code> 和 <code>v-for</code> 是<strong>不推荐的</strong>，因为这样二者的优先级不明显。请查看<a target="_blank" rel="noopener" href="https://cn.vuejs.org/style-guide/rules-essential.html#avoid-v-if-with-v-for">风格指南</a>获得更多信息。</p>
</blockquote>
<p>当它们同时存在于一个节点上时，<code>v-if</code> 比 <code>v-for</code> 的优先级更高。这意味着 <code>v-if</code> 的条件将无法访问到 <code>v-for</code> 作用域内定义的变量别名：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 这会抛出一个错误，因为属性 todo 此时</span></span><br><span class="line"><span class="comment"> 没有在该实例上定义</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!todo.isComplete&quot;</span>&gt;</span>&#123;&#123; todo.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在外新包装一层 <code>&lt;template&gt;</code> 再在其上使用 <code>v-for</code> 可以解决这个问题 (这也更加明显易读)：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-if</span>=<span class="string">&quot;!todo.isComplete&quot;</span>&gt;</span>&#123;&#123; todo.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="通过-key-管理状态"><a href="#通过-key-管理状态" class="headerlink" title="通过 key 管理状态"></a>通过 key 管理状态</h4><p>vue 默认按照“就地更新”的策略来更新通过 <code>v-for</code> 渲染的元素列表。当数据项的顺序改变时，vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。</p>
<p>默认模式是高效的，但<strong>只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况</strong>。</p>
<p>为了给 vue 一个提示，以便它可以跟踪每个节点的标识，从而重用和重新排序现有的元素，你需要为每个元素对应的块提供一个唯一的 <code>key</code> attribute：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当你使用 <code>&lt;template v-for&gt;</code> 时，<code>key</code> 应该被放置在这个 <code>&lt;template&gt;</code> 容器上：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;todo.name&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; todo.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：<code>key</code> 在这里是一个通过 <code>v-bind</code> 绑定的特殊 attribute。请不要和<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/list.html#v-for-with-an-object">在 <code>v-for</code> 中使用对象</a>里所提到的对象属性名相混淆。</p>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/style-guide/rules-essential.html#use-keyed-v-for">推荐</a>在任何可行的时候为 <code>v-for</code> 提供一个 <code>key</code> attribute，除非所迭代的 DOM 内容非常简单 (例如：不包含组件或有状态的 DOM 元素)，或者你想有意采用默认行为来提高性能。</p>
<p><code>key</code> 绑定的值期望是一个基础类型的值，例如字符串或 number 类型。不要用对象作为 <code>v-for</code> 的 key。关于 <code>key</code> attribute 的更多用途细节，请参阅 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/built-in-special-attributes.html#key"><code>key</code> API 文档</a>。</p>
<h4 id="组件上使用v-for"><a href="#组件上使用v-for" class="headerlink" title="组件上使用v-for"></a>组件上使用<code>v-for</code></h4><p>我们可以直接在组件上使用 <code>v-for</code>，和在一般的元素上使用没有区别 (别忘记提供一个 <code>key</code>)：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是，这不会自动将任何数据传递给组件，因为组件有自己独立的作用域。为了将迭代后的数据传递到组件中，我们还需要传递 props：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in items&quot;</span> <span class="attr">:item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">:index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>不自动将 <code>item</code> 注入组件的原因是，这会使组件与 <code>v-for</code> 的工作方式紧密耦合。明确其数据的来源可以使组件在其他情况下重用。</p>
<h4 id="数组变化侦测"><a href="#数组变化侦测" class="headerlink" title="数组变化侦测"></a>数组变化侦测</h4><h5 id="变更方法"><a href="#变更方法" class="headerlink" title="变更方法"></a>变更方法</h5><p>vue 能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新。这些变更方法包括：</p>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
<h5 id="替换一个数组"><a href="#替换一个数组" class="headerlink" title="替换一个数组"></a>替换一个数组</h5><p>变更方法，顾名思义，就是会对调用它们的原数组进行变更。相对地，也有一些不可变 (immutable) 方法，例如 <code>filter()</code>，<code>concat()</code> 和 <code>slice()</code>，这些都不会更改原数组，而总是<strong>返回一个新数组</strong>。当遇到的是非变更方法时，我们需要将旧的数组替换为新的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `items` 是一个数组的 ref</span></span><br><span class="line">items.<span class="property">value</span> = items.<span class="property">value</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">message</span>.<span class="title function_">match</span>(<span class="regexp">/Foo/</span>))</span><br></pre></td></tr></table></figure>

<p>你可能认为这将导致 vue 丢弃现有的 DOM 并重新渲染整个列表——幸运的是，情况并非如此。vue 实现了一些巧妙的方法来最大化对 DOM 元素的重用，因此用另一个包含部分重叠对象的数组来做替换，仍会是一种非常高效的操作。</p>
<h4 id="展示过滤或排序后的结果"><a href="#展示过滤或排序后的结果" class="headerlink" title="展示过滤或排序后的结果"></a>展示过滤或排序后的结果</h4><p>有时，我们希望显示数组经过过滤或排序后的内容，而不实际变更或重置原始数据。在这种情况下，你可以创建返回已过滤或已排序数组的计算属性。</p>
<p>举例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = <span class="title function_">ref</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> evenNumbers = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> numbers.<span class="property">value</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;n in evenNumbers&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在计算属性不可行的情况下 (例如在多层嵌套的 <code>v-for</code> 循环中)，你可以使用以下方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sets = <span class="title function_">ref</span>([</span><br><span class="line"> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line"> [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>],</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">even</span>(<span class="params">numbers</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> numbers.<span class="title function_">filter</span>(<span class="function"><span class="params">number</span> =&gt;</span> number % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-for</span>=<span class="string">&quot;numbers in sets&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;n in even(numbers)&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在计算属性中使用 <code>reverse()</code> 和 <code>sort()</code> 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- return numbers.reverse()</span></span><br><span class="line"><span class="addition">+ return [...numbers].reverse()</span></span><br></pre></td></tr></table></figure>

<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><h4 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h4><p>我们可以使用 <code>v-on</code> 指令 (简写为 <code>@</code>) 来监听 DOM 事件，并在事件触发时执行对应的 JavaScript。用法：<code>v-on:click=&quot;methodName&quot;</code> 或 <code>@click=&quot;handler&quot;</code>。</p>
<p>事件处理器的值可以是：</p>
<ol>
<li><strong>内联事件处理器</strong>：事件被触发时执行的内联 JavaScript 语句 (与 <code>onclick</code> 类似)。</li>
<li><strong>方法事件处理器</strong>：一个指向组件上定义的方法的属性名或是路径。</li>
</ol>
<h4 id="内联事件处理器"><a href="#内联事件处理器" class="headerlink" title="内联事件处理器"></a>内联事件处理器</h4><p>内联事件处理器通常用于简单场景，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>Add 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Count is: &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="方法事件处理器"><a href="#方法事件处理器" class="headerlink" title="方法事件处理器"></a>方法事件处理器</h4><p>随着事件处理器的逻辑变得愈发复杂，内联代码方式变得不够灵活。因此 <code>v-on</code> 也可以接受一个方法名或对某个方法的调用。</p>
<p>举例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&quot;Vue.js&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">event</span>) &#123;</span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">`Hello <span class="subst">$&#123;name.value&#125;</span>!`</span>)</span><br><span class="line"> <span class="comment">// `event` 是 DOM 原生事件</span></span><br><span class="line"> <span class="keyword">if</span> (event) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(event.<span class="property">target</span>.<span class="property">tagName</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- `greet` 是上面定义过的方法名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;greet&quot;</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方法事件处理器会自动接收原生 DOM 事件并触发执行。在上面的例子中，我们能够通过被触发事件的 <code>event.target.tagName</code> 访问到该 DOM 元素。</p>
<h5 id="方法与内联事件判断"><a href="#方法与内联事件判断" class="headerlink" title="方法与内联事件判断"></a>方法与内联事件判断</h5><p>模板编译器会通过检查 <code>v-on</code> 的值是否是合法的 JavaScript 标识符或属性访问路径来断定是何种形式的事件处理器。举例来说，<code>foo</code>、<code>foo.bar</code> 和 <code>foo[&#39;bar&#39;]</code> 会被视为方法事件处理器，而 <code>foo()</code> 和 <code>count++</code> 会被视为内联事件处理器。</p>
<h4 id="在内联处理器中调用方法"><a href="#在内联处理器中调用方法" class="headerlink" title="在内联处理器中调用方法"></a>在内联处理器中调用方法</h4><p>除了直接绑定方法名，你还可以在内联事件处理器中调用方法。这允许我们向方法传入自定义参数以代替原生事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">say</span>(<span class="params">message</span>) &#123;</span><br><span class="line"> <span class="title function_">alert</span>(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;say(&#x27;hello&#x27;)&quot;</span>&gt;</span>Say hello<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;say(&#x27;bye&#x27;)&quot;</span>&gt;</span>Say bye<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="在内联事件处理器中访问事件参数"><a href="#在内联事件处理器中访问事件参数" class="headerlink" title="在内联事件处理器中访问事件参数"></a>在内联事件处理器中访问事件参数</h4><p>有时我们需要在内联事件处理器中访问原生 DOM 事件。你可以向该处理器方法传入一个特殊的 <code>$event</code> 变量，或者使用内联箭头函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用特殊的 $event 变量 --&gt;</span><br><span class="line">&lt;button @click=&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用内联箭头函数 --&gt;</span><br><span class="line">&lt;button @click=&quot;e =&gt; warn(&#x27;Form cannot be submitted yet.&#x27;, e)&quot;&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">warn</span>(<span class="params">message, event</span>) &#123;</span><br><span class="line"> <span class="comment">// 这里可以访问原生事件</span></span><br><span class="line"> <span class="keyword">if</span> (event) &#123;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>()</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">alert</span>(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><p>在处理事件时调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是很常见的。尽管我们可以直接在方法内调用，但如果方法能更专注于数据逻辑而不用去处理 DOM 事件的细节会更好。</p>
<p>为解决这一问题，Vue 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。修饰符是用 <code>.</code> 表示的指令后缀，包含以下这些：</p>
<ul>
<li><code>.stop</code></li>
<li><code>.prevent</code></li>
<li><code>.self</code></li>
<li><code>.capture</code></li>
<li><code>.once</code></li>
<li><code>.passive</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 单击事件将停止传递 --&gt;</span><br><span class="line">&lt;a @click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交事件将不再重新加载页面 --&gt;</span><br><span class="line">&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰语可以使用链式书写 --&gt;</span><br><span class="line">&lt;a @click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 也可以只有修饰符 --&gt;</span><br><span class="line">&lt;form @submit.prevent&gt;&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 仅当 event.target 是元素本身时才会触发事件处理器 --&gt;</span><br><span class="line">&lt;!-- 例如：事件处理器不来自子元素 --&gt;</span><br><span class="line">&lt;div @click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。因此使用 <code>@click.prevent.self</code> 会阻止<strong>元素及其子元素的所有点击事件的默认行为，</strong>而 <code>@click.self.prevent</code> 则只会阻止对元素本身的点击事件的默认行为。</p>
<p><code>.capture</code>、<code>.once</code> 和 <code>.passive</code> 修饰符与<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#options">原生 <code>addEventListener</code> 事件</a>相对应：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 添加事件监听器时，使用 `capture` 捕获模式 --&gt;</span><br><span class="line">&lt;!-- 例如：指向内部元素的事件，在被内部元素处理前，先被外部处理 --&gt;</span><br><span class="line">&lt;div @click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 点击事件最多被触发一次 --&gt;</span><br><span class="line">&lt;a @click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 滚动事件的默认行为 (scrolling) 将立即发生而非等待 `onScroll` 完成 --&gt;</span><br><span class="line">&lt;!-- 以防其中包含 `event.preventDefault()` --&gt;</span><br><span class="line">&lt;div @scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><code>.passive</code> 修饰符一般用于触摸事件的监听器，可以用来<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#%E4%BD%BF%E7%94%A8_passive_%E6%94%B9%E5%96%84%E6%BB%9A%E5%B1%8F%E6%80%A7%E8%83%BD">改善移动端设备的滚屏性能</a>。</p>
<p>请勿同时使用 <code>.passive</code> 和 <code>.prevent</code>，因为 <code>.passive</code> 已经向浏览器表明了你<em>不想</em>阻止事件的默认行为。如果你这么做了，则 <code>.prevent</code> 会被忽略，并且浏览器会抛出警告。</p>
<h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><p>在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许在 <code>v-on</code> 或 <code>@</code> 监听按键事件时添加按键修饰符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 仅在 `key` 为 `Enter` 时调用 `submit` --&gt;</span><br><span class="line">&lt;input @keyup.enter=&quot;submit&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>你可以直接使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/KeyboardEvent/key/Key_Values"><code>KeyboardEvent.key</code></a> 暴露的按键名称作为修饰符，但需要转为 kebab-case 形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input @keyup.page-down=&quot;onPageDown&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，仅会在 <code>$event.key</code> 为 <code>&#39;PageDown&#39;</code> 时调用事件处理。</p>
<h5 id="按键别名"><a href="#按键别名" class="headerlink" title="按键别名"></a>按键别名</h5><p>Vue 为一些常用的按键提供了别名：</p>
<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code> (捕获“Delete”和“Backspace”两个按键)</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
<h5 id="系统按键修饰符"><a href="#系统按键修饰符" class="headerlink" title="系统按键修饰符"></a>系统按键修饰符</h5><p>你可以使用以下系统按键修饰符来触发鼠标或键盘事件监听器，只有当按键被按下时才会触发。</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<blockquote>
<p>在 Mac 键盘上，meta 是 Command 键 (⌘)。在 Windows 键盘上，meta 键是 Windows 键 (⊞)。在 Sun 微机系统键盘上，meta 是钻石键 (◆)。在某些键盘上，特别是 MIT 和 Lisp 机器的键盘及其后代版本的键盘，如 Knight 键盘，space-cadet 键盘，meta 都被标记为“META”。在 Symbolics 键盘上，meta 也被标识为“META”或“Meta”。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Alt + Enter --&gt;</span><br><span class="line">&lt;input @keyup.alt.enter=&quot;clear&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Ctrl + 点击 --&gt;</span><br><span class="line">&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>请注意，系统按键修饰符和常规按键不同。与 <code>keyup</code> 事件一起使用时，该按键必须在事件发出时处于按下状态。换句话说，<code>keyup.ctrl</code> 只会在你仍然按住 <code>ctrl</code> 但松开了另一个键时被触发。若你单独松开 <code>ctrl</code> 键将不会触发。</p>
<h5 id="exact修饰符"><a href="#exact修饰符" class="headerlink" title=".exact修饰符"></a><code>.exact</code>修饰符</h5><p><code>.exact</code> 修饰符允许控制触发一个事件所需的确定组合的系统按键修饰符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 仅当没有按下任何系统按键时触发 --&gt;</span><br><span class="line">&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h4 id="鼠标按键修饰符"><a href="#鼠标按键修饰符" class="headerlink" title="鼠标按键修饰符"></a>鼠标按键修饰符</h4><ul>
<li><code>.left</code></li>
<li><code>.right</code></li>
<li><code>.middle</code></li>
</ul>
<p>这些修饰符将处理程序限定为由特定鼠标按键触发的事件。</p>
<h3 id="表单输入与绑定"><a href="#表单输入与绑定" class="headerlink" title="表单输入与绑定"></a>表单输入与绑定</h3><p>在前端处理表单时，我们常常需要将表单输入框的内容同步给 JavaScript 中相应的变量。手动连接值绑定和更改事件监听器可能会很麻烦：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  :value=&quot;text&quot;</span><br><span class="line">  @input=&quot;event =&gt; text = event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><code>v-model</code> 指令帮我们简化了这一步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;text&quot;&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p><code>v-model</code> 会忽略任何表单元素上初始的 <code>value</code>、<code>checked</code> 或 <code>selected</code> attribute。它将始终将当前绑定的 JavaScript 状态视为数据的正确来源。你应该在 JavaScript 中使用响应式系统的 API 来声明该初始值。</p>
</blockquote>
<h4 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h4><p>有时我们可能希望将该值绑定到当前组件实例上的动态数据。这可以通过使用 <code>v-bind</code> 来实现。此外，使用 <code>v-bind</code> 还使我们可以将选项值绑定为非字符串的数据类型。</p>
<h4 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; true-value=&quot;yes&quot; false-value=&quot;no&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><code>true-value</code> 和 <code>false-value</code> 是 Vue 特有的 attributes，仅支持和 <code>v-model</code> 配套使用。这里 <code>toggle</code> 属性的值会在选中时被设为 <code>&#39;yes&#39;</code>，取消选择时设为 <code>&#39;no&#39;</code>。你同样可以通过 <code>v-bind</code> 将其绑定为其他动态值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; :true-value=&quot;dynamicTrueValue&quot; :false-value=&quot;dynamicFalseValue&quot; /&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：</p>
<p><code>true-value</code> 和 <code>false-value</code> attributes 不会影响 <code>value</code> attribute，因为浏览器在表单提交时，并不会包含未选择的复选框。为了保证这两个值 (例如：“yes”和“no”) 的其中之一被表单提交，请使用单选按钮作为替代。</p>
</blockquote>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><h5 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a><code>.lazy</code></h5><p>默认情况下，<code>v-model</code> 会在每次 <code>input</code> 事件后更新数据 (<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/forms.html#vmodel-ime-tip">IME 拼字阶段的状态</a>例外)。你可以添加 <code>lazy</code> 修饰符来改为在每次 <code>change</code> 事件后更新数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在 &quot;change&quot; 事件后同步更新而不是 &quot;input&quot; --&gt;</span><br><span class="line">&lt;input v-model.lazy=&quot;msg&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h5 id="number"><a href="#number" class="headerlink" title=".number"></a><code>.number</code></h5><p>如果你想让用户输入自动转换为数字，你可以在 <code>v-model</code> 后添加 <code>.number</code> 修饰符来管理输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.number=&quot;age&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>如果该值无法被 <code>parseFloat()</code> 处理，那么将返回原始值。</p>
<p><code>number</code> 修饰符会在输入框有 <code>type=&quot;number&quot;</code> 时自动启用。</p>
<h5 id="trim"><a href="#trim" class="headerlink" title=".trim"></a><code>.trim</code></h5><p>如果你想要默认自动去除用户输入内容中两端的空格，你可以在 <code>v-model</code> 后添加 <code>.trim</code> 修饰符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.trim=&quot;msg&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h4 id="组件上的v-model"><a href="#组件上的v-model" class="headerlink" title="组件上的v-model"></a>组件上的<code>v-model</code></h4><p>HTML 的内置表单输入类型并不总能满足所有需求。幸运的是，我们可以使用 Vue 构建具有自定义行为的可复用输入组件，并且这些输入组件也支持 <code>v-model</code>！要了解更多关于此的内容，请在组件指引中阅读<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/components/v-model.html">配合 <code>v-model</code> 使用</a>。</p>
<h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><p>每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM，以及在数据改变时更新 DOM。在此过程中，它也会运行被称为生命周期钩子的函数，让开发者有机会在特定阶段运行自己的代码。</p>
<p><img data-src="//img.to2b.cn/blog/ljk/1676878242776.png"></p>
<h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><p>计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。</p>
<h4 id="侦听器-和-计算属性"><a href="#侦听器-和-计算属性" class="headerlink" title="侦听器 和 计算属性"></a>侦听器 和 计算属性</h4><p>有“副作用”，使用侦听器；没有“副作用”，使用计算属性。</p>
<h4 id="watch"><a href="#watch" class="headerlink" title="watch()"></a><code>watch()</code></h4><p>在组合式 API 中，我们可以使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-core.html#watch"><code>watch</code> 函数</a>在每次响应式状态发生变化时触发回调函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, watch &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const question = ref(&quot;&quot;)</span><br><span class="line">const answer = ref(&quot;Questions usually contain a question mark. ;-)&quot;)</span><br><span class="line"></span><br><span class="line">// 可以直接侦听一个 ref</span><br><span class="line">watch(question, async (newQuestion, oldQuestion) =&gt; &#123;</span><br><span class="line"> if (newQuestion.indexOf(&quot;?&quot;) &gt; -1) &#123;</span><br><span class="line">  answer.value = &quot;Thinking...&quot;</span><br><span class="line">  try &#123;</span><br><span class="line">   const res = await fetch(&quot;https://yesno.wtf/api&quot;)</span><br><span class="line">   answer.value = (await res.json()).answer</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">   answer.value = &quot;Error! Could not reach the API. &quot; + error</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;p&gt;</span><br><span class="line">  Ask a yes/no question:</span><br><span class="line">  &lt;input v-model=&quot;question&quot; /&gt;</span><br><span class="line"> &lt;/p&gt;</span><br><span class="line"> &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p><code>watch</code> 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> y = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个 ref</span></span><br><span class="line"><span class="title function_">watch</span>(x, <span class="function"><span class="params">newX</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`x is <span class="subst">$&#123;newX&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter 函数</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line"> <span class="function">() =&gt;</span> x.<span class="property">value</span> + y.<span class="property">value</span>,</span><br><span class="line"> <span class="function"><span class="params">sum</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`sum of x + y is: <span class="subst">$&#123;sum&#125;</span>`</span>)</span><br><span class="line"> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个来源组成的数组</span></span><br><span class="line"><span class="title function_">watch</span>([x, <span class="function">() =&gt;</span> y.<span class="property">value</span>], <span class="function">(<span class="params">[newX, newY]</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`x is <span class="subst">$&#123;newX&#125;</span> and y is <span class="subst">$&#123;newY&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意，你不能直接侦听响应式对象的属性值，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，因为 watch() 得到的参数是一个 number</span></span><br><span class="line"><span class="title function_">watch</span>(obj.<span class="property">count</span>, <span class="function"><span class="params">count</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`count is: <span class="subst">$&#123;count&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里需要用一个返回该属性的 getter 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供一个 getter 函数</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line"> <span class="function">() =&gt;</span> obj.<span class="property">count</span>,</span><br><span class="line"> <span class="function"><span class="params">count</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`count is: <span class="subst">$&#123;count&#125;</span>`</span>)</span><br><span class="line"> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="深层侦听器"><a href="#深层侦听器" class="headerlink" title="深层侦听器"></a>深层侦听器</h4><p>直接给 <code>watch()</code> 传入一个响应式对象，会隐式地创建一个深层侦听器——该回调函数在所有嵌套的变更时都会被触发：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(obj, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">// 在嵌套的属性变更时触发</span></span><br><span class="line"> <span class="comment">// 注意：`newValue` 此处和 `oldValue` 是相等的</span></span><br><span class="line"> <span class="comment">// 因为它们是同一个对象！</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">count</span>++</span><br></pre></td></tr></table></figure>

<p>相比之下，一个返回响应式对象的 getter 函数，只有在返回不同的对象时，才会触发回调：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(</span><br><span class="line"> <span class="function">() =&gt;</span> state.<span class="property">someObject</span>,</span><br><span class="line"> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 仅当 state.someObject 被替换时触发</span></span><br><span class="line"> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>你也可以给上面这个例子显式地加上 <code>deep</code> 选项，强制转成深层侦听器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(</span><br><span class="line"> <span class="function">() =&gt;</span> state.<span class="property">someObject</span>,</span><br><span class="line"> <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 注意：`newValue` 此处和 `oldValue` 是相等的</span></span><br><span class="line">  <span class="comment">// *除非* state.someObject 被整个替换了</span></span><br><span class="line"> &#125;,</span><br><span class="line"> &#123; <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>谨慎使用：</p>
<p>深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请只在必要时才使用它，并且要留意性能。</p>
</blockquote>
<h4 id="即时回调的侦听器"><a href="#即时回调的侦听器" class="headerlink" title="即时回调的侦听器"></a>即时回调的侦听器</h4><p><code>watch</code> 默认是懒执行的：仅当数据源变化时，才会执行回调。但在某些场景中，我们希望在创建侦听器时，立即执行一遍回调。举例来说，我们想请求一些初始数据，然后在相关状态更改时重新请求数据。</p>
<p>我们可以通过传入 <code>immediate: true</code> 选项来强制侦听器的回调立即执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(</span><br><span class="line"> source,</span><br><span class="line"> <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 立即执行，且当 `source` 改变时再次执行</span></span><br><span class="line"> &#125;,</span><br><span class="line"> &#123; <span class="attr">immediate</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect()"></a><code>watchEffect()</code></h4><p>下面的例子中，在每当 <code>todoId</code> 的引用发生变化时使用侦听器来加载一个远程资源：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoId = <span class="title function_">ref</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line"> todoId,</span><br><span class="line"> <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`https://jsonplaceholder.typicode.com/todos/<span class="subst">$&#123;todoId.value&#125;</span>`</span>)</span><br><span class="line">  data.<span class="property">value</span> = <span class="keyword">await</span> response.<span class="title function_">json</span>()</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123; <span class="attr">immediate</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>侦听的数据源是<code>todoId</code>，而回调中也使用到了<code>todoId</code>，这种情况是很常见的。</p>
<p>我们可以用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-core.html#watcheffect"><code>watchEffect</code> 函数</a> 来简化上面的代码。<code>watchEffect()</code> 允许我们自动跟踪回调的响应式依赖。上面的侦听器可以重写为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watchEffect</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"> <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`https://jsonplaceholder.typicode.com/todos/<span class="subst">$&#123;todoId.value&#125;</span>`</span>)</span><br><span class="line"> data.<span class="property">value</span> = <span class="keyword">await</span> response.<span class="title function_">json</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这个例子中，回调会立即执行，不需要指定 <code>immediate: true</code>。在执行期间，它会自动追踪 <code>todoId.value</code> 作为依赖（和计算属性类似）。每当 <code>todoId.value</code> 变化时，回调会再次执行。有了 <code>watchEffect()</code>，我们不再需要明确传递 <code>todoId</code> 作为源值。</p>
<p>对于这种只有一个依赖项的例子来说，<code>watchEffect()</code> 的好处相对较小。但是对于有多个依赖项的侦听器来说，使用 <code>watchEffect()</code> 可以消除手动维护依赖列表的负担。此外，如果你需要侦听一个嵌套数据结构中的几个属性，<code>watchEffect()</code> 可能会比深度侦听器更有效，因为它将只跟踪回调中被使用到的属性，而不是递归地跟踪所有的属性。</p>
<blockquote>
<p>提示：</p>
<p><code>watchEffect</code> 仅会在其<strong>同步</strong>执行期间，才追踪依赖。在使用异步回调时，只有在第一个 <code>await</code> 正常工作前访问到的属性才会被追踪。</p>
</blockquote>
<h4 id="watch-和-watchEffect"><a href="#watch-和-watchEffect" class="headerlink" title="watch 和 watchEffect"></a><code>watch</code> 和 <code>watchEffect</code></h4><p><code>watch</code> 和 <code>watchEffect</code> 都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式：</p>
<ul>
<li><code>watch</code> 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。<code>watch</code> 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。</li>
<li><code>watchEffect</code>，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。</li>
</ul>
<h4 id="回调的触发时机"><a href="#回调的触发时机" class="headerlink" title="回调的触发时机"></a>回调的触发时机</h4><p>当你更改了响应的状态，它可能会同时触发 vue 组件更新和侦听器回调。</p>
<p>默认情况下，用户创建的侦听器回调，都会在 vue 组件更新<strong>之前</strong>被调用。这意味着你在侦听器回调中访问的 DOM 将是被 vue 更新的状态。</p>
<p>如果想在侦听器回调中能访问被 vue 更新<strong>之后</strong>的 DOM，你需要指明<code>flush &#39;post&#39;</code>选项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(source, callback, &#123;</span><br><span class="line"> <span class="attr">flush</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(callback, &#123;</span><br><span class="line"> <span class="attr">flush</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>后置刷新的<code>watchEffect()</code>有个更方便的别名<code>watchPostEffect()</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; watchPostEffect &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">watchPostEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">/* 在 Vue 更新后执行 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="停止侦听器"><a href="#停止侦听器" class="headerlink" title="停止侦听器"></a>停止侦听器</h4><p>在 <code>setup()</code> 或 <code>&lt;script setup&gt;</code> 中用同步语句创建的侦听器，会自动绑定到宿主组件实例上，并且会在宿主组件卸载时自动停止。因此，在大多数情况下，你无需关心怎么停止一个侦听器。</p>
<p>一个关键点是，侦听器必须用<strong>同步</strong>语句创建：如果用异步回调创建一个侦听器，那么它不会绑定到当前组件上，你必须手动停止它，以防内存泄漏。如下方这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; watchEffect &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">// 它会自动停止</span><br><span class="line">watchEffect(() =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">// ...这个则不会！</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line"> watchEffect(() =&gt; &#123;&#125;)</span><br><span class="line">&#125;, 100)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>要手动停止一个侦听器，请调用 <code>watch</code> 或 <code>watchEffect</code> 返回的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unwatch = <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...当该侦听器不再需要时</span></span><br><span class="line"><span class="title function_">unwatch</span>()</span><br></pre></td></tr></table></figure>

<p>注意，需要异步创建侦听器的情况很少，请尽可能选择同步创建。如果需要等待一些异步数据，你可以使用条件式的侦听逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要异步请求得到的数据</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (data.<span class="property">value</span>) &#123;</span><br><span class="line">  <span class="comment">// 数据加载后执行某些操作...</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="模板引用"><a href="#模板引用" class="headerlink" title="模板引用"></a>模板引用</h3><p>虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素。要实现这一点，我们可以使用特殊的 <code>ref</code> attribute：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=<span class="string">&quot;input&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p><code>ref</code> 是一个特殊的 attribute，和 <code>v-for</code> 章节中提到的 <code>key</code> 类似。它允许我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用。这可能很有用，比如说在组件挂载时将焦点设置到一个 input 元素上，或在一个元素上初始化一个第三方库。</p>
<h4 id="访问模板引用"><a href="#访问模板引用" class="headerlink" title="访问模板引用"></a>访问模板引用</h4><p>为了通过组合式 API 获得该模板引用，我们需要声明一个同名的 ref：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, onMounted &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">// 声明一个 ref 来存放该元素的引用</span><br><span class="line">// 必须和模板里的 ref 同名</span><br><span class="line">const input = ref(null)</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line"> input.value.focus()</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;input ref=&quot;input&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>注意，你只可以<strong>在组件挂载后</strong>才能访问模板引用。如果你想在模板中的表达式上访问 <code>input</code>，在初次渲染时会是 <code>null</code>。这是因为在初次渲染前这个元素还不存在呢！</p>
<p>如果你需要侦听一个模板引用 ref 的变化，确保考虑到其值为 <code>null</code> 的情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (input.<span class="property">value</span>) &#123;</span><br><span class="line">  input.<span class="property">value</span>.<span class="title function_">focus</span>()</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 此时还未挂载，或此元素已经被卸载（例如通过 v-if 控制）</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="v-for中的模板引用"><a href="#v-for中的模板引用" class="headerlink" title="v-for中的模板引用"></a><code>v-for</code>中的模板引用</h4><p>当在 <code>v-for</code> 中使用模板引用时，对应的 ref 中包含的值是一个数组，它将在元素被挂载后包含对应整个列表的所有元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, onMounted &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const list = ref([</span><br><span class="line"> /* ... */</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">const itemRefs = ref([])</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; console.log(itemRefs.value))</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;item in list&quot; ref=&quot;itemRefs&quot;&gt;</span><br><span class="line">   &#123;&#123; item &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line"> &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>应该注意的是，ref 数组<strong>并不</strong>保证与源数组相同的顺序。</p>
<h4 id="函数模板引用"><a href="#函数模板引用" class="headerlink" title="函数模板引用"></a>函数模板引用</h4><p>除了使用字符串值作名字，<code>ref</code> attribute 还可以绑定为一个函数，会在每次组件更新时都被调用。该函数会收到元素引用作为其第一个参数：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:ref</span>=<span class="string">&quot;(el) =&gt; &#123; /* 将 el 赋值给一个数据属性或 ref 变量 */ &#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意我们这里需要使用动态的 <code>:ref</code> 绑定才能够传入一个函数。当绑定的元素被卸载时，函数也会被调用一次，此时的 <code>el</code> 参数会是 <code>null</code>。你当然也可以绑定一个组件方法而不是内联函数。</p>
<h4 id="组件上的-ref"><a href="#组件上的-ref" class="headerlink" title="组件上的 ref"></a>组件上的 ref</h4><p>模板引用也可以被用在一个子组件上。这种情况下引用中获得的值是组件实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, onMounted &#125; from &quot;vue&quot;</span><br><span class="line">import Child from &quot;./Child.vue&quot;</span><br><span class="line"></span><br><span class="line">const child = ref(null)</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line"> // child.value 是 &lt;Child /&gt; 组件的实例</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;Child ref=&quot;child&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>如果一个子组件使用的是选项式 API 或没有使用 <code>&lt;script setup&gt;</code>，被引用的组件实例和该子组件的 <code>this</code> 完全一致，这意味着父组件对子组件的每一个属性和方法都有完全的访问权。这使得在父组件和子组件之间创建紧密耦合的实现细节变得很容易，当然也因此，应该只在绝对需要时才使用组件引用。大多数情况下，你应该首先使用标准的 props 和 emit 接口来实现父子组件交互。</p>
<p>有一个例外的情况，使用了 <code>&lt;script setup&gt;</code> 的组件是<strong>默认私有</strong>的：一个父组件无法访问到一个使用了 <code>&lt;script setup&gt;</code> 的子组件中的任何东西，除非子组件在其中通过 <code>defineExpose</code> 宏显式暴露：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const a = 1</span><br><span class="line">const b = ref(2)</span><br><span class="line"></span><br><span class="line">// 像 defineExpose 这样的编译器宏不需要导入</span><br><span class="line">defineExpose(&#123;</span><br><span class="line"> a,</span><br><span class="line"> b,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当父组件通过模板引用获取到了该组件的实例时，得到的实例类型为 <code>&#123; a: number, b: number &#125;</code> (ref 都会自动解包，和一般的实例一样)。</p>
<h3 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h3><h4 id="传递-props"><a href="#传递-props" class="headerlink" title="传递 props"></a>传递 props</h4><p>props 是一种特别的 attributes，你可以在组件上声明注册。要传递给博客文章组件一个标题，我们必须在组件的 props 列表上声明它。这里要用到 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits"><code>defineProps</code></a> 宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- BlogPost.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps([&quot;title&quot;])</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p><code>defineProps</code> 是一个仅 <code>&lt;script setup&gt;</code> 中可用的编译宏命令，并不需要显式地导入。声明的 props 会自动暴露给模板。<code>defineProps</code> 会返回一个对象，其中包含了可以传递给组件的所有 props：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>([<span class="string">&quot;title&quot;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">title</span>)</span><br></pre></td></tr></table></figure>

<h4 id="监听事件-1"><a href="#监听事件-1" class="headerlink" title="监听事件"></a>监听事件</h4><p>父组件可以通过 <code>v-on</code> 或 <code>@</code> 来选择性地监听子组件上抛的事件，就像监听原生 DOM 事件那样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BlogPost ... @enlarge-text=&quot;postFontSize += 0.1&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>子组件可以通过调用内置的 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/component-instance.html#emit"><strong><code>$emit</code></strong> 方法</a>，通过传入事名称来抛出一个事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- BlogPost.vue, 省略了 &lt;script&gt; --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div class=&quot;blog-post&quot;&gt;</span><br><span class="line">  &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt;</span><br><span class="line">  &lt;button @click=&quot;$emit(&#x27;enlarge-text&#x27;)&quot;&gt;Enlarge text&lt;/button&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>因为有了 <code>@enlarge-text=&quot;postFontSize += 0.1&quot;</code> 的监听，父组件会接收这一事件，从而更新 <code>postFontSize</code> 的值。</p>
<p>我们可以通过 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits"><code>defineEmits</code></a> 宏来声明需要抛出的事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- BlogPost.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps([&quot;title&quot;])</span><br><span class="line">defineEmits([&quot;enlarge-text&quot;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这声明了一个组件可能触发的所有事件，还可以对事件的参数进行<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/components/events.html#validate-emitted-events">验证</a>。同时，这还可以让 Vue 避免将它们作为原生事件监听器隐式地应用于子组件的根元素。</p>
<p>和 <code>defineProps</code> 类似，<code>defineEmits</code> 仅可用于 <code>&lt;script setup&gt;</code> 之中，并且不需要导入，它返回一个等同于 <code>$emit</code> 方法的 <code>emit</code> 函数。它可以被用于在组件的 <code>&lt;script setup&gt;</code> 中抛出事件，因为此处无法直接访问 <code>$emit</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const emit = defineEmits([&quot;enlarge-text&quot;])</span><br><span class="line"></span><br><span class="line">emit(&quot;enlarge-text&quot;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="深入组件"><a href="#深入组件" class="headerlink" title="深入组件"></a>深入组件</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>一个 Vue 组件在使用前需要先被“注册”，这样 Vue 才能在渲染模板时找到其对应的实现。组件注册有两种方式：全局注册和局部注册。</p>
<h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><p>我们可以使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/application.html">Vue 应用实例</a>的 <code>app.component()</code> 方法，让组件在当前 Vue 应用中全局可用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&quot;MyComponent&quot;</span>, <span class="title class_">MyComponent</span>)</span><br></pre></td></tr></table></figure>

<p><code>app.component()</code> 方法可以被链式调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">component</span>(<span class="string">&quot;ComponentA&quot;</span>, <span class="title class_">ComponentA</span>).<span class="title function_">component</span>(<span class="string">&quot;ComponentB&quot;</span>, <span class="title class_">ComponentB</span>).<span class="title function_">component</span>(<span class="string">&quot;ComponentC&quot;</span>, <span class="title class_">ComponentC</span>)</span><br></pre></td></tr></table></figure>

<p>全局注册的组件可以在此应用的任意组件的模板中使用。并且相互可以在彼此内部使用。</p>
<h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><p>局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对 tree-shaking 更加友好。</p>
<h4 id="组件名格式"><a href="#组件名格式" class="headerlink" title="组件名格式"></a>组件名格式</h4><p>在 SFC 中，推荐为子组件使用<code>PascalCase</code>的标签名，以此来和原声的 HTML 元素作区分。</p>
<p>但是，PascalCase 的标签名在 DOM 模板中是不可用的，详情参见 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/component-basics.html#dom-template-parsing-caveats">DOM 模板解析注意事项</a>，在这种情况下，需要使用 <code>kebab-case</code> 形式。</p>
<p>什么是 DOM 模板？就是直接写在 DOM 中的模板，会被浏览器直接解析：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE &lt;html&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue Component<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 在 HTML 中是 kebab-case (短横线命名) 的会被渲染 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">my-Component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-Component</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">My-component</span>&gt;</span><span class="tag">&lt;/<span class="name">My-component</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">My-Component</span>&gt;</span><span class="tag">&lt;/<span class="name">My-Component</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 注册时：PascalCase (首字母大写命名)、camelCase (驼峰命名)、kebab-case (短横线命名) 都可以</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyComponent&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;Hello Vue&lt;/div&gt;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">new</span> <span class="title class_">Vue</span> (&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;my-component&gt;&lt;/my-component&gt;</code> 就是 DOM 模板。</p>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><h4 id="props-声明"><a href="#props-声明" class="headerlink" title="props 声明"></a>props 声明</h4><p>一个组件需要显式声明它所接受的 props，这样 Vue 才能知道外部传入的哪些是 props，哪些是透传 attribute (关于透传 attribute，我们会在<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/components/attrs.html">专门的章节</a>中讨论)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps([&quot;foo&quot;])</span><br><span class="line"></span><br><span class="line">console.log(props.foo)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如果使用了 ts，也可以这么声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">interface Props &#123;</span><br><span class="line"> foo: string</span><br><span class="line"> bar?: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const props = defineProps&lt;Props&gt;()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这被称之为“基于类型的声明”。感觉怪怪的。</p>
<p>当使用基于类型的声明时，我们失去了为 props 声明默认值的能力。这可以通过 <code>withDefaults</code> 编译器宏解决：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line"> msg?: <span class="built_in">string</span></span><br><span class="line"> labels?: <span class="built_in">string</span>[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> props = <span class="title function_">withDefaults</span>(defineProps&lt;<span class="title class_">Props</span>&gt;(), &#123;</span><br><span class="line"> <span class="attr">msg</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line"> <span class="attr">labels</span>: <span class="function">() =&gt;</span> [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="传递-prop-细节"><a href="#传递-prop-细节" class="headerlink" title="传递 prop 细节"></a>传递 prop 细节</h4><h5 id="prop-名字格式"><a href="#prop-名字格式" class="headerlink" title="prop 名字格式"></a>prop 名字格式</h5><p>prop 名字使用 camelCase 形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">defineProps</span>(&#123;</span><br><span class="line"> <span class="attr">greetingMessage</span>: <span class="title class_">String</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然而对于传递 props 来说，使用 camelCase 并没有太多优势，因此我们推荐更贴近 HTML 的书写风格，使用 kebab-case 形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent greeting-message=&quot;hello&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h5 id="静态-和-动态-prop"><a href="#静态-和-动态-prop" class="headerlink" title="静态 和 动态 prop"></a>静态 和 动态 prop</h5><p>静态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BlogPost title=&quot;My journey with Vue&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>动态绑定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 根据一个变量的值动态传入 --&gt;</span><br><span class="line">&lt;BlogPost :title=&quot;post.title&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 根据一个更复杂表达式的值动态传入 --&gt;</span><br><span class="line">&lt;BlogPost :title=&quot;post.title + &#x27; by &#x27; + post.author.name&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h5 id="传递不同的值类型"><a href="#传递不同的值类型" class="headerlink" title="传递不同的值类型"></a>传递不同的值类型</h5><p>不仅仅是字符串，实际上<strong>任何</strong>类型的值都可以作为 props 的值被传递。</p>
<p><strong>Number：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 虽然 `42` 是个常量，我们还是需要使用 v-bind --&gt;</span><br><span class="line">&lt;!-- 因为这是一个 JavaScript 表达式而不是一个字符串 --&gt;</span><br><span class="line">&lt;BlogPost :likes=&quot;42&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 根据一个变量的值动态传入 --&gt;</span><br><span class="line">&lt;BlogPost :likes=&quot;post.likes&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>Boolean：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 仅写上 prop 但不传值，会隐式转换为 `true` --&gt;</span><br><span class="line">&lt;BlogPost is-published /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 虽然 `false` 是静态的值，我们还是需要使用 v-bind --&gt;</span><br><span class="line">&lt;!-- 因为这是一个 JavaScript 表达式而不是一个字符串 --&gt;</span><br><span class="line">&lt;BlogPost :is-published=&quot;false&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 根据一个变量的值动态传入 --&gt;</span><br><span class="line">&lt;BlogPost :is-published=&quot;post.isPublished&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>Array：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 虽然这个数组是个常量，我们还是需要使用 v-bind --&gt;</span><br><span class="line">&lt;!-- 因为这是一个 JavaScript 表达式而不是一个字符串 --&gt;</span><br><span class="line">&lt;BlogPost :comment-ids=&quot;[234, 266, 273]&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 根据一个变量的值动态传入 --&gt;</span><br><span class="line">&lt;BlogPost :comment-ids=&quot;post.commentIds&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>Object：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 虽然这个对象字面量是个常量，我们还是需要使用 v-bind --&gt;</span><br><span class="line">&lt;!-- 因为这是一个 JavaScript 表达式而不是一个字符串 --&gt;</span><br><span class="line">&lt;BlogPost</span><br><span class="line"> :author=&quot;&#123;</span><br><span class="line">  name: &#x27;Veronica&#x27;,</span><br><span class="line">  company: &#x27;Veridian Dynamics&#x27;,</span><br><span class="line"> &#125;&quot;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 根据一个变量的值动态传入 --&gt;</span><br><span class="line">&lt;BlogPost :author=&quot;post.author&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h4 id="使用一个对象绑定多个-prop"><a href="#使用一个对象绑定多个-prop" class="headerlink" title="使用一个对象绑定多个 prop"></a>使用一个对象绑定多个 prop</h4><p>如果你想要将一个对象的所有属性都当作 props 传入，你可以使用<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/template-syntax.html#dynamically-binding-multiple-attributes">没有参数的 <code>v-bind</code></a>，即只使用 <code>v-bind</code> 而非 <code>:prop-name</code>。例如，这里有一个 <code>post</code> 对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> post = &#123;</span><br><span class="line"> <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="attr">title</span>: <span class="string">&quot;My Journey with Vue&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BlogPost v-bind=&quot;post&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BlogPost :id=&quot;post.id&quot; :title=&quot;post.title&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h4 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h4><p>所有的 props 都遵循着<strong>单向绑定</strong>原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解。</p>
<p>另外，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值，这意味着你<strong>不应该</strong>在子组件中去更改一个 prop。若你这么做了，Vue 会在控制台上向你抛出警告。</p>
<h5 id="更改对象-x2F-数组类型的-props"><a href="#更改对象-x2F-数组类型的-props" class="headerlink" title="更改对象 &#x2F; 数组类型的 props"></a>更改对象 &#x2F; 数组类型的 props</h5><p>当对象或数组作为 props 被传入时，虽然子组件无法更改 props 绑定，但仍然<strong>可以</strong>更改对象或数组内部的值。这是因为 JavaScript 的对象和数组是按引用传递，而对 Vue 来说，禁止这样的改动，虽然可能生效，但有很大的性能损耗，比较得不偿失。</p>
<p>这种更改的主要缺陷是它允许了子组件以某种不明显的方式影响父组件的状态，可能会使数据流在将来变得更难以理解。在最佳实践中，你应该尽可能避免这样的更改，除非父子组件在设计上本来就需要紧密耦合。在大多数场景下，子组件应该<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/components/events.html">抛出一个事件</a>来通知父组件做出改变。</p>
<h3 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h3><h4 id="触发与监听事件"><a href="#触发与监听事件" class="headerlink" title="触发与监听事件"></a>触发与监听事件</h4><p>在组件的模板表达式中，可以直接使用 <code>$emit</code> 方法触发自定义事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- MyComponent --&gt;</span><br><span class="line">&lt;button @click=&quot;$emit(&#x27;increaseBy&#x27;, 1)&quot;&gt;</span><br><span class="line">  Increase by 1</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>父组件监听事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyButton @increase-by=&quot;n =&gt; (count += n)&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>同样，组件的事件监听器也支持 <code>.once</code> 修饰符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent @some-event.once=&quot;callback&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>像组件与 prop 一样，事件的名字也提供了自动的格式转换。注意这里我们触发了一个以 camelCase 形式命名的事件，但在父组件中可以使用 kebab-case 形式来监听。与 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/components/props.html#prop-name-casing">prop 大小写格式</a>一样，在模板中我们也推荐使用 kebab-case 形式来编写监听器。</p>
<blockquote>
<p>提示：</p>
<p>和原生 DOM 事件不一样，组件触发的事件<strong>没有冒泡机制</strong>。你只能监听直接子组件触发的事件。平级组件或是跨越多层嵌套的组件间通信，应使用一个外部的事件总线，或是使用一个<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/scaling-up/state-management.html">全局状态管理方案</a>。</p>
</blockquote>
<h4 id="声明触发的事件"><a href="#声明触发的事件" class="headerlink" title="声明触发的事件"></a>声明触发的事件</h4><p>组件可以显式地通过 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits"><code>defineEmits()</code></a> 宏来声明它要触发的事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">const emit = defineEmits&lt;&#123;</span><br><span class="line"> (e: &quot;change&quot;, id: number): void</span><br><span class="line"> (e: &quot;update&quot;, value: string): void</span><br><span class="line">&#125;&gt;()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>我们在 <code>&lt;template&gt;</code> 中使用的 <code>$emit</code> 方法不能在组件的 <code>&lt;script setup&gt;</code> 部分中使用，但 <code>defineEmits()</code> 会返回一个相同作用的函数供我们使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const emit = defineEmits&lt;&#123;</span><br><span class="line">  (e: &#x27;change&#x27;, id: number): void</span><br><span class="line">  (e: &#x27;update&#x27;, value: string): void</span><br><span class="line">&#125;&gt;()</span><br><span class="line"></span><br><span class="line">function buttonClick() &#123;</span><br><span class="line">  emit(&#x27;submit&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="组件-v-model"><a href="#组件-v-model" class="headerlink" title="组件 v-model"></a>组件 v-model</h3><p><code>v-model</code> 可以在组件上使用以实现双向绑定。</p>
<p>首先让我们回忆一下 <code>v-model</code> 在原生元素上的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;searchText&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>模板编译器会对 <code>v-model</code> 进行冗长的等价展开。因此上面的代码其实等价于下面这段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input :value=&quot;searchText&quot; @input=&quot;searchText = $event.target.value&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>而当使用在一个组件上时，<code>v-model</code> 会被展开为如下的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;CustomInput :modelValue=&quot;searchText&quot; @update:modelValue=&quot;newValue =&gt; (searchText = newValue)&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>所以，<code>&lt;CustomInput&gt;</code> 组件内部需要做两件事：</p>
<ol>
<li>将内部原生 <code>&lt;input&gt;</code> 元素的 <code>value</code> attribute 绑定到 <code>modelValue</code> prop</li>
<li>当原生的 <code>input</code> 事件触发时，触发一个携带了新值的 <code>update:modelValue</code> 自定义事件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- CustomInput.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps([&quot;modelValue&quot;])</span><br><span class="line">defineEmits([&quot;update:modelValue&quot;])</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;input :value=&quot;modelValue&quot; @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>现在 <code>v-model</code> 可以在这个组件上正常工作了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;CustomInput v-model=&quot;searchText&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>另一种在组件内实现 <code>v-model</code> 的方式是使用一个可写的，同时具有 getter 和 setter 的 <code>computed</code> 属性。<code>get</code> 方法需返回 <code>modelValue</code> prop，而 <code>set</code> 方法需触发相应的事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- CustomInput.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; computed &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const props = defineProps([&quot;modelValue&quot;])</span><br><span class="line">const emit = defineEmits([&quot;update:modelValue&quot;])</span><br><span class="line"></span><br><span class="line">const value = computed(&#123;</span><br><span class="line"> get() &#123;</span><br><span class="line">  return props.modelValue</span><br><span class="line"> &#125;,</span><br><span class="line"> set(value) &#123;</span><br><span class="line">  emit(&quot;update:modelValue&quot;, value)</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;input v-model=&quot;value&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="v-model-的参数"><a href="#v-model-的参数" class="headerlink" title="v-model 的参数"></a><code>v-model</code> 的参数</h4><p>默认情况下，<code>v-model</code> 在组件上都是使用 <code>modelValue</code> 作为 prop，并以 <code>update:modelValue</code> 作为对应的事件。我们可以通过给 <code>v-model</code> 指定一个参数来更改这些名字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent v-model:title=&quot;bookTitle&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，子组件应声明一个 <code>title</code> prop，并通过触发 <code>update:title</code> 事件更新父组件值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- MyComponent.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps([&quot;title&quot;])</span><br><span class="line">defineEmits([&quot;update:title&quot;])</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;input type=&quot;text&quot; :value=&quot;title&quot; @input=&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="多个v-model绑定"><a href="#多个v-model绑定" class="headerlink" title="多个v-model绑定"></a>多个<code>v-model</code>绑定</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;UserName v-model:first-name=&quot;first&quot; v-model:last-name=&quot;last&quot; /&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps(&#123;</span><br><span class="line"> firstName: String,</span><br><span class="line"> lastName: String,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">defineEmits([&quot;update:firstName&quot;, &quot;update:lastName&quot;])</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;input type=&quot;text&quot; :value=&quot;firstName&quot; @input=&quot;$emit(&#x27;update:firstName&#x27;, $event.target.value)&quot; /&gt;</span><br><span class="line"> &lt;input type=&quot;text&quot; :value=&quot;lastName&quot; @input=&quot;$emit(&#x27;update:lastName&#x27;, $event.target.value)&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="处理v-model修饰符"><a href="#处理v-model修饰符" class="headerlink" title="处理v-model修饰符"></a>处理<code>v-model</code>修饰符</h4><p>在学习输入绑定时，我们知道了 <code>v-model</code> 有一些<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/forms.html#modifiers">内置的修饰符</a>，例如 <code>.trim</code>，<code>.number</code> 和 <code>.lazy</code>。在某些场景下，你可能想要一个自定义组件的 <code>v-model</code> 支持自定义的修饰符。</p>
<p>我们来创建一个自定义的修饰符 <code>capitalize</code>，它会自动将 <code>v-model</code> 绑定输入的字符串值第一个字母转为大写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent v-model.capitalize=&quot;myText&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>组件的 <code>v-model</code> 上所添加的修饰符，可以通过 <code>modelModifiers</code> prop 在组件内访问到。在下面的组件中，我们声明了 <code>modelModifiers</code> 这个 prop，它的默认值是一个空对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line"> modelValue: String,</span><br><span class="line"> modelModifiers: &#123; default: () =&gt; (&#123;&#125;) &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">defineEmits([&quot;update:modelValue&quot;])</span><br><span class="line"></span><br><span class="line">console.log(props.modelModifiers) // &#123; capitalize: true &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>注意这里组件的 <code>modelModifiers</code> prop 包含了 <code>capitalize</code> 且其值为 <code>true</code>，因为它在模板中的 <code>v-model</code> 绑定 <code>v-model.capitalize=&quot;myText&quot;</code> 上被使用了。</p>
<p>有了这个 prop，我们就可以检查 <code>modelModifiers</code> 对象的键，并编写一个处理函数来改变抛出的值。在下面的代码里，我们就是在每次 <code>&lt;input /&gt;</code> 元素触发 <code>input</code> 事件时将值的首字母大写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line"> modelValue: String,</span><br><span class="line"> modelModifiers: &#123; default: () =&gt; (&#123;&#125;) &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const emit = defineEmits([&quot;update:modelValue&quot;])</span><br><span class="line"></span><br><span class="line">function emitValue(e) &#123;</span><br><span class="line"> let value = e.target.value</span><br><span class="line"> if (props.modelModifiers.capitalize) &#123;</span><br><span class="line">  value = value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line"> &#125;</span><br><span class="line"> emit(&quot;update:modelValue&quot;, value)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;emitValue&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>对于又有参数又有修饰符的 <code>v-model</code> 绑定，生成的 prop 名将是 <code>arg + &quot;Modifiers&quot;</code>。举例来说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent v-model:title.capitalize=&quot;myText&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>相应的声明应该是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>([<span class="string">&quot;title&quot;</span>, <span class="string">&quot;titleModifiers&quot;</span>])</span><br><span class="line"><span class="title function_">defineEmits</span>([<span class="string">&quot;update:title&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">titleModifiers</span>) <span class="comment">// &#123; capitalize: true &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="透传-attributes"><a href="#透传-attributes" class="headerlink" title="透传 attributes"></a>透传 attributes</h3><h4 id="attributes-继承"><a href="#attributes-继承" class="headerlink" title="attributes 继承"></a>attributes 继承</h4><p>“透传 attribute”指的是传递给一个组件，却没有被该组件声明为 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/components/props.html">props</a> 或 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/components/events.html#defining-custom-events">emits</a> 的 attribute 或者 <code>v-on</code> 事件监听器。最常见的例子就是 <code>class</code>、<code>style</code> 和 <code>id</code>。</p>
<p>当一个组件以单个元素为根作渲染时，透传的 attribute 会自动被添加到<strong>根元素</strong>上。举例来说，假如我们有一个 <code>&lt;MyButton&gt;</code> 组件，它的模板长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;MyButton&gt; 的模板 --&gt;</span><br><span class="line">&lt;button&gt;click me&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>一个父组件使用了这个组件，并且传入了 <code>class</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyButton class=&quot;large&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>最后渲染出的 DOM 结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button class=&quot;large&quot;&gt;click me&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>这里，<code>&lt;MyButton&gt;</code> 并没有将 <code>class</code> 声明为一个它所接受的 prop，所以 <code>class</code> 被视作透传 attribute，自动透传到了 <code>&lt;MyButton&gt;</code> 的根元素上。</p>
<h5 id="对-class-和-style-的合并"><a href="#对-class-和-style-的合并" class="headerlink" title="对 class 和 style 的合并"></a>对 <code>class</code> 和 <code>style</code> 的合并</h5><p>如果一个子组件的根元素已经有了 <code>class</code> 或 <code>style</code> attribute，它会和从父组件上继承的值合并。如果我们将之前的 <code>&lt;MyButton&gt;</code> 组件的模板改成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;MyButton&gt; 的模板 --&gt;</span><br><span class="line">&lt;button class=&quot;btn&quot;&gt;click me&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>则最后渲染出的 DOM 结果会变成：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn large&quot;</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="v-on-监听器继承"><a href="#v-on-监听器继承" class="headerlink" title="v-on 监听器继承"></a><code>v-on</code> 监听器继承</h5><p>同样的规则也适用于 <code>v-on</code> 事件监听器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyButton @click=&quot;onClick&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><code>click</code> 监听器会被添加到 <code>&lt;MyButton&gt;</code> 的根元素，即那个原生的 <code>&lt;button&gt;</code> 元素之上。当原生的 <code>&lt;button&gt;</code> 被点击，会触发父组件的 <code>onClick</code> 方法。同样的，如果原生 <code>button</code> 元素自身也通过 <code>v-on</code> 绑定了一个事件监听器，则这个监听器和从父组件继承的监听器都会被触发。</p>
<h5 id="深层组件继承"><a href="#深层组件继承" class="headerlink" title="深层组件继承"></a>深层组件继承</h5><p>有些情况下一个组件会在根节点上渲染另一个组件。例如，我们重构一下 <code>&lt;MyButton&gt;</code>，让它在根节点上渲染 <code>&lt;BaseButton&gt;</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;MyButton/&gt; 的模板，只是渲染另一个组件 --&gt;</span><br><span class="line">&lt;BaseButton /&gt;</span><br></pre></td></tr></table></figure>

<p>此时 <code>&lt;MyButton&gt;</code> 接收的透传 attribute 会直接继续传给 <code>&lt;BaseButton&gt;</code>。</p>
<p>请注意：</p>
<ol>
<li>透传的 attribute 不会包含 <code>&lt;MyButton&gt;</code> 上声明过的 props 或是针对 <code>emits</code> 声明事件的 <code>v-on</code> 侦听函数，换句话说，<strong>声明过的 props 和侦听函数被 <code>&lt;MyButton&gt;</code>“消费”了</strong>。</li>
<li>透传的 attribute 若符合声明，也可以作为 props 传入 <code>&lt;BaseButton&gt;</code>。</li>
</ol>
<h4 id="禁用-attributes-继承"><a href="#禁用-attributes-继承" class="headerlink" title="禁用 attributes 继承"></a>禁用 attributes 继承</h4><p>如果你<strong>不想要</strong>一个组件自动地继承 attribute，你可以在组件选项中设置 <code>inheritAttrs: false</code>。</p>
<p>如果你使用了 <code>&lt;script setup&gt;</code>，你需要一个额外的 <code>&lt;script&gt;</code> 块来书写这个选项声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">// 使用普通的 &lt;script&gt; 来声明选项</span><br><span class="line">export default &#123;</span><br><span class="line"> inheritAttrs: false,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">// ...setup 部分逻辑</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>最常见的需要禁用 attribute 继承的场景就是 attribute 需要应用在根节点以外的其他元素上。通过设置 <code>inheritAttrs</code> 选项为 <code>false</code>，你可以完全控制透传进来的 attribute 被如何使用。</p>
<p>这些透传进来的 attribute 可以在模板的表达式中直接用 <code>$attrs</code> 访问到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;Fallthrough attribute: &#123;&#123; $attrs &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>这个 <code>$attrs</code> 对象包含了除组件所声明的 <code>props</code> 和 <code>emits</code> 之外的所有其他 attribute，例如 <code>class</code>，<code>style</code>，<code>v-on</code> 监听器等等。</p>
<p>有几点需要注意：</p>
<ul>
<li>和 props 有所不同，透传 attributes 在 JavaScript 中保留了它们原始的大小写，所以像 <code>foo-bar</code> 这样的一个 attribute 需要通过 <code>$attrs[&#39;foo-bar&#39;]</code> 来访问。</li>
<li>像 <code>@click</code> 这样的一个 <code>v-on</code> 事件监听器将在此对象下被暴露为一个函数 <code>$attrs.onClick</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;btn-wrapper&quot;&gt;</span><br><span class="line">  &lt;button class=&quot;btn&quot; v-bind=&quot;$attrs&quot;&gt;click me&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>小提示：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/template-syntax.html#dynamically-binding-multiple-attributes">没有参数的 <code>v-bind</code></a> 会将一个对象的所有属性都作为 attribute 应用到目标元素上。</p>
<h4 id="多根节点的-attributes-继承"><a href="#多根节点的-attributes-继承" class="headerlink" title="多根节点的 attributes 继承"></a>多根节点的 attributes 继承</h4><p>和单根节点组件有所不同，有着多个根节点的组件没有自动 attribute 透传行为。如果 <code>$attrs</code> 没有被显式绑定，将会抛出一个运行时警告。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;CustomLayout id=&quot;custom-layout&quot; @click=&quot;changeValue&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>如果 <code>&lt;CustomLayout&gt;</code> 有下面这样的多根节点模板，由于 Vue 不知道要将 attribute 透传到哪里，所以会抛出一个警告。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>$attrs</code> 被显式绑定，则不会有警告：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;...&lt;/header&gt;</span><br><span class="line">&lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;</span><br><span class="line">&lt;footer&gt;...&lt;/footer&gt;</span><br></pre></td></tr></table></figure>

<h4 id="在-JavaScript-中访问透传-Attributes"><a href="#在-JavaScript-中访问透传-Attributes" class="headerlink" title="在 JavaScript 中访问透传 Attributes"></a>在 JavaScript 中访问透传 Attributes</h4><p>如果需要，你可以在 <code>&lt;script setup&gt;</code> 中使用 <code>useAttrs()</code> API 来访问一个组件的所有透传 attribute：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useAttrs &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const attrs = useAttrs()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，虽然这里的 <code>attrs</code> 对象总是反映为最新的透传 attribute，但它并不是响应式的 (考虑到性能因素)。你不能通过侦听器去监听它的变化。如果你需要响应性，可以使用 prop。或者你也可以使用声明周期函数 <code>onUpdated()</code> 使得在每次更新时结合最新的 <code>attrs</code> 执行副作用。</p>
<h3 id="插槽-slots"><a href="#插槽-slots" class="headerlink" title="插槽 slots"></a>插槽 slots</h3><p>依靠 props 传值，还是不够，如果要传递模板内容，则需要使用插槽 slots。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;FancyButton&gt;</span><br><span class="line">  Click me! &lt;!-- 插槽内容 --&gt;</span><br><span class="line">&lt;/FancyButton&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;FancyButton&gt;</code> 模板是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button class=&quot;fancy-btn&quot;&gt;</span><br><span class="line">  &lt;slot&gt;&lt;/slot&gt; &lt;!-- 插槽出口 --&gt;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;slot&gt;</code> 元素是一个<strong>插槽出口</strong> (slot outlet)，标示了父元素提供的<strong>插槽内容</strong> (slot content) 将在哪里被渲染。</p>
<p><img data-src="//img.to2b.cn/blog/ljk/1677055310606.png"></p>
<p>最终渲染出的 DOM 是这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;fancy-btn&quot;</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="多个插槽"><a href="#多个插槽" class="headerlink" title="多个插槽"></a>多个插槽</h4><p>如果有多个插槽，需要给插槽命名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>这类带 <code>name</code> 的插槽被称为具名插槽 (named slots)。没有提供 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会隐式地命名为“default”。</p>
<p>要为具名插槽传入内容，我们需要使用一个含 <code>v-slot</code> 指令的 <code>&lt;template&gt;</code> 元素，并将目标插槽的名字传给该指令，<code>v-slot</code> 有对应的简写 <code>#</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;BaseLayout&gt;</span><br><span class="line">  &lt;template #header&gt;</span><br><span class="line">    &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template #default&gt;</span><br><span class="line">    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template #footer&gt;</span><br><span class="line">    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/BaseLayout&gt;</span><br></pre></td></tr></table></figure>

<p><img data-src="//img.to2b.cn/blog/ljk/1677055853340.png"></p>
<p>当一个组件同时接收默认插槽和具名插槽时，所有位于顶级的非 <code>&lt;template&gt;</code> 节点都被隐式地视为默认插槽的内容。所以上面也可以写成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;BaseLayout&gt;</span><br><span class="line">  &lt;template #header&gt;</span><br><span class="line">    &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 隐式的默认插槽 --&gt;</span><br><span class="line">  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template #footer&gt;</span><br><span class="line">    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/BaseLayout&gt;</span><br></pre></td></tr></table></figure>

<h4 id="向插槽传参"><a href="#向插槽传参" class="headerlink" title="向插槽传参"></a>向插槽传参</h4><p>Vue 模板中的表达式只能访问其定义时所处的作用域，这和 JavaScript 的词法作用域规则是一致的。</p>
<p>子组件定义插槽，父组件中使用子组件的时候，定义插槽中的内容。</p>
<p>插槽中内容是在父组件中定义的，所以插槽中只能访问父组件的作用域，但是如果插槽中需要使用到子组件作用域中的数据，怎么办？</p>
<p>子组件在定义插槽的时候，将需要使用到的数据传入插槽，这样，父组件在定义插槽中的内容时，就能使用传入的数据了。</p>
<p>定义组件 <code>FacyList</code>，并将<code>item</code>传入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;item in items&quot;&gt;</span><br><span class="line">    &lt;slot name=&quot;item&quot; :body=&quot;item.body&quot; :username=&quot;item.username&quot; :likes=&quot;item.links&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;item in items&quot;&gt;</span><br><span class="line">    &lt;slot name=&quot;item&quot; v-bind=&quot;item&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>注意：插槽上的 <code>name</code> 是一个 Vue 特别保留的 attribute，不会作为 props 传递给插槽。</p>
<p>在父组件中引用子组件 <code>FancyList</code>，可以使用传入的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;FancyList&gt;</span><br><span class="line">  &lt;template #item=&quot;&#123; body, username, likes &#125;&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;</span><br><span class="line">      &lt;p&gt;&#123;&#123; body &#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;by &#123;&#123; username &#125;&#125; | &#123;&#123; likes &#125;&#125; likes&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/FancyList&gt;</span><br></pre></td></tr></table></figure>

<h4 id="无渲染组件"><a href="#无渲染组件" class="headerlink" title="无渲染组件"></a>无渲染组件</h4><p>一些组件可能只包括了逻辑而不需要自己渲染内容，视图输出通过作用域插槽全权交给了消费者组件。我们将这种类型的组件称为<strong>无渲染组件</strong>。</p>
<p>大部分能用无渲染组件实现的功能都可以通过组合式 API 以另一种更高效的方式实现，并且还不会带来额外组件嵌套的开销。</p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>深层的组件需要顶层的数据，如果通过层层组件逐级传递 props，会很麻烦，中间层的组件可能根本不关系这些 props。</p>
<p>这个问题被称为 “<strong>prop 逐级透传</strong>”。</p>
<img data-src="//img.to2b.cn/blog/ljk/1677062368602.png" style="zoom:50%;" />

<p><code>provide</code>（提供） 和 <code>inject</code>（注入） 可以帮助我们解决这一问题。一个父组件相对于其所有的后代组件，会作为<strong>依赖提供者</strong>。任何后代的组件树，无论层级有多深，都可以<strong>注入</strong>由父组件提供给整条链路的依赖。</p>
<img data-src="//img.to2b.cn/blog/ljk/1677062470008.png" style="zoom:50%;" />

<h4 id="provide（提供）"><a href="#provide（提供）" class="headerlink" title="provide（提供）"></a>provide（提供）</h4><p>要为组件后代提供数据，需要使用到 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/composition-api-dependency-injection.html#provide"><code>provide()</code></a> 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; provide &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">provide(/* 注入名 */ &quot;message&quot;, /* 值 */ &quot;hello!&quot;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注入名</strong> 可以是字符串或是 <code>Symbol</code>。</p>
<p>后代组件会用注入名来查找期望注入的值。</p>
<p>可以多次调用 <code>provide()</code>，使用不同的注入名，注入不同的依赖值。</p>
<p><strong>值</strong> 可以是任意类型，包括响应式的状态，比如一个 ref：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, provide &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="title function_">provide</span>(<span class="string">&quot;key&quot;</span>, count)</span><br></pre></td></tr></table></figure>

<p>提供的响应式状态使后代组件可以由此和提供者建立响应式的联系。</p>
<h5 id="应用层-provide"><a href="#应用层-provide" class="headerlink" title="应用层 provide"></a>应用层 provide</h5><p>除了在一个组件中提供依赖，我们还可以在整个应用层面提供依赖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">provide</span>(<span class="comment">/* 注入名 */</span> <span class="string">&quot;message&quot;</span>, <span class="comment">/* 值 */</span> <span class="string">&quot;hello!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在应用级别提供的数据在该应用内的所有组件中都可以注入。这在你编写<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/reusability/plugins.html">插件</a>时会特别有用，因为插件一般都不会使用组件形式来提供值。</p>
<h4 id="inject（注入）"><a href="#inject（注入）" class="headerlink" title="inject（注入）"></a>inject（注入）</h4><p>要注入上层组件提供的数据，需使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/composition-api-dependency-injection.html#inject"><code>inject()</code></a> 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; inject &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const message = inject(&quot;message&quot;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如果提供的值是一个 ref，注入进来的会是该 ref 对象，而<strong>不会</strong>自动解包为其内部的值。这使得注入方组件能够通过 ref 对象保持了和供给方的响应性链接。</p>
<h5 id="注入默认值"><a href="#注入默认值" class="headerlink" title="注入默认值"></a>注入默认值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果没有祖先组件提供 &quot;message&quot;</span></span><br><span class="line"><span class="comment">// `value` 会是 &quot;这是默认值&quot;</span></span><br><span class="line"><span class="keyword">const</span> value = <span class="title function_">inject</span>(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;这是默认值&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><figcaption><span>s</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const value = inject(&#x27;key&#x27;, () =&gt; new ExpensiveClass())</span><br></pre></td></tr></table></figure>

<h4 id="和响应式数据配合使用"><a href="#和响应式数据配合使用" class="headerlink" title="和响应式数据配合使用"></a>和响应式数据配合使用</h4><p>当提供 &#x2F; 注入响应式的数据时，<strong>建议尽可能将任何对响应式状态的变更都保持在供给方组件中</strong>。这样可以确保所提供状态的声明和变更操作都内聚在同一个组件内，使其更容易维护。</p>
<p>有的时候，我们可能需要在注入方组件中更改数据。在这种情况下，我们推荐在供给方组件内声明并提供一个更改数据的方法函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在供给方组件内 --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; provide, ref &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const location = ref(&quot;North Pole&quot;)</span><br><span class="line"></span><br><span class="line">function updateLocation() &#123;</span><br><span class="line"> location.value = &quot;South Pole&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provide(&quot;location&quot;, &#123;</span><br><span class="line"> location,</span><br><span class="line"> updateLocation,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在注入方组件 --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; inject &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const &#123; location, updateLocation &#125; = inject(&quot;location&quot;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;button @click=&quot;updateLocation&quot;&gt;&#123;&#123; location &#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>最后，如果你想确保提供的数据不能被注入方的组件更改，你可以使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-core.html#readonly"><code>readonly()</code></a> 来包装提供的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, provide, readonly &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const count = ref(0)</span><br><span class="line">provide(&quot;read-only-count&quot;, readonly(count))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="使用-symbol-作为注入名"><a href="#使用-symbol-作为注入名" class="headerlink" title="使用 symbol 作为注入名"></a>使用 symbol 作为注入名</h4><p>如果你正在构建大型的应用，包含非常多的依赖提供，或者你正在编写提供给其他开发者使用的组件库，建议最好使用 Symbol 来作为注入名以避免潜在的冲突。</p>
<p>我们通常推荐在一个单独的文件中导出这些注入名 Symbol：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keys.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myInjectionKey = <span class="title class_">Symbol</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在供给方组件中</span></span><br><span class="line"><span class="keyword">import</span> &#123; provide &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; myInjectionKey &#125; <span class="keyword">from</span> <span class="string">&quot;./keys.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">provide</span>(myInjectionKey, &#123;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  要提供的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入方组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; myInjectionKey &#125; <span class="keyword">from</span> <span class="string">&quot;./keys.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> injected = <span class="title function_">inject</span>(myInjectionKey)</span><br></pre></td></tr></table></figure>

<h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。Vue 提供了 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/general.html#defineasynccomponent"><code>defineAsyncComponent</code></a> 方法来实现此功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...从服务器获取组件</span></span><br><span class="line">  <span class="title function_">resolve</span>(<span class="comment">/* 获取到的组件 */</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ... 像使用其他一般组件一样使用 `AsyncComp`</span></span><br></pre></td></tr></table></figure>

<p>如你所见，<code>defineAsyncComponent</code> 方法接收一个返回 Promise 的加载函数。这个 Promise 的 <code>resolve</code> 回调方法应该在从服务器获得组件定义时调用。你也可以调用 <code>reject(reason)</code> 表明加载失败。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import">ES 模块动态导入</a>也会返回一个 Promise，所以多数情况下我们会将它和 <code>defineAsyncComponent</code> 搭配使用。类似 Vite 和 Webpack 这样的构建工具也支持此语法 (并且会将它们作为打包时的代码分割点)，因此我们也可以用它来导入 Vue 单文件组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./components/MyComponent.vue&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>最后得到的 <code>AsyncComp</code> 是一个外层包装过的组件，仅在页面需要它渲染时才会调用加载内部实际组件的函数。它会将接收到的 props 和插槽传给内部组件，所以你可以使用这个异步的包装组件无缝地替换原始组件，同时实现延迟加载。</p>
<h4 id="加载与错误状态"><a href="#加载与错误状态" class="headerlink" title="加载与错误状态"></a>加载与错误状态</h4><p>异步操作不可避免地会涉及到加载和错误状态，因此 <code>defineAsyncComponent()</code> 也支持在高级选项中处理这些状态：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp</span> = <span class="title function_">defineAsyncComponent</span>(&#123;</span><br><span class="line"> <span class="comment">// 加载函数</span></span><br><span class="line"> <span class="attr">loader</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./Foo.vue&quot;</span>),</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 加载异步组件时使用的组件</span></span><br><span class="line"> <span class="attr">loadingComponent</span>: <span class="title class_">LoadingComponent</span>,</span><br><span class="line"> <span class="comment">// 展示加载组件前的延迟时间，默认为 200ms</span></span><br><span class="line"> <span class="attr">delay</span>: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 加载失败后展示的组件</span></span><br><span class="line"> <span class="attr">errorComponent</span>: <span class="title class_">ErrorComponent</span>,</span><br><span class="line"> <span class="comment">// 如果提供了一个 timeout 时间限制，并超时了</span></span><br><span class="line"> <span class="comment">// 也会显示这里配置的报错组件，默认值是：Infinity</span></span><br><span class="line"> <span class="attr">timeout</span>: <span class="number">3000</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果提供了一个加载组件，它将在内部组件加载时先行显示。在加载组件显示之前有一个默认的 200ms 延迟——这是因为在网络状况较好时，加载完成得很快，加载组件和最终组件之间的替换太快可能产生闪烁，反而影响用户感受。</p>
<p>如果提供了一个报错组件，则它会在加载器函数返回的 Promise 抛错时被渲染。你还可以指定一个超时时间，在请求耗时超过指定时间时也会渲染报错组件。</p>
<h4 id="搭配-Suspense-使用"><a href="#搭配-Suspense-使用" class="headerlink" title="搭配 Suspense 使用"></a>搭配 Suspense 使用</h4><p>异步组件可以搭配内置的 <code>&lt;Suspense&gt;</code> 组件一起使用，若想了解 <code>&lt;Suspense&gt;</code> 和异步组件之间交互，请参阅 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/built-ins/suspense.html"><code>Suspense</code></a> 章节。</p>
<h2 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h2><h3 id="组合式函数"><a href="#组合式函数" class="headerlink" title="组合式函数"></a>组合式函数</h3><p>复用<strong>无状态逻辑</strong>的库有很多，比如你可能已经用过的 <a target="_blank" rel="noopener" href="https://lodash.com/">lodash</a> 或是 <a target="_blank" rel="noopener" href="https://date-fns.org/">date-fns</a>。</p>
<p>在 Vue 中，复用<strong>有状态逻辑</strong>使用“组合式函数”(Composables) 。</p>
<p>和组件一样，可以在组合式函数中使用所有的 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/#composition-api">组合式 API</a>，并返回需要暴露的状态。</p>
<p>更酷的是，你还可以嵌套多个组合式函数：一个组合式函数可以调用一个或多个其他的组合式函数。这使得我们可以像使用多个组件组合成整个应用一样，用多个较小且逻辑独立的单元来组合形成复杂的逻辑。实际上，这正是为什么我们决定将实现了这一设计模式的 API 集合命名为组合式 API。</p>
<h4 id="异步状态示例示例"><a href="#异步状态示例示例" class="headerlink" title="异步状态示例示例"></a>异步状态示例示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useFetch</span> = (<span class="params">url: string</span>) =&gt; &#123;</span><br><span class="line"> <span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"> <span class="keyword">const</span> loading = <span class="title function_">ref</span>(<span class="literal">true</span>)</span><br><span class="line"> <span class="keyword">const</span> error = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">request</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">  <span class="variable language_">window</span></span><br><span class="line">   .<span class="title function_">fetch</span>(url)</span><br><span class="line">   .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">   .<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> (data.<span class="property">value</span> = json))</span><br><span class="line">   .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> (error.<span class="property">value</span> = err))</span><br><span class="line">   .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> (loading.<span class="property">value</span> = <span class="literal">false</span>))</span><br><span class="line"></span><br><span class="line"> <span class="title function_">request</span>()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">  data,</span><br><span class="line">  loading,</span><br><span class="line">  error,</span><br><span class="line">  <span class="attr">refetch</span>: request,</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; useFetch &#125; from &quot;@/utils/fetch&quot;</span><br><span class="line"></span><br><span class="line">const &#123; data, loading, error, refetch &#125; = useFetch(&quot;http://101.43.187.22:9501/api/nav/wallPaper&quot;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;el-button @click=&quot;refetch&quot;&gt;refresh&lt;/el-button&gt;</span><br><span class="line"> &lt;el-row v-for=&quot;url of data?.result&quot; :key=&quot;url&quot; v-loading=&quot;loading&quot;&gt;&#123;&#123; url &#125;&#125;&lt;/el-row&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>推荐使用 <a target="_blank" rel="noopener" href="https://tanstack.com/query/latest/docs/vue/reference/useQuery">TanStack Query</a> 库。</p>
<h4 id="约定和最佳实践"><a href="#约定和最佳实践" class="headerlink" title="约定和最佳实践"></a>约定和最佳实践</h4><h5 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h5><p>组合式函数约定用驼峰命名法命名，并以“use”作为开头。</p>
<h5 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h5><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>你可能已经注意到了，我们一直在组合式函数中使用 <code>ref()</code> 而不是 <code>reactive()</code>。我们推荐的约定是组合式函数始终返回一个包含多个 ref 的普通的非响应式对象，这样该对象在组件中被解构为 ref 之后仍可以保持响应性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x 和 y 是两个 ref</span></span><br><span class="line"><span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">useMouse</span>()</span><br></pre></td></tr></table></figure>

<p>从组合式函数返回一个响应式对象会导致在对象解构过程中丢失与组合式函数内状态的响应性连接。与之相反，ref 则可以维持这一响应性连接。</p>
<p>如果你更希望以对象属性的形式来使用组合式函数中返回的状态，你可以将返回的对象用 <code>reactive()</code> 包装一次，这样其中的 ref 会被自动解包，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mouse = <span class="title function_">reactive</span>(<span class="title function_">useMouse</span>())</span><br><span class="line"><span class="comment">// mouse.x 链接到了原来的 x ref</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mouse.<span class="property">x</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mouse position is at: &#123;&#123; mouse.x &#125;&#125;, &#123;&#123; mouse.y &#125;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h5><p>在组合式函数中的确可以执行副作用 (例如：添加 DOM 事件监听器或者请求数据)，但请注意以下规则：</p>
<ul>
<li><p>如果你的应用用到了<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/scaling-up/ssr.html">服务端渲染</a> (SSR)，请确保在组件挂载后才调用的生命周期钩子中执行 DOM 相关的副作用，例如：<code>onMounted()</code>。这些钩子仅会在浏览器中被调用，因此可以确保能访问到 DOM。</p>
</li>
<li><p>确保在 <code>onUnmounted()</code> 时清理副作用。举例来说，如果一个组合式函数设置了一个事件监听器，它就应该在 <code>onUnmounted()</code> 中被移除。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; onMounted, onUnmounted &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useEventListener</span>(<span class="params">target, event, callback</span>) &#123;</span><br><span class="line"> <span class="comment">// 如果你想的话，</span></span><br><span class="line"> <span class="comment">// 也可以用字符串形式的 CSS 选择器来寻找目标 DOM 元素</span></span><br><span class="line"> <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> target.<span class="title function_">addEventListener</span>(event, callback))</span><br><span class="line"> <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> target.<span class="title function_">removeEventListener</span>(event, callback)) <span class="comment">// 清理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h5><p>组合式函数在 <code>&lt;script setup&gt;</code> 或 <code>setup()</code> 钩子中，应始终被<strong>同步地</strong>调用。在某些场景下，你也可以在像 <code>onMounted()</code> 这样的生命周期钩子中使用他们。</p>
<p>这个限制是为了让 Vue 能够确定当前正在被执行的到底是哪个组件实例，只有能确认当前组件实例，才能够：</p>
<ol>
<li>将生命周期钩子注册到该组件实例上；</li>
<li>将计算属性和监听器注册到该组件实例上，以便在该组件被卸载时停止监听，避免内存泄漏。</li>
</ol>
<blockquote>
<p>提示：</p>
<p><code>&lt;script setup&gt;</code> 是唯一在调用 <code>await</code> 之后仍可调用组合式函数的地方。编译器会在异步操作之后自动为你恢复当前的组件实例。</p>
</blockquote>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>除了 Vue 内置的一系列指令 (比如 <code>v-model</code> 或 <code>v-show</code>) 之外，Vue 还允许你注册自定义的指令 (Custom Directives)。</p>
<p>我们已经介绍了两种在 Vue 中重用代码的方式：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/component-basics.html">组件</a>和<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/reusability/composables.html">组合式函数</a>。组件是主要的构建模块，而组合式函数则侧重于有状态的逻辑。另一方面，自定义指令主要是为了重用涉及普通元素的底层 DOM 访问的逻辑。</p>
<p>一个自定义指令由一个包含类似组件生命周期钩子的对象来定义。钩子函数会接收到指令所绑定元素作为其参数。下面是一个自定义指令的例子，当一个 input 元素被 Vue 插入到 DOM 中后，它会被自动聚焦：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">// 在模板中启用 v-focus</span><br><span class="line">const vFocus = &#123;</span><br><span class="line"> mounted: el =&gt; el.focus(),</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;input v-focus /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>假设你还未点击页面中的其他地方，那么上面这个 input 元素应该会被自动聚焦。该指令比 <code>autofocus</code> attribute 更有用，因为它不仅仅可以在页面加载完成后生效，还可以在 Vue 动态插入元素后生效。</p>
<p>在 <code>&lt;script setup&gt;</code> 中，任何以 <code>v</code> 开头的驼峰式命名的变量都可以被用作一个自定义指令。在上面的例子中，<code>vFocus</code> 即可以在模板中以 <code>v-focus</code> 的形式使用。</p>
<p>将一个自定义指令全局注册到应用层级也是一种常见的做法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使 v-focus 在所有组件中都可用</span></span><br><span class="line">app.<span class="title function_">directive</span>(<span class="string">&quot;focus&quot;</span>, &#123;</span><br><span class="line"> <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：</p>
<p>只有当所需功能只能通过直接的 DOM 操作来实现时，才应该使用自定义指令。其他情况下应该尽可能地使用 <code>v-bind</code> 这样的内置指令来声明式地使用模板，这样更高效，也对服务端渲染更友好。</p>
</blockquote>
<h4 id="指令钩子"><a href="#指令钩子" class="headerlink" title="指令钩子"></a>指令钩子</h4><p>一个指令的定义对象可以提供几种钩子函数 (都是可选的)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myDirective = &#123;</span><br><span class="line"> <span class="comment">// 在绑定元素的 attribute 前</span></span><br><span class="line"> <span class="comment">// 或事件监听器应用前调用</span></span><br><span class="line"> <span class="title function_">created</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;</span><br><span class="line">  <span class="comment">// 下面会介绍各个参数的细节</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="comment">// 在元素被插入到 DOM 前调用</span></span><br><span class="line"> <span class="title function_">beforeMount</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line"> <span class="comment">// 在绑定元素的父组件</span></span><br><span class="line"> <span class="comment">// 及他自己的所有子节点都挂载完成后调用</span></span><br><span class="line"> <span class="title function_">mounted</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line"> <span class="comment">// 绑定元素的父组件更新前调用</span></span><br><span class="line"> <span class="title function_">beforeUpdate</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line"> <span class="comment">// 在绑定元素的父组件</span></span><br><span class="line"> <span class="comment">// 及他自己的所有子节点都更新后调用</span></span><br><span class="line"> <span class="title function_">updated</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line"> <span class="comment">// 绑定元素的父组件卸载前调用</span></span><br><span class="line"> <span class="title function_">beforeUnmount</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line"> <span class="comment">// 绑定元素的父组件卸载后调用</span></span><br><span class="line"> <span class="title function_">unmounted</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="钩子参数"><a href="#钩子参数" class="headerlink" title="钩子参数"></a>钩子参数</h4><h4 id="简化形式"><a href="#简化形式" class="headerlink" title="简化形式"></a>简化形式</h4><h4 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h4><h4 id="在组件上使用-1"><a href="#在组件上使用-1" class="headerlink" title="在组件上使用"></a>在组件上使用</h4><p>当在组件上使用自定义指令时，它会始终应用于组件的根节点，和<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/components/attrs.html">透传 attributes</a> 类似。</p>
<p>总的来说，<strong>不</strong>推荐在组件上使用自定义指令。</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>插件 (Plugins) 是一种能为 Vue 添加全局功能的工具代码。下面是如何安装一个插件的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(myPlugin, &#123;</span><br><span class="line"> <span class="comment">/* 可选的选项 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>一个插件可以是一个拥有 <code>install()</code> 方法的对象，也可以直接是一个安装函数本身。安装函数会接收到安装它的<a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/application.html">应用实例</a>和传递给 <code>app.use()</code> 的额外选项作为参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPlugin = &#123;</span><br><span class="line"> <span class="title function_">install</span>(<span class="params">app, options</span>) &#123;</span><br><span class="line">  <span class="comment">// 配置此应用</span></span><br><span class="line"> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插件没有严格定义的使用范围，但是插件发挥作用的常见场景主要包括以下几种：</p>
<ol>
<li>通过 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/application.html#app-component"><code>app.component()</code></a> 和 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/application.html#app-directive"><code>app.directive()</code></a> 注册一到多个全局组件或自定义指令。</li>
<li>通过 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/application.html#app-provide"><code>app.provide()</code></a> 使一个资源 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/components/provide-inject.html">可被注入</a> 进整个应用。</li>
<li>向 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/application.html#app-config-globalproperties"><code>app.config.globalProperties</code></a> 中添加一些全局实例属性或方法</li>
<li>一个可能上述三种都包含了的功能库 (例如 <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-router-next">vue-router</a>)。</li>
</ol>
<h4 id="编写一个插件"><a href="#编写一个插件" class="headerlink" title="编写一个插件"></a>编写一个插件</h4><p>…</p>
<h2 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h2><h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><p>在一个元素或组件进入和离开 DOM 时应用动画。</p>
<h3 id="TransitionGroup"><a href="#TransitionGroup" class="headerlink" title="TransitionGroup"></a>TransitionGroup</h3><p>在一个 <code>v-for</code> 列表中的元素或组件被插入，移动，或移除时应用动画。</p>
<h3 id="KeepAlive"><a href="#KeepAlive" class="headerlink" title="KeepAlive"></a>KeepAlive</h3><p>想要组件能在被“切走”的时候保留它们的状态。</p>
<p>可以用 <code>&lt;KeepAlive&gt;</code> 内置组件将这些动态组件包装起来。</p>
<h3 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h3><p>它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。</p>
<h3 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h3><blockquote>
<p><code>&lt;Suspense&gt;</code> 是一项实验性功能。它不一定会最终成为稳定功能，并且在稳定之前相关 API 也可能会发生变化。</p>
</blockquote>
<p><code>&lt;Suspense&gt;</code> 是一个内置组件，用来在组件树中协调对异步依赖的处理。它让我们可以在组件树上层等待下层的多个嵌套异步依赖项解析完成，并可以在等待时渲染一个加载状态。</p>
<h2 id="应用规模化"><a href="#应用规模化" class="headerlink" title="应用规模化"></a>应用规模化</h2><h3 id="状态管理-pinia"><a href="#状态管理-pinia" class="headerlink" title="状态管理 pinia"></a><a target="_blank" rel="noopener" href="https://pinia.vuejs.org/zh/introduction.html">状态管理 pinia</a></h3><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h3 id="服务端渲染-SSR"><a href="#服务端渲染-SSR" class="headerlink" title="服务端渲染 (SSR)"></a>服务端渲染 (SSR)</h3><h2 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h2><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><h2 id="进阶主题"><a href="#进阶主题" class="headerlink" title="进阶主题"></a>进阶主题</h2>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/Golang/%E8%85%BE%E8%AE%AFgo%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Golang/%E8%85%BE%E8%AE%AFgo%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">腾讯go安全指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-23 15:43:05" itemprop="dateCreated datePublished" datetime="2023-02-23T15:43:05+08:00">2023-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-29 16:58:22" itemprop="dateModified" datetime="2023-05-29T16:58:22+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>转载：</p>
<p><a target="_blank" rel="noopener" href="https://gitee.com/tgzhome/tencent-code-security-guide/blob/main/Go%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97.md">https://gitee.com/tgzhome/tencent-code-security-guide/blob/main/Go%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97.md</a></p>
<h1 id="通用类"><a href="#通用类" class="headerlink" title="通用类"></a>通用类</h1><h2 id="1-代码实现类"><a href="#1-代码实现类" class="headerlink" title="1. 代码实现类"></a>1. 代码实现类</h2><h3 id="1-1-内存管理"><a href="#1-1-内存管理" class="headerlink" title="1.1 内存管理"></a>1.1 内存管理</h3><h4 id="1-1-1【必须】切片长度校验"><a href="#1-1-1【必须】切片长度校验" class="headerlink" title="1.1.1【必须】切片长度校验"></a>1.1.1【必须】切片长度校验</h4><ul>
<li>在对slice进行操作时，必须判断长度是否合法，防止程序panic</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad: 未判断data的长度，可导致 index out of range</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decode</span><span class="params">(data []<span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> data[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; data[<span class="number">1</span>] == <span class="string">&#x27;U&#x27;</span> &amp;&amp; data[<span class="number">2</span>] == <span class="string">&#x27;Z&#x27;</span> &amp;&amp; data[<span class="number">3</span>] == <span class="string">&#x27;Z&#x27;</span> &amp;&amp; data[<span class="number">4</span>] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; data[<span class="number">5</span>] == <span class="string">&#x27;R&#x27;</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Bad&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad: slice bounds out of range</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> slice = []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line"> fmt.Println(slice[:<span class="number">10</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good: 使用data前应判断长度是否合法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decode</span><span class="params">(data []<span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">6</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> data[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; data[<span class="number">1</span>] == <span class="string">&#x27;U&#x27;</span> &amp;&amp; data[<span class="number">2</span>] == <span class="string">&#x27;Z&#x27;</span> &amp;&amp; data[<span class="number">3</span>] == <span class="string">&#x27;Z&#x27;</span> &amp;&amp; data[<span class="number">4</span>] == <span class="string">&#x27;E&#x27;</span> &amp;&amp; data[<span class="number">5</span>] == <span class="string">&#x27;R&#x27;</span> &#123;</span><br><span class="line">   fmt.Println(<span class="string">&quot;Good&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2【必须】nil指针判断"><a href="#1-1-2【必须】nil指针判断" class="headerlink" title="1.1.2【必须】nil指针判断"></a>1.1.2【必须】nil指针判断</h4><ul>
<li>进行指针操作时，必须判断该指针是否为nil，防止程序panic，尤其在进行结构体Unmarshal时</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Packet <span class="keyword">struct</span> &#123;</span><br><span class="line"> PackeyType    <span class="type">uint8</span></span><br><span class="line"> PackeyVersion <span class="type">uint8</span></span><br><span class="line"> Data          *Data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Data <span class="keyword">struct</span> &#123;</span><br><span class="line"> Stat <span class="type">uint8</span></span><br><span class="line"> Len  <span class="type">uint8</span></span><br><span class="line"> Buf  [<span class="number">8</span>]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Packet)</span></span> UnmarshalBinary(b []<span class="type">byte</span>) <span class="type">error</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(b) &lt; <span class="number">2</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> io.EOF</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> p.PackeyType = b[<span class="number">0</span>]</span><br><span class="line"> p.PackeyVersion = b[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 若长度等于2，那么不会new Data</span></span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">len</span>(b) &gt; <span class="number">2</span> &#123;</span><br><span class="line">  p.Data = <span class="built_in">new</span>(Data)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad: 未判断指针是否为nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> packet := <span class="built_in">new</span>(Packet)</span><br><span class="line"> data := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">2</span>)</span><br><span class="line"> <span class="keyword">if</span> err := packet.UnmarshalBinary(data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Failed to unmarshal packet&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">&quot;Stat: %v\n&quot;</span>, packet.Data.Stat)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good: 判断Data指针是否为nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> packet := <span class="built_in">new</span>(Packet)</span><br><span class="line"> data := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> err := packet.UnmarshalBinary(data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Failed to unmarshal packet&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> packet.Data == <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fmt.Printf(<span class="string">&quot;Stat: %v\n&quot;</span>, packet.Data.Stat)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-3【必须】整数安全"><a href="#1-1-3【必须】整数安全" class="headerlink" title="1.1.3【必须】整数安全"></a>1.1.3【必须】整数安全</h4><ul>
<li><p>在进行数字运算操作时，需要做好长度限制，防止外部输入运算导致异常：</p>
<ul>
<li>确保无符号整数运算时不会反转</li>
<li>确保有符号整数运算时不会出现溢出</li>
<li>确保整型转换时不会出现截断错误</li>
<li>确保整型转换时不会出现符号错误</li>
</ul>
</li>
<li><p>以下场景必须严格进行长度限制：</p>
<ul>
<li>作为数组索引</li>
<li>作为对象的长度或者大小</li>
<li>作为数组的边界（如作为循环计数器）</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad: 未限制长度，导致整数溢出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overflow</span><span class="params">(numControlByUser <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> numInt <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line"> numInt = numControlByUser + <span class="number">1</span></span><br><span class="line"> <span class="comment">// 对长度限制不当，导致整数溢出</span></span><br><span class="line"> fmt.Printf(<span class="string">&quot;%d\n&quot;</span>, numInt)</span><br><span class="line"> <span class="comment">// 使用numInt，可能导致其他错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> overflow(<span class="number">2147483647</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overflow</span><span class="params">(numControlByUser <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> numInt <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line"> numInt = numControlByUser + <span class="number">1</span></span><br><span class="line"> <span class="keyword">if</span> numInt &lt; <span class="number">0</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;integer overflow&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> fmt.Println(<span class="string">&quot;integer ok&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> overflow(<span class="number">2147483647</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-4【必须】make分配长度验证"><a href="#1-1-4【必须】make分配长度验证" class="headerlink" title="1.1.4【必须】make分配长度验证"></a>1.1.4【必须】make分配长度验证</h4><ul>
<li>在进行make分配内存时，需要对外部可控的长度进行校验，防止程序panic。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parse</span><span class="params">(lenControlByUser <span class="type">int</span>, data []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line"> size := lenControlByUser</span><br><span class="line"> <span class="comment">// 对外部传入的size，进行长度判断以免导致panic</span></span><br><span class="line"> buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, size)</span><br><span class="line"> <span class="built_in">copy</span>(buffer, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parse</span><span class="params">(lenControlByUser <span class="type">int</span>, data []<span class="type">byte</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line"> size := lenControlByUser</span><br><span class="line"> <span class="comment">// 限制外部可控的长度大小范围</span></span><br><span class="line"> <span class="keyword">if</span> size &gt; <span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;value too large&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> buffer := <span class="built_in">make</span>([]<span class="type">byte</span>, size)</span><br><span class="line"> <span class="built_in">copy</span>(buffer, data)</span><br><span class="line"> <span class="keyword">return</span> buffer, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-5【必须】禁止SetFinalizer和指针循环引用同时使用"><a href="#1-1-5【必须】禁止SetFinalizer和指针循环引用同时使用" class="headerlink" title="1.1.5【必须】禁止SetFinalizer和指针循环引用同时使用"></a>1.1.5【必须】禁止SetFinalizer和指针循环引用同时使用</h4><ul>
<li>当一个对象从被GC选中到移除内存之前，runtime.SetFinalizer()都不会执行，即使程序正常结束或者发生错误。由指针构成的“循环引用”虽然能被GC正确处理，但由于无法确定Finalizer依赖顺序，从而无法调用runtime.SetFinalizer()，导致目标对象无法变成可达状态，从而造成内存无法被回收。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">var</span> a, b Data</span><br><span class="line"> a.o = &amp;b</span><br><span class="line"> b.o = &amp;a</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 指针循环引用，SetFinalizer()无法正常调用</span></span><br><span class="line"> runtime.SetFinalizer(&amp;a, <span class="function"><span class="keyword">func</span><span class="params">(d *Data)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;a %p final.\n&quot;</span>, d)</span><br><span class="line"> &#125;)</span><br><span class="line"> runtime.SetFinalizer(&amp;b, <span class="function"><span class="keyword">func</span><span class="params">(d *Data)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;b %p final.\n&quot;</span>, d)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">  foo()</span><br><span class="line">  time.Sleep(time.Millisecond)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-1-6【必须】禁止重复释放channel"><a href="#1-1-6【必须】禁止重复释放channel" class="headerlink" title="1.1.6【必须】禁止重复释放channel"></a>1.1.6【必须】禁止重复释放channel</h4><ul>
<li>重复释放一般存在于异常流程判断中，如果恶意攻击者构造出异常条件使程序重复释放channel，则会触发运行时panic，从而造成DoS攻击。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line"> err := processBusiness()</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  c &lt;- <span class="number">0</span></span><br><span class="line">  <span class="built_in">close</span>(c) <span class="comment">// 重复释放channel</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> c &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> <span class="keyword">defer</span> <span class="built_in">close</span>(c) <span class="comment">// 使用defer延迟关闭channel</span></span><br><span class="line"> err := processBusiness()</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  c &lt;- <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"> c &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-7【必须】确保每个协程都能退出"><a href="#1-1-7【必须】确保每个协程都能退出" class="headerlink" title="1.1.7【必须】确保每个协程都能退出"></a>1.1.7【必须】确保每个协程都能退出</h4><ul>
<li>启动一个协程就会做一个入栈操作，在系统不退出的情况下，协程也没有设置退出条件，则相当于协程失去了控制，它占用的资源无法回收，可能会导致内存泄露。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad: 协程没有设置退出条件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWaiter</span><span class="params">(name <span class="type">string</span>, second <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">  time.Sleep(time.Duration(second) * time.Second)</span><br><span class="line">  fmt.Println(name, <span class="string">&quot; is ready!&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-8【推荐】不使用unsafe包"><a href="#1-1-8【推荐】不使用unsafe包" class="headerlink" title="1.1.8【推荐】不使用unsafe包"></a>1.1.8【推荐】不使用unsafe包</h4><ul>
<li>由于unsafe包绕过了 Golang 的内存安全原则，一般来说使用该库是不安全的，可导致内存破坏，尽量避免使用该包。若必须要使用unsafe操作指针，必须做好安全校验。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad: 通过unsafe操作原始指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unsafePointer</span><span class="params">()</span></span> &#123;</span><br><span class="line"> b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1</span>)</span><br><span class="line"> foo := (*<span class="type">int</span>)(unsafe.Pointer(<span class="type">uintptr</span>(unsafe.Pointer(&amp;b[<span class="number">0</span>])) + <span class="type">uintptr</span>(<span class="number">0xfffffffe</span>)))</span><br><span class="line"> fmt.Print(*foo + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [signal SIGSEGV: segmentation violation code=0x1 addr=0xc100068f55 pc=0x49142b]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-1-9【推荐】不使用slice作为函数入参"><a href="#1-1-9【推荐】不使用slice作为函数入参" class="headerlink" title="1.1.9【推荐】不使用slice作为函数入参"></a>1.1.9【推荐】不使用slice作为函数入参</h4><ul>
<li>slice在作为函数入参时，函数内对slice的修改可能会影响原始数据</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="comment">// slice作为函数入参时包含原始数组指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(array []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">10</span> <span class="comment">// 对入参slice的元素修改会影响原始数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    array := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    modify(array)</span><br><span class="line">    fmt.Println(array) <span class="comment">// output：[10 2 3 4 5]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="comment">// 数组作为函数入参，而不是slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modify</span><span class="params">(array [5]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  array[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 传入数组，注意数组与slice的区别</span></span><br><span class="line">    array := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    modify(array)</span><br><span class="line">    fmt.Println(array)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-2-文件操作"><a href="#1-2-文件操作" class="headerlink" title="1.2 文件操作"></a>1.2 文件操作</h3><h4 id="1-2-1【必须】-路径穿越检查"><a href="#1-2-1【必须】-路径穿越检查" class="headerlink" title="1.2.1【必须】 路径穿越检查"></a>1.2.1【必须】 路径穿越检查</h4><ul>
<li>在进行文件操作时，如果对外部传入的文件名未做限制，可能导致任意文件读取或者任意文件写入，严重可能导致代码执行。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad: 任意文件读取</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"> path := r.URL.Query()[<span class="string">&quot;path&quot;</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 未过滤文件路径，可能导致任意文件读取</span></span><br><span class="line"> data, _ := ioutil.ReadFile(path)</span><br><span class="line"> w.Write(data)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 对外部传入的文件名变量，还需要验证是否存在../等路径穿越的文件名</span></span><br><span class="line"> data, _ = ioutil.ReadFile(filepath.Join(<span class="string">&quot;/home/user/&quot;</span>, path))</span><br><span class="line"> w.Write(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad: 任意文件写入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unzip</span><span class="params">(f <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"> r, _ := zip.OpenReader(f)</span><br><span class="line"> <span class="keyword">for</span> _, f := <span class="keyword">range</span> r.File &#123;</span><br><span class="line">  p, _ := filepath.Abs(f.Name)</span><br><span class="line">  <span class="comment">// 未验证压缩文件名，可能导致../等路径穿越，任意文件路径写入</span></span><br><span class="line">  ioutil.WriteFile(p, []<span class="type">byte</span>(<span class="string">&quot;present&quot;</span>), <span class="number">0640</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good: 检查压缩的文件名是否包含..路径穿越特征字符，防止任意写入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">unzipGood</span><span class="params">(f <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"> r, err := zip.OpenReader(f)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;read zip file fail&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> _, f := <span class="keyword">range</span> r.File &#123;</span><br><span class="line">  <span class="keyword">if</span> !strings.Contains(f.Name, <span class="string">&quot;..&quot;</span>) &#123;</span><br><span class="line">   p, _ := filepath.Abs(f.Name)</span><br><span class="line">   ioutil.WriteFile(p, []<span class="type">byte</span>(<span class="string">&quot;present&quot;</span>), <span class="number">0640</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2【必须】-文件访问权限"><a href="#1-2-2【必须】-文件访问权限" class="headerlink" title="1.2.2【必须】 文件访问权限"></a>1.2.2【必须】 文件访问权限</h4><ul>
<li>根据创建文件的敏感性设置不同级别的访问权限，以防止敏感数据被任意权限用户读取。例如，设置文件权限为：-rw-r—–</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioutil.WriteFile(p, []<span class="type">byte</span>(<span class="string">&quot;present&quot;</span>), <span class="number">0640</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-3-系统接口"><a href="#1-3-系统接口" class="headerlink" title="1.3 系统接口"></a>1.3 系统接口</h3><p>1.3.1【必须】命令执行检查</p>
<ul>
<li>使用exec.Command、exec.CommandContext、syscall.StartProcess、os.StartProcess等函数时，第一个参数（path）直接取外部输入值时，应使用白名单限定可执行的命令范围，不允许传入bash、cmd、sh等命令；</li>
<li>使用exec.Command、exec.CommandContext等函数时，通过bash、cmd、sh等创建shell，-c后的参数（arg）拼接外部输入，应过滤\n  $  &amp;  ;  |  ‘  “  ( )  &#96;等潜在恶意字符；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line"> userInputedVal := <span class="string">&quot;&amp;&amp; echo &#x27;hello&#x27;&quot;</span> <span class="comment">// 假设外部传入该变量值</span></span><br><span class="line"> cmdName := <span class="string">&quot;ping &quot;</span> + userInputedVal</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 未判断外部输入是否存在命令注入字符，结合sh可造成命令注入</span></span><br><span class="line"> cmd := exec.Command(<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmdName)</span><br><span class="line"> output, _ := cmd.CombinedOutput()</span><br><span class="line"> fmt.Println(<span class="type">string</span>(output))</span><br><span class="line"></span><br><span class="line"> cmdName := <span class="string">&quot;ls&quot;</span></span><br><span class="line"> <span class="comment">// 未判断外部输入是否是预期命令</span></span><br><span class="line"> cmd := exec.Command(cmdName)</span><br><span class="line"> output, _ := cmd.CombinedOutput()</span><br><span class="line"> fmt.Println(<span class="type">string</span>(output))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkIllegal</span><span class="params">(cmdName <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> strings.Contains(cmdName, <span class="string">&quot;&amp;&quot;</span>) || strings.Contains(cmdName, <span class="string">&quot;|&quot;</span>) || strings.Contains(cmdName, <span class="string">&quot;;&quot;</span>) ||</span><br><span class="line">  strings.Contains(cmdName, <span class="string">&quot;$&quot;</span>) || strings.Contains(cmdName, <span class="string">&quot;&#x27;&quot;</span>) || strings.Contains(cmdName, <span class="string">&quot;`&quot;</span>) ||</span><br><span class="line">  strings.Contains(cmdName, <span class="string">&quot;(&quot;</span>) || strings.Contains(cmdName, <span class="string">&quot;)&quot;</span>) || strings.Contains(cmdName, <span class="string">&quot;\&quot;&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> userInputedVal := <span class="string">&quot;&amp;&amp; echo &#x27;hello&#x27;&quot;</span></span><br><span class="line"> cmdName := <span class="string">&quot;ping &quot;</span> + userInputedVal</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> checkIllegal(cmdName) &#123; <span class="comment">// 检查传给sh的命令是否有特殊字符</span></span><br><span class="line">  <span class="keyword">return</span> <span class="comment">// 存在特殊字符直接return</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> cmd := exec.Command(<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, cmdName)</span><br><span class="line"> output, _ := cmd.CombinedOutput()</span><br><span class="line"> fmt.Println(<span class="type">string</span>(output))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-通信安全"><a href="#1-4-通信安全" class="headerlink" title="1.4 通信安全"></a>1.4 通信安全</h3><h4 id="1-4-1【必须】网络通信采用TLS方式"><a href="#1-4-1【必须】网络通信采用TLS方式" class="headerlink" title="1.4.1【必须】网络通信采用TLS方式"></a>1.4.1【必须】网络通信采用TLS方式</h4><ul>
<li>明文传输的通信协议目前已被验证存在较大安全风险，被中间人劫持后可能导致许多安全风险，因此必须采用至少TLS的安全通信方式保证通信安全，例如gRPC&#x2F;Websocket都使用TLS1.3。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">  w.Header().Add(<span class="string">&quot;Strict-Transport-Security&quot;</span>, <span class="string">&quot;max-age=63072000; includeSubDomains&quot;</span>)</span><br><span class="line">  w.Write([]<span class="type">byte</span>(<span class="string">&quot;This is an example server.\n&quot;</span>))</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 服务器配置证书与私钥</span></span><br><span class="line"> log.Fatal(http.ListenAndServeTLS(<span class="string">&quot;:443&quot;</span>, <span class="string">&quot;yourCert.pem&quot;</span>, <span class="string">&quot;yourKey.pem&quot;</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-2【推荐】TLS启用证书验证"><a href="#1-4-2【推荐】TLS启用证书验证" class="headerlink" title="1.4.2【推荐】TLS启用证书验证"></a>1.4.2【推荐】TLS启用证书验证</h4><ul>
<li>TLS证书应当是有效的、未过期的，且配置正确的域名，生产环境的服务端应启用证书验证。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line"> <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doAuthReq</span><span class="params">(authReq *http.Request)</span></span> *http.Response &#123;</span><br><span class="line"> tr := &amp;http.Transport&#123;</span><br><span class="line">  TLSClientConfig: &amp;tls.Config&#123;InsecureSkipVerify: <span class="literal">true</span>&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line"> res, _ := client.Do(authReq)</span><br><span class="line"> <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line"> <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doAuthReq</span><span class="params">(authReq *http.Request)</span></span> *http.Response &#123;</span><br><span class="line"> tr := &amp;http.Transport&#123;</span><br><span class="line">  TLSClientConfig: &amp;tls.Config&#123;InsecureSkipVerify: <span class="literal">false</span>&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> client := &amp;http.Client&#123;Transport: tr&#125;</span><br><span class="line"> res, _ := client.Do(authReq)</span><br><span class="line"> <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-敏感数据保护"><a href="#1-5-敏感数据保护" class="headerlink" title="1.5 敏感数据保护"></a>1.5 敏感数据保护</h3><h4 id="1-5-1【必须】敏感信息访问"><a href="#1-5-1【必须】敏感信息访问" class="headerlink" title="1.5.1【必须】敏感信息访问"></a>1.5.1【必须】敏感信息访问</h4><ul>
<li>禁止将敏感信息硬编码在程序中，既可能会将敏感信息暴露给攻击者，也会增加代码管理和维护的难度</li>
<li>使用配置中心系统统一托管密钥等敏感信息</li>
</ul>
<h4 id="1-5-2【必须】敏感数据输出"><a href="#1-5-2【必须】敏感数据输出" class="headerlink" title="1.5.2【必须】敏感数据输出"></a>1.5.2【必须】敏感数据输出</h4><ul>
<li>只输出必要的最小数据集，避免多余字段暴露引起敏感信息泄露</li>
<li>不能在日志保存密码（包括明文密码和密文密码）、密钥和其它敏感信息</li>
<li>对于必须输出的敏感信息，必须进行合理脱敏展示</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">()</span></span> &#123;</span><br><span class="line"> http.HandleFunc(<span class="string">&quot;/register&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  r.ParseForm()</span><br><span class="line">  user := r.Form.Get(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">  pw := r.Form.Get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"></span><br><span class="line">  log.Printf(<span class="string">&quot;Registering new user %s with password %s.\n&quot;</span>, user, pw)</span><br><span class="line"> &#125;)</span><br><span class="line"> http.ListenAndServe(<span class="string">&quot;:80&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">serve1</span><span class="params">()</span></span> &#123;</span><br><span class="line"> http.HandleFunc(<span class="string">&quot;/register&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  r.ParseForm()</span><br><span class="line">  user := r.Form.Get(<span class="string">&quot;user&quot;</span>)</span><br><span class="line">  pw := r.Form.Get(<span class="string">&quot;password&quot;</span>)</span><br><span class="line"></span><br><span class="line">  log.Printf(<span class="string">&quot;Registering new user %s.\n&quot;</span>, user)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  use(pw)</span><br><span class="line"> &#125;)</span><br><span class="line"> http.ListenAndServe(<span class="string">&quot;:80&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>避免通过GET方法、代码注释、自动填充、缓存等方式泄露敏感信息</li>
</ul>
<h4 id="1-5-3【必须】敏感数据存储"><a href="#1-5-3【必须】敏感数据存储" class="headerlink" title="1.5.3【必须】敏感数据存储"></a>1.5.3【必须】敏感数据存储</h4><ul>
<li>敏感数据应使用SHA2、RSA等算法进行加密存储</li>
<li>敏感数据应使用独立的存储层，并在访问层开启访问控制</li>
<li>包含敏感信息的临时文件或缓存一旦不再需要应立刻删除</li>
</ul>
<h4 id="1-5-4【必须】异常处理和日志记录"><a href="#1-5-4【必须】异常处理和日志记录" class="headerlink" title="1.5.4【必须】异常处理和日志记录"></a>1.5.4【必须】异常处理和日志记录</h4><ul>
<li>应合理使用panic、recover、defer处理系统异常，避免出错信息输出到前端</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;Recovered in start()&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<ul>
<li>对外环境禁止开启debug模式，或将程序运行日志输出到前端</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">dlv --listen=:2345 --headless=<span class="literal">true</span> --api-version=2 debug test.go</span><br><span class="line">// good</span><br><span class="line">dlv debug test.go</span><br></pre></td></tr></table></figure>

<h3 id="1-6-加密解密"><a href="#1-6-加密解密" class="headerlink" title="1.6 加密解密"></a>1.6 加密解密</h3><h4 id="1-6-1【必须】不得硬编码密码-x2F-密钥"><a href="#1-6-1【必须】不得硬编码密码-x2F-密钥" class="headerlink" title="1.6.1【必须】不得硬编码密码&#x2F;密钥"></a>1.6.1【必须】不得硬编码密码&#x2F;密钥</h4><ul>
<li>在进行用户登陆，加解密算法等操作时，不得在代码里硬编码密钥或密码，可通过变换算法或者配置等方式设置密码或者密钥。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"> user     = <span class="string">&quot;dbuser&quot;</span></span><br><span class="line"> password = <span class="string">&quot;s3cretp4ssword&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">()</span></span> *sql.DB &#123;</span><br><span class="line"> connStr := fmt.Sprintf(<span class="string">&quot;postgres://%s:%s@localhost/pqgotest&quot;</span>, user, password)</span><br><span class="line"> db, err := sql.Open(<span class="string">&quot;postgres&quot;</span>, connStr)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"> commonkey = []<span class="type">byte</span>(<span class="string">&quot;0123456789abcdef&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AesEncrypt</span><span class="params">(plaintext <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line"> block, err := aes.NewCipher(commonkey)</span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-2【必须】密钥存储安全"><a href="#1-6-2【必须】密钥存储安全" class="headerlink" title="1.6.2【必须】密钥存储安全"></a>1.6.2【必须】密钥存储安全</h4><ul>
<li>在使用对称密码算法时，需要保护好加密密钥。当算法涉及敏感、业务数据时，可通过非对称算法协商加密密钥。其他较为不敏感的数据加密，可以通过变换算法等方式保护密钥。</li>
</ul>
<h4 id="1-6-3【推荐】不使用弱密码算法"><a href="#1-6-3【推荐】不使用弱密码算法" class="headerlink" title="1.6.3【推荐】不使用弱密码算法"></a>1.6.3【推荐】不使用弱密码算法</h4><ul>
<li>在使用加密算法时，不建议使用加密强度较弱的算法。</li>
</ul>
<h3 id="1-7-正则表达式"><a href="#1-7-正则表达式" class="headerlink" title="1.7 正则表达式"></a>1.7 正则表达式</h3><h4 id="1-7-1【推荐】使用regexp进行正则表达式匹配"><a href="#1-7-1【推荐】使用regexp进行正则表达式匹配" class="headerlink" title="1.7.1【推荐】使用regexp进行正则表达式匹配"></a>1.7.1【推荐】使用regexp进行正则表达式匹配</h4><ul>
<li>正则表达式编写不恰当可被用于DoS攻击，造成服务不可用，推荐使用regexp包进行正则表达式匹配。regexp保证了线性时间性能和优雅的失败：对解析器、编译器和执行引擎都进行了内存限制。但regexp不支持以下正则表达式特性，如业务依赖这些特性，则regexp不适合使用。<ul>
<li>回溯引用Backreferences</li>
<li>查看Lookaround</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line">matched, err := regexp.MatchString(<span class="string">`a.b`</span>, <span class="string">&quot;aaxbb&quot;</span>)</span><br><span class="line">fmt.Println(matched) <span class="comment">// true</span></span><br><span class="line">fmt.Println(err)     <span class="comment">// nil</span></span><br></pre></td></tr></table></figure>

<h1 id="后台类"><a href="#后台类" class="headerlink" title="后台类"></a>后台类</h1><h2 id="1-代码实现类-1"><a href="#1-代码实现类-1" class="headerlink" title="1 代码实现类"></a>1 代码实现类</h2><h3 id="1-1-输入校验"><a href="#1-1-输入校验" class="headerlink" title="1.1 输入校验"></a>1.1 输入校验</h3><h4 id="1-1-1【必须】按类型进行数据校验"><a href="#1-1-1【必须】按类型进行数据校验" class="headerlink" title="1.1.1【必须】按类型进行数据校验"></a>1.1.1【必须】按类型进行数据校验</h4><ul>
<li>所有外部输入的参数，应使用validator进行白名单校验，校验内容包括但不限于数据长度、数据范围、数据类型与格式，校验不通过的应当拒绝</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;github.com/go-playground/validator/v10&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> validate *validator.Validate</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateVariable</span><span class="params">()</span></span> &#123;</span><br><span class="line"> myEmail := <span class="string">&quot;abc@tencent.com&quot;</span></span><br><span class="line"> errs := validate.Var(myEmail, <span class="string">&quot;required,email&quot;</span>)</span><br><span class="line"> <span class="keyword">if</span> errs != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(errs)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">  <span class="comment">//停止执行</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 验证通过，继续执行</span></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> validate = validator.New()</span><br><span class="line"> validateVariable()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>无法通过白名单校验的应使用html.EscapeString、text&#x2F;template或bluemonday对&lt;, &gt;, &amp;, ‘,”等字符进行过滤或编码</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;text/template&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// TestHTMLEscapeString HTML特殊字符转义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">(inputValue <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"> escapedResult := template.HTMLEscapeString(inputValue)</span><br><span class="line"> <span class="keyword">return</span> escapedResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-SQL操作"><a href="#1-2-SQL操作" class="headerlink" title="1.2 SQL操作"></a>1.2 SQL操作</h3><h4 id="1-2-1【必须】SQL语句默认使用预编译并绑定变量"><a href="#1-2-1【必须】SQL语句默认使用预编译并绑定变量" class="headerlink" title="1.2.1【必须】SQL语句默认使用预编译并绑定变量"></a>1.2.1【必须】SQL语句默认使用预编译并绑定变量</h4><ul>
<li>使用database&#x2F;sql的prepare、Query或使用GORM等ORM执行SQL操作</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line"> _ <span class="string">&quot;github.com/jinzhu/gorm/dialects/sqlite&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line"> gorm.Model</span><br><span class="line"> Code  <span class="type">string</span></span><br><span class="line"> Price <span class="type">uint</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">var</span> product Product</span><br><span class="line">...</span><br><span class="line">db.First(&amp;product, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用参数化查询，禁止拼接SQL语句，另外对于传入参数用于order by或表名的需要通过校验</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;database/sql&quot;</span></span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(db *sql.DB, req *http.Request)</span></span> &#123;</span><br><span class="line"> q := fmt.Sprintf(<span class="string">&quot;SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=&#x27;%s&#x27; ORDER BY PRICE&quot;</span>,</span><br><span class="line">  req.URL.Query()[<span class="string">&quot;category&quot;</span>])</span><br><span class="line"> db.Query(q)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlerGood</span><span class="params">(db *sql.DB, req *http.Request)</span></span> &#123;</span><br><span class="line"> <span class="comment">// 使用?占位符</span></span><br><span class="line"> q := <span class="string">&quot;SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=&#x27;?&#x27; ORDER BY PRICE&quot;</span></span><br><span class="line"> db.Query(q, req.URL.Query()[<span class="string">&quot;category&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-网络请求"><a href="#1-3-网络请求" class="headerlink" title="1.3 网络请求"></a>1.3 网络请求</h3><h4 id="1-3-1【必须】资源请求过滤验证"><a href="#1-3-1【必须】资源请求过滤验证" class="headerlink" title="1.3.1【必须】资源请求过滤验证"></a>1.3.1【必须】资源请求过滤验证</h4><ul>
<li><p>使用”net&#x2F;http”下的方法http.Get(url)、http.Post(url, contentType, body)、http.Head(url)、http.PostForm(url, data)、http.Do(req)时，如变量值外部可控（指从参数中动态获取），应对请求目标进行严格的安全校验。</p>
</li>
<li><p>如请求资源域名归属固定的范围，如只允许a.qq.com和b.qq.com，应做白名单限制。如不适用白名单，则推荐的校验逻辑步骤是：</p>
<ul>
<li><p>第 1 步、只允许HTTP或HTTPS协议</p>
</li>
<li><p>第 2 步、解析目标URL，获取其HOST</p>
</li>
<li><p>第 3 步、解析HOST，获取HOST指向的IP地址转换成Long型</p>
</li>
<li><p>第 4 步、检查IP地址是否为内网IP，网段有：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 以RFC定义的专有网络为例，如有自定义私有网段亦应加入禁止访问列表。</span><br><span class="line">10.0.0.0/8</span><br><span class="line">172.16.0.0/12</span><br><span class="line">192.168.0.0/16</span><br><span class="line">127.0.0.0/8</span><br></pre></td></tr></table></figure>
</li>
<li><p>第 5 步、请求URL</p>
</li>
<li><p>第 6 步、如有跳转，跳转后执行1，否则绑定经校验的ip和域名，对URL发起请求</p>
</li>
</ul>
</li>
<li><p>官方库encoding&#x2F;xml不支持外部实体引用，使用该库可避免xxe漏洞</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;encoding/xml&quot;</span></span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">  XMLName  xml.Name <span class="string">`xml:&quot;person&quot;`</span></span><br><span class="line">  Id       <span class="type">int</span>      <span class="string">`xml:&quot;id,attr&quot;`</span></span><br><span class="line">  UserName <span class="type">string</span>   <span class="string">`xml:&quot;name&gt;first&quot;`</span></span><br><span class="line">  Comment  <span class="type">string</span>   <span class="string">`xml:&quot;,comment&quot;`</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> v := &amp;Person&#123;Id: <span class="number">13</span>, UserName: <span class="string">&quot;John&quot;</span>&#125;</span><br><span class="line"> v.Comment = <span class="string">&quot; Need more details. &quot;</span></span><br><span class="line"></span><br><span class="line"> enc := xml.NewEncoder(os.Stdout)</span><br><span class="line"> enc.Indent(<span class="string">&quot;  &quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line"> <span class="keyword">if</span> err := enc.Encode(v); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">&quot;error: %v\n&quot;</span>, err)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-服务器端渲染"><a href="#1-4-服务器端渲染" class="headerlink" title="1.4 服务器端渲染"></a>1.4 服务器端渲染</h3><h4 id="1-4-1【必须】模板渲染过滤验证"><a href="#1-4-1【必须】模板渲染过滤验证" class="headerlink" title="1.4.1【必须】模板渲染过滤验证"></a>1.4.1【必须】模板渲染过滤验证</h4><ul>
<li>使用text&#x2F;template或者html&#x2F;template渲染模板时禁止将外部输入参数引入模板，或仅允许引入白名单内字符。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"> r.ParseForm()</span><br><span class="line"> x := r.Form.Get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> tmpl = <span class="string">`&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;form action=&quot;/&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="string">        First name:&lt;br&gt;</span></span><br><span class="line"><span class="string">    &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;/form&gt;&lt;p&gt;`</span> + x + <span class="string">` &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;`</span></span><br><span class="line"></span><br><span class="line"> t := template.New(<span class="string">&quot;main&quot;</span>)</span><br><span class="line"> t, _ = t.Parse(tmpl)</span><br><span class="line"> t.Execute(w, <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"> <span class="string">&quot;github.com/go-playground/validator/v10&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> validate *validator.Validate</span><br><span class="line">validate = validator.New()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateVariable</span><span class="params">(val)</span></span> &#123;</span><br><span class="line"> errs := validate.Var(val, <span class="string">&quot;gte=1,lte=100&quot;</span>) <span class="comment">// 限制必须是1-100的正整数</span></span><br><span class="line"> <span class="keyword">if</span> errs != <span class="literal">nil</span> &#123;</span><br><span class="line">  fmt.Println(errs)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"> r.ParseForm()</span><br><span class="line"> x := r.Form.Get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> validateVariable(x) &#123;</span><br><span class="line">  <span class="keyword">var</span> tmpl = <span class="string">`&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;</span></span><br><span class="line"><span class="string">            &lt;form action=&quot;/&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="string">            First name:&lt;br&gt;</span></span><br><span class="line"><span class="string">            &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;/form&gt;&lt;p&gt;`</span> + x + <span class="string">` &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;`</span></span><br><span class="line">  t := template.New(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">  t, _ = t.Parse(tmpl)</span><br><span class="line">  t.Execute(w, <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-Web跨域"><a href="#1-5-Web跨域" class="headerlink" title="1.5 Web跨域"></a>1.5 Web跨域</h3><h4 id="1-5-1【必须】跨域资源共享CORS限制请求来源"><a href="#1-5-1【必须】跨域资源共享CORS限制请求来源" class="headerlink" title="1.5.1【必须】跨域资源共享CORS限制请求来源"></a>1.5.1【必须】跨域资源共享CORS限制请求来源</h4><ul>
<li>CORS请求保护不当可导致敏感信息泄漏，因此应当严格设置Access-Control-Allow-Origin使用同源策略进行保护。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line">c := cors.New(cors.Options&#123;</span><br><span class="line"> AllowedOrigins:   []<span class="type">string</span>&#123;<span class="string">&quot;http://qq.com&quot;</span>, <span class="string">&quot;https://qq.com&quot;</span>&#125;,</span><br><span class="line"> AllowCredentials: <span class="literal">true</span>,</span><br><span class="line"> Debug:            <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入中间件</span></span><br><span class="line">handler = c.Handler(handler)</span><br></pre></td></tr></table></figure>

<h3 id="1-6-响应输出"><a href="#1-6-响应输出" class="headerlink" title="1.6 响应输出"></a>1.6 响应输出</h3><h4 id="1-6-1-【必须】设置正确的HTTP响应包类型"><a href="#1-6-1-【必须】设置正确的HTTP响应包类型" class="headerlink" title="1.6.1 【必须】设置正确的HTTP响应包类型"></a>1.6.1 【必须】设置正确的HTTP响应包类型</h4><ul>
<li>响应头Content-Type与实际响应内容，应保持一致。如：API响应数据类型是json，则响应头使用application&#x2F;json；若为xml，则设置为text&#x2F;xml。</li>
</ul>
<h4 id="1-6-2-【必须】添加安全响应头"><a href="#1-6-2-【必须】添加安全响应头" class="headerlink" title="1.6.2 【必须】添加安全响应头"></a>1.6.2 【必须】添加安全响应头</h4><ul>
<li>所有接口、页面，添加响应头 X-Content-Type-Options: nosniff。</li>
<li>所有接口、页面，添加响应头X-Frame-Options。按需合理设置其允许范围，包括：DENY、SAMEORIGIN、ALLOW-FROM origin。用法参考：MDN文档</li>
</ul>
<h4 id="1-6-3【必须】外部输入拼接到HTTP响应头中需进行过滤"><a href="#1-6-3【必须】外部输入拼接到HTTP响应头中需进行过滤" class="headerlink" title="1.6.3【必须】外部输入拼接到HTTP响应头中需进行过滤"></a>1.6.3【必须】外部输入拼接到HTTP响应头中需进行过滤</h4><ul>
<li>应尽量避免外部可控参数拼接到HTTP响应头中，如业务需要则需要过滤掉\r、\n等换行符，或者拒绝携带换行符号的外部输入。</li>
</ul>
<h4 id="1-6-4【必须】外部输入拼接到response页面前进行编码处理"><a href="#1-6-4【必须】外部输入拼接到response页面前进行编码处理" class="headerlink" title="1.6.4【必须】外部输入拼接到response页面前进行编码处理"></a>1.6.4【必须】外部输入拼接到response页面前进行编码处理</h4><ul>
<li>直出html页面或使用模板生成html页面的，推荐使用text&#x2F;template自动编码，或者使用html.EscapeString或text&#x2F;template对&lt;, &gt;, &amp;, ‘,”等字符进行编码。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;html/template&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">outtemplate</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"> param1 := r.URL.Query().Get(<span class="string">&quot;param1&quot;</span>)</span><br><span class="line"> tmpl := template.New(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"> tmpl, _ = tmpl.Parse(<span class="string">`&#123;&#123;define &quot;T&quot;&#125;&#125;&#123;&#123;.&#125;&#125;&#123;&#123;end&#125;&#125;`</span>)</span><br><span class="line"> tmpl.ExecuteTemplate(w, <span class="string">&quot;T&quot;</span>, param1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-会话管理"><a href="#1-7-会话管理" class="headerlink" title="1.7 会话管理"></a>1.7 会话管理</h3><h4 id="1-7-1【必须】安全维护session信息"><a href="#1-7-1【必须】安全维护session信息" class="headerlink" title="1.7.1【必须】安全维护session信息"></a>1.7.1【必须】安全维护session信息</h4><ul>
<li>用户登录时应重新生成session，退出登录后应清理session。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;github.com/gorilla/handlers&quot;</span></span><br><span class="line"> <span class="string">&quot;github.com/gorilla/mux&quot;</span></span><br><span class="line"> <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建cookie</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setToken</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"> expireToken := time.Now().Add(time.Minute * <span class="number">30</span>).Unix()</span><br><span class="line"> expireCookie := time.Now().Add(time.Minute * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"> cookie := http.Cookie&#123;</span><br><span class="line">  Name:     <span class="string">&quot;Auth&quot;</span>,</span><br><span class="line">  Value:    signedToken,</span><br><span class="line">  Expires:  expireCookie, <span class="comment">// 过期失效</span></span><br><span class="line">  HttpOnly: <span class="literal">true</span>,</span><br><span class="line">  Path:     <span class="string">&quot;/&quot;</span>,</span><br><span class="line">  Domain:   <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">  Secure:   <span class="literal">true</span>,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> http.SetCookie(res, &amp;cookie)</span><br><span class="line"> http.Redirect(res, req, <span class="string">&quot;/profile&quot;</span>, <span class="number">307</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除cookie</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logout</span><span class="params">(res http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"> deleteCookie := http.Cookie&#123;</span><br><span class="line">  Name:    <span class="string">&quot;Auth&quot;</span>,</span><br><span class="line">  Value:   <span class="string">&quot;none&quot;</span>,</span><br><span class="line">  Expires: time.Now(),</span><br><span class="line"> &#125;</span><br><span class="line"> http.SetCookie(res, &amp;deleteCookie)</span><br><span class="line"> <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-7-2【必须】CSRF防护"><a href="#1-7-2【必须】CSRF防护" class="headerlink" title="1.7.2【必须】CSRF防护"></a>1.7.2【必须】CSRF防护</h4><ul>
<li>涉及系统敏感操作或可读取敏感信息的接口应校验Referer或添加csrf_token。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;github.com/gorilla/csrf&quot;</span></span><br><span class="line"> <span class="string">&quot;github.com/gorilla/mux&quot;</span></span><br><span class="line"> <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> r := mux.NewRouter()</span><br><span class="line"> r.HandleFunc(<span class="string">&quot;/signup&quot;</span>, ShowSignupForm)</span><br><span class="line"> r.HandleFunc(<span class="string">&quot;/signup/post&quot;</span>, SubmitSignupForm)</span><br><span class="line"> <span class="comment">// 使用csrf_token验证</span></span><br><span class="line"> http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>,</span><br><span class="line">  csrf.Protect([]<span class="type">byte</span>(<span class="string">&quot;32-byte-long-auth-key&quot;</span>))(r))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-8-访问控制"><a href="#1-8-访问控制" class="headerlink" title="1.8 访问控制"></a>1.8 访问控制</h3><h4 id="1-8-1【必须】默认鉴权"><a href="#1-8-1【必须】默认鉴权" class="headerlink" title="1.8.1【必须】默认鉴权"></a>1.8.1【必须】默认鉴权</h4><ul>
<li><p>除非资源完全可对外开放，否则系统默认进行身份认证，使用白名单的方式放开不需要认证的接口或页面。</p>
</li>
<li><p>根据资源的机密程度和用户角色，以最小权限原则，设置不同级别的权限，如完全公开、登录可读、登录可写、特定用户可读、特定用户可写等</p>
</li>
<li><p>涉及用户自身相关的数据的读写必须验证登录态用户身份及其权限，避免越权操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 伪代码</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id<span class="operator">=</span>:id <span class="keyword">and</span> userid<span class="operator">=</span>session.userid</span><br></pre></td></tr></table></figure>
</li>
<li><p>没有独立账号体系的外网服务使用QQ或微信登录，内网服务使用统一登录服务登录，其他使用账号密码登录的服务需要增加验证码等二次验证</p>
</li>
</ul>
<h3 id="1-9-并发保护"><a href="#1-9-并发保护" class="headerlink" title="1.9 并发保护"></a>1.9 并发保护</h3><h4 id="1-9-1【必须】禁止在闭包中直接调用循环变量"><a href="#1-9-1【必须】禁止在闭包中直接调用循环变量" class="headerlink" title="1.9.1【必须】禁止在闭包中直接调用循环变量"></a>1.9.1【必须】禁止在闭包中直接调用循环变量</h4><ul>
<li>在循环中启动协程，当协程中使用到了循环的索引值，由于多个协程同时使用同一个变量会产生数据竞争，造成执行结果异常。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line"> <span class="keyword">var</span> group sync.WaitGroup</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">  group.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> group.Done()</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%-2d&quot;</span>, i) <span class="comment">// 这里打印的i不是所期望的</span></span><br><span class="line">  &#125;()</span><br><span class="line"> &#125;</span><br><span class="line"> group.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line"> <span class="keyword">var</span> group sync.WaitGroup</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">  group.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">     fmt.Println(<span class="string">&quot;Recovered in start()&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    group.Done()</span><br><span class="line">   &#125;()</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%-2d&quot;</span>, j) <span class="comment">// 闭包内部使用局部变量</span></span><br><span class="line">  &#125;(i) <span class="comment">// 把循环变量显式地传给协程</span></span><br><span class="line"> &#125;</span><br><span class="line"> group.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-9-2【必须】禁止并发写map"><a href="#1-9-2【必须】禁止并发写map" class="headerlink" title="1.9.2【必须】禁止并发写map"></a>1.9.2【必须】禁止并发写map</h4><ul>
<li>并发写map容易造成程序崩溃并异常退出，建议加锁保护<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line"> <span class="comment">// 并发读写</span></span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">   _ = m[<span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">   m[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;()</span><br><span class="line"> <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="1-9-3【必须】确保并发安全"><a href="#1-9-3【必须】确保并发安全" class="headerlink" title="1.9.3【必须】确保并发安全"></a>1.9.3【必须】确保并发安全</h4><p>敏感操作如果未作并发安全限制，可导致数据读写异常，造成业务逻辑限制被绕过。可通过同步锁或者原子操作进行防护。</p>
<p>通过同步锁共享内存</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(lock *sync.Mutex)</span></span> &#123;</span><br><span class="line"> lock.Lock() <span class="comment">// 加写锁</span></span><br><span class="line"> count++</span><br><span class="line"> fmt.Println(count)</span><br><span class="line"> lock.Unlock() <span class="comment">// 解写锁，任何一个Lock()或RLock()均需要保证对应有Unlock()或RUnlock()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> lock := &amp;sync.Mutex&#123;&#125;</span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  <span class="keyword">go</span> Count(lock) <span class="comment">// 传递指针是为了防止函数内的锁和调用锁不一致</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span> &#123;</span><br><span class="line">  lock.Lock()</span><br><span class="line">  c := count</span><br><span class="line">  lock.Unlock()</span><br><span class="line">  runtime.Gosched() <span class="comment">// 交出时间片给协程</span></span><br><span class="line">  <span class="keyword">if</span> c &gt; <span class="number">10</span> &#123;</span><br><span class="line">   <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用sync&#x2F;atomic执行原子操作</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"> <span class="string">&quot;sync&quot;</span></span><br><span class="line"> <span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="keyword">type</span> Map <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line"> <span class="keyword">var</span> m atomic.Value</span><br><span class="line"> m.Store(<span class="built_in">make</span>(Map))</span><br><span class="line"> <span class="keyword">var</span> mu sync.Mutex <span class="comment">// used only by writers</span></span><br><span class="line"> read := <span class="function"><span class="keyword">func</span><span class="params">(key <span class="type">string</span>)</span></span> (val <span class="type">string</span>) &#123;</span><br><span class="line">  m1 := m.Load().(Map)</span><br><span class="line">  <span class="keyword">return</span> m1[key]</span><br><span class="line"> &#125;</span><br><span class="line"> insert := <span class="function"><span class="keyword">func</span><span class="params">(key, val <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  mu.Lock() <span class="comment">// 与潜在写入同步</span></span><br><span class="line">  <span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">  m1 := m.Load().(Map) <span class="comment">// 导入struct当前数据</span></span><br><span class="line">  m2 := <span class="built_in">make</span>(Map)      <span class="comment">// 创建新值</span></span><br><span class="line">  <span class="keyword">for</span> k, v := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">   m2[k] = v</span><br><span class="line">  &#125;</span><br><span class="line">  m2[key] = val</span><br><span class="line">  m.Store(m2) <span class="comment">// 用新的替代当前对象</span></span><br><span class="line"> &#125;</span><br><span class="line"> _, _ = read, insert</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/Golang/go%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Golang/go%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">go中的泛型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-23 14:16:56" itemprop="dateCreated datePublished" datetime="2023-02-23T14:16:56+08:00">2023-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-29 16:58:05" itemprop="dateModified" datetime="2023-05-29T16:58:05+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000041634906">https://segmentfault.com/a/1190000041634906</a></p>
<h2 id="了解概念"><a href="#了解概念" class="headerlink" title="了解概念"></a>了解概念</h2><ul>
<li>类型形参（Type parameter）</li>
<li>类型实参（Type argument）</li>
<li>类型形参列表（Type parameter list）</li>
<li>类型约束（Type constraint）</li>
<li>实例化（Instantiations）</li>
<li>泛型类型（Generic type）</li>
<li>泛型接收器（Generic receiver）</li>
<li>泛型函数（Generic function）</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MySlice[T <span class="type">int</span> | <span class="type">string</span>] []T</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyMap[K <span class="type">string</span> | <span class="type">int</span>, V <span class="type">int</span> | <span class="type">float32</span> | <span class="type">float64</span>] <span class="keyword">map</span>[K]V</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyStruct[T <span class="type">int</span> | <span class="type">string</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Data T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPrintData[T <span class="type">int</span> | <span class="type">float32</span> | <span class="type">string</span>] <span class="keyword">interface</span> &#123;</span><br><span class="line">    Print(data T)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyChan[T <span class="type">int</span> | <span class="type">string</span>] <span class="keyword">chan</span> T</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型形参可以互相套用</span></span><br><span class="line"><span class="keyword">type</span> WowStruct[T <span class="type">int</span> | <span class="type">float32</span>, S []T] <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data     S</span><br><span class="line">    MaxValue T</span><br><span class="line">    MinValue T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="//img.to2b.cn/blog/lujinkai/1672892619535.png"></p>
<p><strong>任何泛型类型都必须传入类型实参实例化才可以使用：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := MyMap[string, int]&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="//img.to2b.cn/blog/lujinkai/1672899644005.png"></p>
<p><strong>注意：匿名结构体不支持泛型</strong></p>
<h3 id="几种常见错误"><a href="#几种常见错误" class="headerlink" title="几种常见错误"></a>几种常见错误</h3><p>1、定义泛型类型的时候，<strong>基础类型不能只有类型形参</strong>。如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CommonType[T <span class="type">int</span>|<span class="type">string</span>|<span class="type">float32</span>] T   <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>2、当类型约束的一些写法会被编译器误认为是表达式时会报错。如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NewType[T *<span class="type">int</span>] []T    <span class="comment">// 错误。T *int会被编译器误认为是表达式 T乘以int，而不是int指针</span></span><br><span class="line"><span class="keyword">type</span> NewType2[T *<span class="type">int</span>|*<span class="type">float64</span>] []T  <span class="comment">// 错误。和上面一样，这里不光*被会认为是乘号，| 还会被认为是按位或操作</span></span><br></pre></td></tr></table></figure>

<p>为了避免这种误解，解决办法就是给类型约束包上 <code>interface&#123;&#125;</code> 或加上逗号消除歧义</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NewType[T <span class="keyword">interface</span>&#123;*<span class="type">int</span>&#125;] []T</span><br><span class="line"><span class="keyword">type</span> NewType2[T <span class="keyword">interface</span>&#123;*<span class="type">int</span>|*<span class="type">float64</span>&#125;] []T</span><br></pre></td></tr></table></figure>

<h2 id="泛型-receiver"><a href="#泛型-receiver" class="headerlink" title="泛型 receiver"></a>泛型 receiver</h2><p>单纯的泛型类型实际上对开发来说用处并不大，但泛型类型和泛型 receiver 相结合，就有了非常大的实用性。</p>
<p>我们知道，定义了新的普通类型之后可以给类型添加方法。那么可以给泛型类型添加方法吗？答案自然是可以的，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MySlice[T <span class="type">int</span> | <span class="type">float32</span>] []T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s MySlice[T])</span></span> Sum() T &#123;</span><br><span class="line">    <span class="keyword">var</span> sum T</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> s &#123;</span><br><span class="line">        sum += value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">var</span> s MySlice[<span class="type">int</span>] = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Println(s.Sum()) <span class="comment">// 输出：10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 MySlice[<span class="type">float32</span>] = []<span class="type">float32</span>&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;</span><br><span class="line">fmt.Println(s2.Sum()) <span class="comment">// 输出：10.0</span></span><br></pre></td></tr></table></figure>

<h3 id="动态判断变量类型"><a href="#动态判断变量类型" class="headerlink" title="动态判断变量类型"></a>动态判断变量类型</h3><p>使用接口的时候经常会用到<strong>类型断言</strong>或 <strong><code>type swith</code></strong> 来确定接口具体的类型，然后对不同类型做出不同的处理，如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">interface</span>&#123;&#125; = <span class="number">123</span></span><br><span class="line">i.(<span class="type">int</span>) <span class="comment">// 类型断言</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type switch</span></span><br><span class="line"><span class="keyword">switch</span> i.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，对于 <code>valut T</code> 这样通过类型形参定义的变量，不能使用<strong>类型断言</strong>或 <strong><code>type swith</code></strong> 判断具体类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue[T])</span></span> Put(value T) &#123;</span><br><span class="line">    value.(<span class="type">int</span>) <span class="comment">// 错误。泛型类型定义的变量不能使用类型断言</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误。不允许使用type switch 来判断 value 的具体类型</span></span><br><span class="line">    <span class="keyword">switch</span> value.(<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过反射机制达到目的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver Queue[T])</span></span> Put(value T) &#123;</span><br><span class="line">    <span class="comment">// Printf() 可输出变量value的类型(底层就是通过反射实现的)</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T&quot;</span>, value)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射可以动态获得变量value的类型从而分情况处理</span></span><br><span class="line">    v := reflect.ValueOf(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> v.Kind() &#123;</span><br><span class="line">    <span class="keyword">case</span> reflect.Int:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">case</span> reflect.String:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这看起来达到了我们的目的，可是当你写出上面这样的代码时候就出现了一个问题：</p>
<blockquote>
<p>你为了避免使用反射而选择了泛型，结果到头来又为了一些功能在在泛型中使用反射</p>
</blockquote>
<p>当出现这种情况的时候你可能需要重新思考一下，自己的需求是不是真的需要用泛型（毕竟泛型机制本身就很复杂了，再加上反射的复杂度，增加的复杂度并不一定值得）</p>
<h2 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h2><p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span>[<span class="title">T</span> <span class="title">int</span> | <span class="title">float32</span> | <span class="title">float64</span>]<span class="params">(a T, b T)</span></span> T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Add[<span class="type">int</span>](<span class="number">1</span>,<span class="number">2</span>)     <span class="comment">// 传入类型实参int，计算结果为 3</span></span><br><span class="line">Add[<span class="type">float32</span>](<span class="number">1.0</span>, <span class="number">2.0</span>)   <span class="comment">// 传入类型实参float32, 计算结果为 3.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Go还支持类型实参的自动推导</span></span><br><span class="line">Add(<span class="number">1</span>, <span class="number">2</span>)     <span class="comment">// 1，2是int类型，编译请自动推导出类型实参T是int</span></span><br><span class="line">Add(<span class="number">1.0</span>, <span class="number">2.0</span>)   <span class="comment">// 1.0, 2.0 是浮点，编译请自动推导出类型实参T是float32</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>匿名函数不支持泛型</li>
<li>虽然函数支持泛型，但是方法不支持泛型</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不支持泛型方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver A)</span></span> Add[T <span class="type">int</span> | <span class="type">float32</span> | <span class="type">float64</span>](a T, b T) T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要想在方法中使用泛型的话，可以通过 receiver 间接实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A[T <span class="type">int</span> | <span class="type">float32</span> | <span class="type">float64</span>] <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法可以使用类型定义中的形参 T</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(receiver A[T])</span></span> Add(a T, b T) T &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：</span></span><br><span class="line"><span class="keyword">var</span> a A[<span class="type">int</span>]</span><br><span class="line">a.Add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aa A[<span class="type">float32</span>]</span><br><span class="line">aa.Add(<span class="number">1.0</span>, <span class="number">2.0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="接口更加复杂"><a href="#接口更加复杂" class="headerlink" title="接口更加复杂"></a>接口更加复杂</h2><p>有时候使用泛型编程时，我们会书写长长的类型约束，如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个可以容纳所有int,uint以及浮点类型的泛型切片</span></span><br><span class="line"><span class="keyword">type</span> Slice[T <span class="type">int</span> | <span class="type">int8</span> | <span class="type">int16</span> | <span class="type">int32</span> | <span class="type">int64</span> | <span class="type">uint</span> | <span class="type">uint8</span> | <span class="type">uint16</span> | <span class="type">uint32</span> | <span class="type">uint64</span> | <span class="type">float32</span> | <span class="type">float64</span>] []T</span><br></pre></td></tr></table></figure>

<p>理所当然，这种写法是我们无法忍受也难以维护的，而 Go 支持将类型约束单独拿出来定义到接口中，从而让代码更容易维护：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntUintFloat <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">int</span> | <span class="type">int8</span> | <span class="type">int16</span> | <span class="type">int32</span> | <span class="type">int64</span> | <span class="type">uint</span> | <span class="type">uint8</span> | <span class="type">uint16</span> | <span class="type">uint32</span> | <span class="type">uint64</span> | <span class="type">float32</span> | <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T IntUintFloat] []T</span><br></pre></td></tr></table></figure>

<p>这段代码把类型约束给单独拿出来，写入了接口类型 <code>IntUintFloat</code> 当中。需要指定类型约束的时候直接使用接口 <code>IntUintFloat</code> 即可。</p>
<p>不过这样的代码依旧不好维护，而接口和接口、接口和普通类型之间也是可以通过 <code>|</code> 进行组合：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Int <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">int</span> | <span class="type">int8</span> | <span class="type">int16</span> | <span class="type">int32</span> | <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">uint</span> | <span class="type">uint8</span> | <span class="type">uint16</span> | <span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">float32</span> | <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T Int | Uint | Float] []T   <span class="comment">// 使用 &#x27;|&#x27; 将多个接口类型组合</span></span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceElement <span class="keyword">interface</span> &#123;</span><br><span class="line">    Int | Uint | Float | <span class="type">string</span>   <span class="comment">// 组合了三个接口类型并额外增加了一个 string 类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T SliceElement] []T</span><br></pre></td></tr></table></figure>

<h3 id="指定底层类型"><a href="#指定底层类型" class="headerlink" title="~ 指定底层类型"></a><code>~</code> 指定底层类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 Slice[<span class="type">int</span>]   <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> s2 Slice[MyInt]  <span class="comment">// ✗ 错误。MyInt类型底层类型是int但并不是int类型，不符合 Slice[T] 的类型约束</span></span><br></pre></td></tr></table></figure>

<p>这里发生错误的原因是，泛型类型 <code>Slice[T]</code> 允许的是 <code>int</code> 作为类型实参，而不是 <code>MyInt</code> （虽然 <code>MyInt</code> 类型底层类型是 <code>int</code> ，但它依旧不是 <code>int</code> 类型）。</p>
<p>为了从根本上解决这个问题，Go 新增了一个符号 <code>~</code> ，在类型约束中使用类似 <code>~int</code> 这种写法的话，就代表着不光是 <code>int</code> ，所有以 <code>int</code> 为底层类型的类型也都可用于实例化。</p>
<p>使用 <code>~</code> 对代码进行改写之后如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Int <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">float32</span> | ~<span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Slice[T Int | Uint | Float] []T</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s Slice[<span class="type">int</span>]   <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> s2 Slice[MyInt]   <span class="comment">// MyInt底层类型是int，所以可以用于实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyMyInt MyInt</span><br><span class="line"><span class="keyword">var</span> s3 Slice[MyMyInt]   <span class="comment">// 正确。MyMyInt 虽然基于 MyInt ，但底层类型也是int，所以也能用于实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat32 <span class="type">float32</span>  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> s4 Slice[MyFloat32]</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong>使用 <code>~</code> 时有一定的限制：</p>
<ul>
<li><code>~</code>后面的类型不能为接口</li>
<li><code>~</code>后面的类型必须为基本类型</li>
</ul>
<h3 id="从方法集（Method-set）到类型集（Type-set）"><a href="#从方法集（Method-set）到类型集（Type-set）" class="headerlink" title="从方法集（Method set）到类型集（Type set）"></a>从方法集（Method set）到类型集（Type set）</h3><p>上面的例子中，我们学习到了一种接口的全新写法，而这种写法在 Go1.18 之前是不存在的。这意味着 Go 语言中 <code>接口(interface)</code> 这个概念发生了非常大的变化。</p>
<p>在 Go1.18 之前，Go 官方对 接口（interface）的定义是：接口是一个方法集（method set）。</p>
<p>从 Go1.18 开始，接口的定义正式更改为了 类型集(Type set)。</p>
<h4 id="接口实现（implement）定义的变化"><a href="#接口实现（implement）定义的变化" class="headerlink" title="接口实现（implement）定义的变化"></a>接口实现（implement）定义的变化</h4><p>既然接口定义发生了变化，那么从 Go1.18 开始 接口实现（implement） 的定义自然也发生了变化。</p>
<p>当满足以下条件时，我们可以说 类型 <code>T</code> 实现了接口 <code>I</code> ：</p>
<ul>
<li><code>T</code> 不是接口时：类型 <code>T</code> 是接口 <code>I</code> 代表的类型集中的一个成员</li>
<li><code>T</code> 是接口时： <code>T</code> 接口代表的类型集是 <code>I</code> 代表的类型集的子集</li>
</ul>
<h4 id="类型的交集"><a href="#类型的交集" class="headerlink" title="类型的交集"></a>类型的交集</h4><p>如果一个接口有多个类型的定义，取它们之间的 <strong>交集</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AllInt <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span> | ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">interface</span> &#123; <span class="comment">// 接口A代表的类型集是 AllInt 和 Uint 的交集</span></span><br><span class="line">    AllInt</span><br><span class="line">    Uint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">interface</span> &#123; <span class="comment">// 接口B代表的类型集是 AllInt 和 ~int 的交集</span></span><br><span class="line">    AllInt</span><br><span class="line">    ~<span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子中：</p>
<ul>
<li>接口<code>A</code>代表的是<code>AllInt</code>与<code>Uint</code>的<strong>交集</strong>，即：<code>~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64</code></li>
<li>接口<code>B</code>代表的是<code>AllInt</code>与<code>~int</code>的交集，即：<code>~int</code></li>
</ul>
<h4 id="interface-和-any"><a href="#interface-和-any" class="headerlink" title="interface{} 和 any"></a><code>interface&#123;&#125;</code> 和 <code>any</code></h4><p>Go1.18 开始接口的定义发生了改变，所以 interface{} 的定义也发生了一些变更：</p>
<blockquote>
<p>空接口代表了所有类型的集合</p>
</blockquote>
<p>所以，对于 Go1.18 之后的空接口应该这样理解：</p>
<ol>
<li><p>虽然空接口内没有写入任何的类型，但它代表的是所有类型的集合，而非一个 空集</p>
</li>
<li><p>类型约束中指定 空接口 的意思是指定一个包含所有类型的集合，并不是类型约束限制了只能使用 空接口 来做类型形参</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口代表所有类型的集合。写入类型约束意味着所有类型都可拿来做类型实参</span></span><br><span class="line"><span class="keyword">type</span> Slice[T <span class="keyword">interface</span>&#123;&#125;] []T</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 Slice[<span class="type">int</span>]    <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> s2 Slice[<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>]  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> s3 Slice[<span class="keyword">chan</span> <span class="type">int</span>]  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> s4 Slice[<span class="keyword">interface</span>&#123;&#125;]  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>因为空接口是一个包含了所有类型的类型集，所以我们经常会用到它。于是，Go1.18 开始提供了一个和空接口 <code>interface&#123;&#125;</code> 等价的新关键词 <code>any</code> ，用来使代码更简单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Slice[T any] []T <span class="comment">// 代码等价于 type Slice[T interface&#123;&#125;] []T</span></span><br></pre></td></tr></table></figure>

<h4 id="comparable（可比较）和-可排序（ordered）"><a href="#comparable（可比较）和-可排序（ordered）" class="headerlink" title="comparable（可比较）和 可排序（ordered）"></a>comparable（可比较）和 可排序（ordered）</h4><p>对于一些数据类型，我们需要在类型约束中限制只接受能 <code>!=</code> 和<code>==</code>对比的类型，如 <code>map</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误。因为 map 中键的类型必须是可进行 != 和 == 比较的类型</span></span><br><span class="line"><span class="keyword">type</span> MyMap[K any, V any] <span class="keyword">map</span>[K]V</span><br></pre></td></tr></table></figure>

<p>所以 Go 直接内置了一个叫 <code>comparable</code> 的接口，它代表了所有可用 <code>!=</code> 以及 <code>==</code> 对比的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyMap[KEY comparable, VALUE any] <span class="keyword">map</span>[KEY]VALUE  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>注意：可比较指的是可以执行<code>!=</code> 和 <code>==</code> 操作，并没有确保这个类型可以执行大小比较（<code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code>）</p>
<p>而可进行大小比较的类型被称为 <code>Orderd</code> 。目前 Go 并没有像 <code>comparable</code> 这样直接内置对应的关键词，所以想要的话需要自己来定义相关接口，比如我们可以参考<code>golang.org/x/exp/constraints</code> 如何定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ordered 代表所有可比大小排序的类型</span></span><br><span class="line"><span class="keyword">type</span> Ordered <span class="keyword">interface</span> &#123;</span><br><span class="line">    Integer | Float | ~<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Integer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Signed | Unsigned</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Signed <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | ~<span class="type">int8</span> | ~<span class="type">int16</span> | ~<span class="type">int32</span> | ~<span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Unsigned <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span> | ~<span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Float <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">float32</span> | ~<span class="type">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里虽然可以直接使用官方包 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=P0HRXEwG15JMJtcVCjX90A==.zP8q/S8qIgxQlp9ykQOilYmr6bHwh/7BvIwS7s0TVMbFpitq+YUuMxP4w0jzbW+B">golang.org&#x2F;x&#x2F;exp&#x2F;constraints</a> ，但因为这个包属于实验性质的 x 包，今后可能会发生非常大变动，所以并不推荐直接使用</p>
</blockquote>
<h3 id="接口的两种类型"><a href="#接口的两种类型" class="headerlink" title="接口的两种类型"></a>接口的两种类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">string</span> | ~[]<span class="type">rune</span></span><br><span class="line"></span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用类型集的概念来理解这个接口的意思：</p>
<p>接口类型 <code>ReadWriter</code> 代表了一个类型集合，所有以 <code>string</code> 或 <code>[]rune</code> 为底层类型，并且实现了 <code>Read()</code> <code>Write()</code> 这两个方法的类型都在 <code>ReadWriter</code> 代表的类型集当中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型 StringReadWriter 实现了接口 Readwriter</span></span><br><span class="line"><span class="keyword">type</span> StringReadWriter <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StringReadWriter)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s StringReadWriter)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  类型BytesReadWriter 没有实现接口 Readwriter</span></span><br><span class="line"><span class="keyword">type</span> BytesReadWriter []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s BytesReadWriter)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s BytesReadWriter)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，定义一个 <code>ReadWriter</code> 类型的接口变量，接口变量赋值的时候不光要考虑到方法的实现，还必须考虑到具体底层类型，心智负担太大。为了解决这个问题也为了保持 Go 语言的兼容性，Go1.18 开始将接口分为了两种类型：</p>
<ul>
<li>基本类型（Basic interface）</li>
<li>一般接口（General interface）</li>
</ul>
<h4 id="基本接口（Basic-interface）"><a href="#基本接口（Basic-interface）" class="headerlink" title="基本接口（Basic interface）"></a>基本接口（Basic interface）</h4><p>接口定义中如果只有方法的话，那么这种接口被称为**基本接口(Basic interface)**。这种接口就是 Go1.18 之前的接口，用法也基本和 Go1.18 之前保持一致。基本接口大致可以用于如下几个地方：</p>
<ul>
<li><p>定义接口变量并赋值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">interface</span> &#123;  <span class="comment">// 接口中只有方法，所以是基本接口</span></span><br><span class="line">     Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法和Go1.18之前保持一致</span></span><br><span class="line">err := MyError</span><br></pre></td></tr></table></figure>
</li>
<li><p>用在类型约束中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MySlice[T io.Reader | io.Writer] []Slice</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="一般接口（General-interface）"><a href="#一般接口（General-interface）" class="headerlink" title="一般接口（General interface）"></a>一般接口（General interface）</h4><p>接口中有类型的话，这种接口被称为 <strong>一般接口(General interface)</strong> ，如下例子都是一般接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;    <span class="comment">// 接口 Uint 中有类型，所以是一般接口</span></span><br><span class="line">    ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;   <span class="comment">// ReadWriter 接口既有方法也有类型，所以是一般接口</span></span><br><span class="line">    ~<span class="type">string</span> | ~[]<span class="type">rune</span></span><br><span class="line"></span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一般接口类型不能用来定义变量，只能用于泛型的类型约束中。</strong>所以以下的用法是错误的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Uint <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">uint</span> | ~<span class="type">uint8</span> | ~<span class="type">uint16</span> | ~<span class="type">uint32</span> | ~<span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> uintInf Uint <span class="comment">// 错误。Uint是一般接口，只能用于类型约束，不得用于变量定义</span></span><br></pre></td></tr></table></figure>

<p>这一限制保证了一般接口的使用被限定在了泛型之中，不会影响到 Go1.18 之前的代码，同时也极大减少了书写代码时的心智负担。</p>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> DataProcessor[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">    Process(oriData T) (newData T)</span><br><span class="line">    Save(data T) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DataProcessor2[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="type">int</span> | ~<span class="keyword">struct</span>&#123; Data any &#125;</span><br><span class="line"></span><br><span class="line">    Process(data T) (newData T)</span><br><span class="line">    Save(data T) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口定义的种种限制规则"><a href="#接口定义的种种限制规则" class="headerlink" title="接口定义的种种限制规则"></a>接口定义的种种限制规则</h3><p>Go1.18 从开始，在定义类型集(接口)的时候增加了非常多十分琐碎的限制规则，其中很多规则都在之前的内容中介绍过了，但剩下还有一些规则因为找不到好的地方介绍，所以在这里统一介绍下：</p>
<ol>
<li><p>用 <code>|</code> 连接多个类型的时候，类型之间不能有相交的部分(即必须是不交集)：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，MyInt的底层类型是int,和 ~int 有相交的部分</span></span><br><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | MyInt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是相交的类型中是接口的话，则不受这一限制：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | <span class="keyword">interface</span>&#123; MyInt &#125;  <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span>&#123; ~<span class="type">int</span> &#125; | MyInt <span class="comment">// 也正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span>&#123; ~<span class="type">int</span> &#125; | <span class="keyword">interface</span>&#123; MyInt &#125;  <span class="comment">// 也正确</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类型的并集中不能有类型形参</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInf[T ~<span class="type">int</span> | ~<span class="type">string</span>] <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">float32</span> | T  <span class="comment">// 错误。T是类型形参</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyInf2[T ~<span class="type">int</span> | ~<span class="type">string</span>] <span class="keyword">interface</span> &#123;</span><br><span class="line">    T  <span class="comment">// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口不能直接或间接地并入自己</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Bad <span class="keyword">interface</span> &#123;</span><br><span class="line">    Bad <span class="comment">// 错误，接口不能直接并入自己</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bad2 <span class="keyword">interface</span> &#123;</span><br><span class="line">    Bad1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bad1 <span class="keyword">interface</span> &#123;</span><br><span class="line">    Bad2 <span class="comment">// 错误，接口Bad1通过Bad2间接并入了自己</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bad3 <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | ~<span class="type">string</span> | Bad3 <span class="comment">// 错误，通过类型的并集并入了自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口的并集成员个数大于一的时候不能直接或间接并入 <code>comparable</code> 接口</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> OK <span class="keyword">interface</span> &#123;</span><br><span class="line">    comparable <span class="comment">// 正确。只有一个类型的时候可以使用 comparable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bad1 <span class="keyword">interface</span> &#123;</span><br><span class="line">    []<span class="type">int</span> | comparable <span class="comment">// 错误，类型并集不能直接并入 comparable 接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CmpInf <span class="keyword">interface</span> &#123;</span><br><span class="line">    comparable</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bad2 <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">chan</span> <span class="type">int</span> | CmpInf  <span class="comment">// 错误，类型并集通过 CmpInf 间接并入了comparable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Bad3 <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="keyword">chan</span> <span class="type">int</span> | <span class="keyword">interface</span>&#123;comparable&#125;  <span class="comment">// 理所当然，这样也是不行的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>带方法的接口（无论是基本接口还是一般接口），都不能写入接口的并集中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | ~<span class="type">string</span> | <span class="type">error</span> <span class="comment">// 错误，error是带方法的接口(一般接口) 不能写入并集中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DataProcessor[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">string</span> | ~[]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">    Process(data T) (newData T)</span><br><span class="line">    Save(data T) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，实例化之后的 DataProcessor[string] 是带方法的一般接口，不能写入类型并集</span></span><br><span class="line"><span class="keyword">type</span> _ <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | ~<span class="type">string</span> | DataProcessor[<span class="type">string</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Bad[T any] <span class="keyword">interface</span> &#123;</span><br><span class="line">    ~<span class="type">int</span> | ~<span class="type">string</span> | DataProcessor[T]  <span class="comment">// 也不行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上推荐的使用场景也并没有那么广泛，对于泛型的使用，我们应该遵守下面的规则：</p>
<p>泛型并不取代 Go1.18 之前用接口+反射实现的动态类型，在下面情景的时候非常适合使用泛型：当你需要针对不同类型书写同样的逻辑，使用泛型来简化代码是最好的 (比如你想写个队列，写个链表、栈、堆之类的数据结构）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/Golang/map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Golang/map/" class="post-title-link" itemprop="url">map</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-23 14:16:56" itemprop="dateCreated datePublished" datetime="2023-02-23T14:16:56+08:00">2023-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-29 16:58:05" itemprop="dateModified" datetime="2023-05-29T16:58:05+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/Golang/slice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Golang/slice/" class="post-title-link" itemprop="url">slice</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-23 14:16:56" itemprop="dateCreated datePublished" datetime="2023-02-23T14:16:56+08:00">2023-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-29 16:58:05" itemprop="dateModified" datetime="2023-05-29T16:58:05+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>slice 是数组的引用，但是本身是结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/slice.go</span></span><br><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line"> array unsafe.Pointer		<span class="comment">// 指向slice中第一个元素的指针</span></span><br><span class="line"> <span class="built_in">len</span>   <span class="type">int</span>					<span class="comment">// slice的长度，长度是下标操作的上界，如x[i]中i必须小于长度</span></span><br><span class="line"> <span class="built_in">cap</span>   <span class="type">int</span>					<span class="comment">// slice的容量，容量是分割操作的上界，如x[i:j]中j不能大于容量。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="len-和-cap"><a href="#len-和-cap" class="headerlink" title="len 和 cap"></a>len 和 cap</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(s[<span class="number">0</span>])           <span class="comment">// &quot;&quot;</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// 1 3</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s)) <span class="comment">// 4 6</span></span><br></pre></td></tr></table></figure>

<p>创建 slice：</p>
<ol>
<li>创建一个长度为<code>cap</code>的数组，如果不指定<code>cap</code>，则<code>cap</code>等于<code>len</code>；例如<code>s := []string&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;</code>的<code>len</code>和<code>cap</code>都是 3；</li>
<li>将数组前<code>len</code>个元素进行初始化，上例中数组第一个元素 k 初始化为空字符串；</li>
<li>返回。</li>
</ol>
<h2 id="slice-的分割"><a href="#slice-的分割" class="headerlink" title="slice 的分割"></a>slice 的分割</h2><p>slice 的分割不涉及复制操作：它只是新建了一个结构来放置一个不同的指针，长度和容量：</p>
<p><img data-src="//img.to2b.cn/blog/ljk/1677118637857.png"></p>
<p>分割表达式<code>x[1:3]</code>并不分配更多的数据：它只是创建了一个新的 slice 来引用相同的存储数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 := s1[<span class="number">0</span>:] <span class="comment">// 等价于 s2 = s1</span></span><br><span class="line">s1[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(s2)    <span class="comment">// [100 2 3]</span></span><br></pre></td></tr></table></figure>

<p>修改 s1，也会影响到 s2。</p>
<p><strong>字符串</strong>的分割也同理：</p>
<p><img data-src="//img.to2b.cn/blog/ljk/1677124726990.png"></p>
<h2 id="append-和-copy"><a href="#append-和-copy" class="headerlink" title="append 和 copy"></a>append 和 copy</h2><h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><p>现有的元素加上要添加的元素，长度不超过 cap，则不会发生扩容行为，只会修改被引用的数组和<code>len</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line">s2 := s1</span><br><span class="line">s1 = <span class="built_in">append</span>(s1, <span class="number">1</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%p len：%d cap：%d\n&quot;</span>, s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1)) <span class="comment">// 0xc00010a000 len：3 cap：100</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p len：%d cap：%d\n&quot;</span>, s2, <span class="built_in">len</span>(s2), <span class="built_in">cap</span>(s2)) <span class="comment">// 0xc00010a000 len：2 cap：100</span></span><br><span class="line">fmt.Println(s1)  <span class="comment">// [0 0 1]</span></span><br><span class="line">fmt.Println(s2)  <span class="comment">// [0 0]</span></span><br></pre></td></tr></table></figure>

<p>append 添加的元素太多，当前底层的数组不够用了，就会自动扩容，会复制被引用的数组，然后切断引用关系。</p>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>上面的例子中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 := s1[<span class="number">0</span>:] <span class="comment">// 等价于 s2 = s1</span></span><br><span class="line">s1[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(s2)    <span class="comment">// output：[100 2 3]</span></span><br></pre></td></tr></table></figure>

<p>修改 s1，也会影响到 s2，如果想避免这种情况，需要使用<code>copy(dst, src)</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(s1))</span><br><span class="line"><span class="built_in">copy</span>(s2, s1)</span><br><span class="line">s1[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">fmt.Println(s2)  <span class="comment">// output：[1 2 3]</span></span><br></pre></td></tr></table></figure>

<h2 id="slice-的扩容"><a href="#slice-的扩容" class="headerlink" title="slice 的扩容"></a>slice 的扩容</h2><p>在对 slice 进行 append 等操作时，可能导致 slice 会自动扩容，重新分配更大的数组。go1.18 之前其扩容的策略是：</p>
<ol>
<li>如果新的大小是当前大小 2 倍以上，则大小增长为新大小；</li>
<li>否则循环操作：如果当前大小小于 1024，按每次 2 倍增长，否则每次按当前大小 1&#x2F;4 增长。</li>
</ol>
<p>go1.18 之后，优化了切片扩容的策略 2，让底层数组大小的增长更加平滑：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">    newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> threshold = <span class="number">256</span></span><br><span class="line">    <span class="keyword">if</span> old.<span class="built_in">cap</span> &lt; threshold &#123;</span><br><span class="line">        newcap = doublecap</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line">        <span class="comment">// and prevent an infinite loop.</span></span><br><span class="line">        <span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">            <span class="comment">// Transition from growing 2x for small slices</span></span><br><span class="line">            <span class="comment">// to growing 1.25x for large slices. This formula</span></span><br><span class="line">            <span class="comment">// gives a smooth-ish transition between the two.</span></span><br><span class="line">            newcap += (newcap + <span class="number">3</span>*threshold) / <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line">        <span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line">        <span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">            newcap = <span class="built_in">cap</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过减小阈值并固定增加一个常数，使得优化后的扩容的系数在阈值前后不再会出现从 2 到 1.25 的突变，作者给出了几种原始容量下对应的“扩容系数”：</p>
<table>
<thead>
<tr>
<th>原始容量</th>
<th>扩容系数</th>
</tr>
</thead>
<tbody><tr>
<td>256</td>
<td>2.0</td>
</tr>
<tr>
<td>512</td>
<td>1.63</td>
</tr>
<tr>
<td>1024</td>
<td>1.44</td>
</tr>
<tr>
<td>2048</td>
<td>1.35</td>
</tr>
<tr>
<td>4096</td>
<td>1.30</td>
</tr>
</tbody></table>
<h2 id="什么时候用-slice？"><a href="#什么时候用-slice？" class="headerlink" title="什么时候用 slice？"></a>什么时候用 slice？</h2><p>在 go 语言中 slice 是很灵活的，大部分情况都能表现的很好，但也有特殊情况。</p>
<p>当程序要求 slice 的容量超大并且需要频繁的更改 slice 的内容时，就不应该用 slice，改用<a target="_blank" rel="noopener" href="https://golang.org/pkg/container/list/">list</a>更合适。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/%E8%BF%90%E7%BB%B4/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2/Ubuntu22.04%E5%BA%94%E7%AD%94%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E8%BF%90%E7%BB%B4/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2/Ubuntu22.04%E5%BA%94%E7%AD%94%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">Ubuntu22.04应答文件</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-09 23:08:52" itemprop="dateCreated datePublished" datetime="2022-12-09T23:08:52+08:00">2022-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-29 16:58:05" itemprop="dateModified" datetime="2023-05-29T16:58:05+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%90%E7%BB%B4/" itemprop="url" rel="index"><span itemprop="name">运维</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%90%E7%BB%B4/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">运维自动化</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%90%E7%BB%B4/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2/" itemprop="url" rel="index"><span itemprop="name">系统部署</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>转载：<a target="_blank" rel="noopener" href="http://hmli.ustc.edu.cn/doc/linux/ubuntu-autoinstall/index.html">http://hmli.ustc.edu.cn/doc/linux/ubuntu-autoinstall/index.html</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Ubuntu 22.04下的PXE自动无人值守安装配置服务设置，原文内容比较简单，基本为翻译的 <a target="_blank" rel="noopener" href="https://ubuntu.com/server/docs">Ubuntu 22.04官方手册</a> 。</p>
<ul>
<li><ul>
<li><p>服务端提供PXE自动安装服务的信息：</p>
<p>提供DHCPD服务的网卡：enp2s0IP：192.168.22.254掩码：255.255.255.0</p>
</li>
</ul>
</li>
<li><ul>
<li><p>客户端（目标对象）网络启动引导的信息：</p>
<p>安装系统名：Cleint1采用DHCP协议引导的网卡：enp1s0MAC地址：08:00:20:0A:0C:01自身IP：192.168.22.1网关IP：192.168.22.254掩码：255.255.255.0DNS：202.38.64.7</p>
</li>
</ul>
</li>
</ul>
<p>下述带有 <strong>1.、2.</strong> 编号的才是实际执行的步骤，其他都是介绍。</p>
<h1 id="AMD64-x86-64-架构网络安装"><a href="#AMD64-x86-64-架构网络安装" class="headerlink" title="AMD64(x86_64)架构网络安装"></a>AMD64(x86_64)架构网络安装</h1><p>AMD64（也称为x86_64）架构的系统启动既可以采用 <strong>UEFI</strong> 也可以采用传统 <strong>legacy</strong> (“BIOS”) 模式（很多系统可以被配置为采用其中任一模式启动）。确切的细节取决于系统固件，但两种模式都支持 <strong>PXE(“Preboot eXecution Environment”)</strong> 规范，使得可以通过网络来提供启动器引导加载程序启动主机。</p>
<p>两种模式的网络启动实时服务器安装程序的过程相似，如下所示：</p>
<ul>
<li>待安装机器启动，并定向到网络启动。</li>
<li><strong>DHCP&#x2F;bootp</strong> 服务器告诉机器它的网络配置以及从哪里获取引导加载程序。</li>
<li>机器的固件通过 <strong>tftp</strong> 协议下载引导加载程序并执行它。</li>
<li>引导加载程序通过 <strong>tftp</strong> 协议下载配置，告诉它在哪里下载内核(<strong>kernel</strong>)、 <strong>ramdisk</strong> 和内核命令行以使用。</li>
<li><strong>ramdisk</strong> 查看内核命令行以了解如何配置网络以及从何处下载服务器 <strong>ISO</strong> 操作系统安装镜像文件。</li>
<li><strong>ramdisk</strong> 下载操作系统 <strong>ISO</strong> 并将其安装为循环设备。</li>
<li>从此时起，安装遵循与操作系统 <strong>ISO</strong> 在本地块设备上相同的路径。</li>
</ul>
<p><strong>UEFI</strong> 和传统模式之间的区别在于：在 <strong>UEFI</strong> 模式下，引导加载程序是 <strong>EFI</strong> 可执行文件，经过签名以便安全引导 <strong>SecureBoot</strong> 接受，而在传统模式下，它是 <strong>PXELINUX</strong> 。大多数 <strong>DHCP&#x2F;bootp</strong> 服务器可以配置为为特定机器提供正确的引导加载程序。</p>
<h2 id="设置DHPC-x2F-bootp和tftp服务"><a href="#设置DHPC-x2F-bootp和tftp服务" class="headerlink" title="设置DHPC&#x2F;bootp和tftp服务"></a>设置DHPC&#x2F;bootp和tftp服务</h2><p>有几种可用的 <strong>DHCP&#x2F;bootp</strong> 和 <strong>tftp</strong> 协议实现。本文档将简要介绍如何配置 <strong>dnsmasq</strong> 服务（相比配置 <strong>isc-dhcp-server</strong> 与 <strong>tftpd</strong> 简单的多）以执行这两个角色。</p>
<ol>
<li><p>创建存放为客户端提供 <strong>tftp</strong> 服务所需要的文件的目录 <em>&#x2F;srv&#x2F;tftp</em> ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /srv/tftp</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 <strong>dnsmasq</strong> 包，执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install dnsmasq </span><br></pre></td></tr></table></figure>
</li>
<li><p>设置文件 <em>&#x2F;etc&#x2F;dnsmasq.conf.d&#x2F;pxe.conf</em> ，其内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置本服务器提供DHCP服务的网卡 </span></span><br><span class="line">interface=enp2s0,lo bind-interfaces </span><br><span class="line"><span class="comment">#提供DHCP服务的网卡,开始IP,结束IP </span></span><br><span class="line">dhcp-range=enp2s0,192.168.22.1,192.168.22.254 dhcp-boot=pxelinux.0 </span><br><span class="line"><span class="comment">#设置采用UEFI模式 dhcp-match=set:efi-x86_64,option:client-arch,7 dhcp-boot=tag:efi-x86_64,bootx64.efi </span></span><br><span class="line"><span class="comment">#启用tftp服务 enable-tftp </span></span><br><span class="line"><span class="comment">#设置tftp服务目录 tftp-root=/srv/tftp </span></span><br><span class="line"><span class="comment">#设定将要网络安装的MAC地址为08:00:20:0A:0C:01的主机名为Client1，IP为192.168.22.1 </span></span><br><span class="line">dhcp-host=08:00:20:0A:0C:01,Client1,192.168.22.1 </span><br><span class="line"><span class="comment">#设定将要网络安装的MAC地址为08:00:20:0A:0C:02的主机名为Client2，IP为192.168.22.2 </span></span><br><span class="line">dhcp-host=08:00:20:0A:0C:02,Client2,192.168.22.2 </span><br></pre></td></tr></table></figure>

<p>上面 <strong>enp2s0</strong> 为对客户端安装服务时使用的网卡名（与客户端启动网络安装服务的网卡在同一网络）。</p>
</li>
<li><p>重启 <strong>dnsmasq</strong> 服务，执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart dnsmasq</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="提供引导加载程序和配置"><a href="#提供引导加载程序和配置" class="headerlink" title="提供引导加载程序和配置"></a>提供引导加载程序和配置</h2><h3 id="设置所需要的包"><a href="#设置所需要的包" class="headerlink" title="设置所需要的包"></a>设置所需要的包</h3><ol>
<li><p>安装对应包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install cd-boot-images-amd64</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成软链接 <code>/srv/tftp/boot-amd64</code>指向 <code>/usr/share/cd-boot-images-amd64</code> ：</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /usr/share/cd-boot-images-amd64 /srv/tftp/boot-amd64</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h3 id="安装WEB服务"><a href="#安装WEB服务" class="headerlink" title="安装WEB服务"></a>安装WEB服务</h3><p>安装时，需要通过 <strong>HTTP</strong> 协议下载所需文件，为此需要配置 <strong>WEB</strong> 服务。</p>
<p>安装所需要包，并重新启动服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install apache2 </span><br><span class="line">systemctl restart apache2</span><br></pre></td></tr></table></figure>

<p>或者不用上述 <strong>apache</strong> 服务，如python3支持http模块，则可直接执行下述命令启动简易 <strong>WEB</strong> 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 80</span><br></pre></td></tr></table></figure>

<h3 id="模式独立设置"><a href="#模式独立设置" class="headerlink" title="模式独立设置"></a>模式独立设置</h3><ol>
<li><p>针对该次使用 <strong>Ubuntu 22.04 server</strong> 版（代号： <strong>jammy</strong> ），建议有些配置文件放置在目录 <em>&#x2F;var&#x2F;www&#x2F;html&#x2F;jammy</em> 下，为此先生成该目录：</p>
<p><code>mkdir /var/www/html/jammy </code></p>
</li>
<li><p>下载所需要的操作系统 <strong>Live ISO</strong> 镜像到目录 <em>&#x2F;var&#x2F;www&#x2F;html</em> ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /var/www/html/jammy</span><br><span class="line">wget http://mirrors.ustc.edu.cn/ubuntu-releases/jammy/ubuntu-22.04.1-live-server-amd64.iso</span><br></pre></td></tr></table></figure>
</li>
<li><p>挂载该ISO文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o loop /var/www/html/jammy/ubuntu-22.04.1-live-server-amd64.iso /mnt </span><br></pre></td></tr></table></figure>
</li>
<li><p>将内核和 <strong>initrd</strong> 从其中复制到 <strong>dnsmasq</strong> 中设置的 <strong>tftp</strong> 的位置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /mnt/casper/&#123;vmlinuz,initrd&#125; /srv/tftp/</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="为-UEFI-引导设置文件"><a href="#为-UEFI-引导设置文件" class="headerlink" title="为 UEFI 引导设置文件"></a>为 <strong>UEFI</strong> 引导设置文件</h3><ol>
<li><p>将签名的 shim 二进制文件复制到位：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt download shim-signed</span><br><span class="line">dpkg-deb --fsys-tarfile shim-signed*deb | tar x ./usr/lib/shim/shimx64.efi.signed -O &gt; /srv/tftp/bootx64.efi</span><br></pre></td></tr></table></figure>
</li>
<li><p>将签名的 grub 二进制文件复制到位：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt download grub-efi-amd64-signed</span><br><span class="line">dpkg-deb --fsys-tarfile grub-efi-amd64-signed*deb | tar x ./usr/lib/grub/x86_64-efi-signed/grubnetx64.efi.signed -O &gt; /srv/tftp/grubx64.efi</span><br></pre></td></tr></table></figure>
</li>
<li><p>Grub 还需要在 tftp 上可用的字体：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt download grub-common</span><br><span class="line">dpkg-deb --fsys-tarfile grub-common*deb | tar x ./usr/share/grub/unicode.pf2 -O &gt; /srv/tftp/unicode.pf2</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成文件 <em><code>/srv/tftp/grub/grub.cfg</code></em> ，内容为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> default=<span class="string">&quot;0&quot;</span></span><br><span class="line"><span class="built_in">set</span> <span class="built_in">timeout</span>=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> loadfont unicode ; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">set</span> gfxmode=auto</span><br><span class="line">  <span class="built_in">set</span> locale_dir=<span class="variable">$prefix</span>/locale</span><br><span class="line">  <span class="built_in">set</span> lang=en_US</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">terminal_output gfxterm</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> menu_color_normal=white/black</span><br><span class="line"><span class="built_in">set</span> menu_color_highlight=black/light-gray</span><br><span class="line"><span class="keyword">if</span> background_color 44,0,30; <span class="keyword">then</span></span><br><span class="line">  clear</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> gfxmode &#123;</span><br><span class="line">        <span class="built_in">set</span> gfxpayload=<span class="string">&quot;<span class="variable">$&#123;1&#125;</span>&quot;</span></span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;1&#125;</span>&quot;</span> = <span class="string">&quot;keep&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">set</span> vt_handoff=vt.handoff=7</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">set</span> vt_handoff=</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> linux_gfx_mode=keep</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> linux_gfx_mode</span><br><span class="line"></span><br><span class="line">menuentry <span class="string">&#x27;Ubuntu 22.04.1&#x27;</span> &#123;</span><br><span class="line">        gfxmode <span class="variable">$linux_gfx_mode</span></span><br><span class="line">        linux /vmlinuz <span class="variable">$vt_handoff</span> ip=dhcp url=http://192.168.22.254/jammy/ubuntu-22.04.1-live-server-amd64.iso autoinstall ds=nocloud-net\;s=http://192.168.22.254/jammy/ ---</span><br><span class="line">        <span class="comment">#注意上面最后面有三个-</span></span><br><span class="line">        initrd /initrd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>备注：</p>
<ul>
<li>linux &#x2F;vmlinuz 行的 <em><code>ds=nocloud-net;s=http</code></em> 部分的“;”前面有个转义符“”，最后有三个“-”</li>
<li>上述配置非常简单。PXELINUX有很多选项，可以在 <a target="_blank" rel="noopener" href="https://wiki.syslinux.org/wiki/index.php?title=PXELINUX">https://wiki.syslinux.org/wiki/index.php?title=PXELINUX</a> 查阅其文档以获取更多信息。</li>
</ul>
</li>
</ol>
<h1 id="自动化服务器安装"><a href="#自动化服务器安装" class="headerlink" title="自动化服务器安装"></a>自动化服务器安装</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>从 <strong>20.04</strong> 版起，服务器安装程序支持一种新的操作模式：自动安装（简称 <strong>autoinstall</strong> ），此功能也被称为无人值守、甩手或预置安装。</p>
<p>自动安装使得用户可以通过提前配置自动安装配置文件回答所有这些安装配置问题，并让安装过程无需任何交互即可自行运行，适合批量安装多台主机。</p>
<h2 id="与-debian-installer-预置安装的区别"><a href="#与-debian-installer-预置安装的区别" class="headerlink" title="与 debian-installer 预置安装的区别"></a>与 <strong>debian-installer</strong> 预置安装的区别</h2><p><strong>preseeds</strong> 是基于 <strong>debian-installer</strong> （又名 <strong>d-i</strong> ）自动化安装程序的方法。</p>
<p>Ubuntu新 <strong>autoinstall</strong> 方式的自动安装主要在以下方面不同于 <strong>preseeds</strong> ：</p>
<ul>
<li><p>格式完全不同（ <strong>cloud-init config</strong> 格式，通常是 <strong>yaml</strong> 格式，vs <strong>debconf-set-selections</strong> 格式）</p>
</li>
<li><p>当一个问题的答案不存在于 <strong>preseeds</strong> 中时， <strong>d-i</strong> 停止执行并要求用户输入。 <strong>autoinstalls</strong> 自动安装不是这样的：默认情况下，如果有任何自动安装配置，安装程序会为任何未回答的问题采用默认设置（如没有默认设置则失败）。</p>
<p>用户可以将配置中的特定部分指定为“交互式”，这意味着安装程序仍会停止并询问这些部分。</p>
</li>
</ul>
<h2 id="提供自动安装配置"><a href="#提供自动安装配置" class="headerlink" title="提供自动安装配置"></a>提供自动安装配置</h2><p>自动安装配置是通过 <strong>cloud-init</strong> 配置提供的，几乎无限灵活。在大多数情况下，最简单的方法是通过 <strong>nocloud</strong> 数据源提供用户数据。</p>
<p>自动安装配置应在配置中的关键字 <strong>autoinstall</strong> 下提供，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cloud-config</span></span><br><span class="line">autoinstall:</span><br><span class="line">  version: 1</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<h2 id="运行真正的自动安装"><a href="#运行真正的自动安装" class="headerlink" title="运行真正的自动安装"></a>运行真正的自动安装</h2><p>即使找到完全非交互式的自动安装配置，服务器安装程序也会在写入磁盘之前要求确认，除非内核命令行上存在自动安装关键字 <strong>autoinstall</strong> 。这是为了避免意外创建一个U盘，结果该U盘会在主机启动时重新格式化它插入的机器。许多自动安装将通过 <strong>netboot</strong> 完成，其中内核命令行由 <strong>netboot</strong> 配置控制 —— 只需记住将自动安装放在那里！</p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>如只是想试试看，可以参看页面 <a target="_blank" rel="noopener" href="https://ubuntu.com/server/docs/install/autoinstall-quickstart">https://ubuntu.com/server/docs/install/autoinstall-quickstart</a> 。</p>
<h2 id="创建自动安装配置"><a href="#创建自动安装配置" class="headerlink" title="创建自动安装配置"></a>创建自动安装配置</h2><p>当服务器安装好Ubuntu操作系统时，会在安装好后的服务器上创建一个可用于重复安装的自动安装文件 <em><code>/var/log/installer/autoinstall-user-data</code></em> ，这可用于做后续需要的文件 <em>user-data</em> 的模板。</p>
<h2 id="转换现有-preseed-文件"><a href="#转换现有-preseed-文件" class="headerlink" title="转换现有 preseed 文件"></a>转换现有 <strong>preseed</strong> 文件</h2><p>如已经有了Debian系统的 <strong>preseed</strong> 文件，可利用自动安装生成器 <a target="_blank" rel="noopener" href="https://snapcraft.io/autoinstall-generator?_ga=2.223897308.698614161.1664162991-1711338095.1646124381">autoinstall-generator</a> <strong>snap</strong> 包（snap 是一种包管理器，可用于安装远程snap包）可以帮助将该预置数据转换为自动安装文件。</p>
<p>安装 <strong>autoinstall-generator</strong> 包，执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snap install autoinstall-generator</span><br></pre></td></tr></table></figure>

<p>将 <strong>preseed</strong> 文件转换为自动安装格式的基本用法为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoinstall-generator my-preseed.txt my-cloud-config.yaml --cloud</span><br></pre></td></tr></table></figure>

<p>有关详细信息，请 <a target="_blank" rel="noopener" href="https://discourse.ubuntu.com/t/autoinstall-generator-tool-to-help-with-creation-of-autoinstall-files-based-on-preseed/21334?_ga=2.35077545.964202620.1664022245-197937644.1660466546">参阅</a> 。</p>
<h2 id="自动安装配置文件的结构"><a href="#自动安装配置文件的结构" class="headerlink" title="自动安装配置文件的结构"></a>自动安装配置文件的结构</h2><p>自动安装配置的完整说明参见：<a target="_blank" rel="noopener" href="https://ubuntu.com/server/docs/install/autoinstall-reference">https://ubuntu.com/server/docs/install/autoinstall-reference</a> 。</p>
<p>从技术上讲，虽然配置未定义为文本格式，但 <strong>cloud-init</strong> 配置通常以 <strong>YAML</strong> 形式提供，这是本文档使用的语法。</p>
<p>一个最小的配置是：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">identity:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">hostname</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">username</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$crypted_pass</span></span><br></pre></td></tr></table></figure>

<p>含有更多特性的配置为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">reporting:</span></span><br><span class="line">    <span class="attr">hook:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">webhook</span></span><br><span class="line">        <span class="attr">endpoint:</span> <span class="string">http://example.com/endpoint/path</span></span><br><span class="line"><span class="attr">early-commands:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ping</span> <span class="string">-c1</span> <span class="number">198.162</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line"><span class="attr">locale:</span> <span class="string">en_US</span></span><br><span class="line"><span class="attr">keyboard:</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">gb</span></span><br><span class="line">    <span class="attr">variant:</span> <span class="string">dvorak</span></span><br><span class="line"><span class="attr">network:</span></span><br><span class="line">    <span class="attr">network:</span></span><br><span class="line">        <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">ethernets:</span></span><br><span class="line">            <span class="attr">enp0s25:</span></span><br><span class="line">               <span class="attr">dhcp4:</span> <span class="literal">yes</span></span><br><span class="line">            <span class="attr">enp3s0:</span> &#123;&#125;</span><br><span class="line">            <span class="attr">enp4s0:</span> &#123;&#125;</span><br><span class="line">        <span class="attr">bonds:</span></span><br><span class="line">            <span class="attr">bond0:</span></span><br><span class="line">                <span class="attr">dhcp4:</span> <span class="literal">yes</span></span><br><span class="line">                <span class="attr">interfaces:</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="string">enp3s0</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="string">enp4s0</span></span><br><span class="line">                <span class="attr">parameters:</span></span><br><span class="line">                    <span class="attr">mode:</span> <span class="string">active-backup</span></span><br><span class="line">                    <span class="attr">primary:</span> <span class="string">enp3s0</span></span><br><span class="line"><span class="attr">proxy:</span> <span class="string">http://squid.internal:3128/</span></span><br><span class="line"><span class="attr">apt:</span></span><br><span class="line">    <span class="attr">primary:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">arches:</span> [<span class="string">default</span>]</span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://repo.internal/</span></span><br><span class="line">    <span class="attr">sources:</span></span><br><span class="line">        <span class="attr">my-ppa.list:</span></span><br><span class="line">            <span class="attr">source:</span> <span class="string">&quot;deb http://ppa.launchpad.net/curtin-dev/test-archive/ubuntu $RELEASE main&quot;</span></span><br><span class="line">            <span class="attr">keyid:</span> <span class="string">B59D</span> <span class="string">5F15</span> <span class="string">97A5</span> <span class="string">04B7</span> <span class="string">E230</span>  <span class="string">6DCA</span> <span class="number">0620 </span><span class="string">BBCF</span> <span class="number">0368 </span><span class="string">3F77</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">    <span class="attr">layout:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">lvm</span></span><br><span class="line"><span class="attr">identity:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">hostname</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">username</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$crypted_pass</span></span><br><span class="line"><span class="attr">ssh:</span></span><br><span class="line">    <span class="attr">install-server:</span> <span class="literal">yes</span></span><br><span class="line">    <span class="attr">authorized-keys:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">$key</span></span><br><span class="line">    <span class="attr">allow-pw:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">snaps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">go</span></span><br><span class="line">      <span class="attr">channel:</span> <span class="number">1.14</span><span class="string">/stable</span></span><br><span class="line">      <span class="attr">classic:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">debconf-selections:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    bind9      bind9/run-resolvconf    boolean false</span></span><br><span class="line"><span class="string"></span><span class="attr">packages:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">libreoffice</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">dns-server^</span></span><br><span class="line"><span class="attr">user-data:</span></span><br><span class="line">    <span class="attr">disable_root:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">late-commands:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">sed</span> <span class="string">-ie</span> <span class="string">&#x27;s/GRUB_TIMEOUT=.*/GRUB_TIMEOUT=30/&#x27;</span> <span class="string">/target/etc/default/grub</span></span><br><span class="line"><span class="attr">error-commands:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tar</span> <span class="string">c</span> <span class="string">/var/log/installer</span> <span class="string">|</span> <span class="string">nc</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>许多关键字和值一般直接对应于安装程序提出的问题（例如键盘选择），请参阅相关资料。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>安装过程中的进度及出错信息，可以通过报告 <a target="_blank" rel="noopener" href="https://ubuntu.com/server/docs/install/autoinstall-reference#reporting">reporting</a> 关键字设定的系统获取。此外，当发生致命错误时，将执行错误命令 <a target="_blank" rel="noopener" href="https://ubuntu.com/server/docs/install/autoinstall-reference#error-commands">error-commands</a> 并将回溯打印到控制台，然后服务器等待人为交互式干预。</p>
<h2 id="未来可能的方向"><a href="#未来可能的方向" class="headerlink" title="未来可能的方向"></a>未来可能的方向</h2><p>可能希望扩展磁盘的 <strong>match specs</strong> （匹配规范）以涵盖选择磁盘的其他方式。</p>
<h1 id="自动安装快速入门"><a href="#自动安装快速入门" class="headerlink" title="自动安装快速入门"></a>自动安装快速入门</h1><p><strong>cloud-init</strong> 使用以下三种数据并对其进行操作。</p>
<ul>
<li>用户数据 <strong>user-data</strong> ：包含执行无人值守自动安装所需的指令，如要安装的软件包、分区布局、网络配置等。</li>
<li>元数据 <strong>meta-data</strong> ：包括与特定数据源关联的数据，如可以包括服务器名称和实例ID等。</li>
<li>供应商数据 <strong>vendor-data</strong> ：由组织（如，云提供商）提供的，包括可以自定义镜像以更好地适应镜像运行环境的信息，该种数据为可选。</li>
</ul>
<ol>
<li><p>设置用户数据文件 <em><code>/var/www/html/jammy/user-data</code></em> （可以采用文件 <em><code>/var/log/installer/autoinstall-user-data</code></em> 为模板修改），其内容为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cloud-config</span></span><br><span class="line"><span class="attr">autoinstall:</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">late-commands:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mkdir</span> <span class="string">/target/root/.ssh</span> <span class="string">&amp;&amp;</span> <span class="string">echo</span> <span class="string">&quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDZUS2FXGm2yK09Tv0biWIwLszp0TPGzB2u1PD/QXCGPimLOmEP2xAFJbgwzeXlgfnj01LP7BD65lidSPd68WwaUsNHdlikfwf9iRdlSXxNg+PVueY2KPHRzgQ5omtAzJFUUnHKIOSH/Ozo9tmwrs4tZc4CNpx44InvgQY3yeKfhqvVn2O+WazirNlGsFRcpMcjLJjZ+U2OfMGM4l0soSDJKJTKoaHmV0XpIOA2iqfQmOgFDZExqmjc8Vj/1hTBvTzyhgMPlzkDz28UsuBT3U+RZiZJokPtXks5mnVkVYzQvOkln3r0+bmOX0Q4qDg2HhinSpGXAZGln1PKH3AFU7StMIg6e1Lb8AMNHNxWBR61uXIwJJw3dcP6Sy3N4Gq3WW+hkVsHJgZRD+dPQNRwMHIY1CIfBtB9TySKpwNwSAeXiBPFoYgAi0RlbrdHLpjDl9LxK/vyZ1gvGSumtU9IM01EZWfXfCKoMX68ljIaVsHHhHbqIXSS7AjaEsJO+ss8nQU= root@ubuntu22-server.hanhai22.ustc.edu.cn&quot;</span> <span class="string">&gt;/target/root/.ssh/authorized_keys</span></span><br><span class="line">  <span class="attr">apt:</span></span><br><span class="line">    <span class="attr">disable_components:</span> []</span><br><span class="line">    <span class="attr">geoip:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">preserve_sources_list:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">primary:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">arches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">amd64</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">i386</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://mirrors.ustc.edu.cn/ubuntu</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">arches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">uri:</span> <span class="string">http://ports.ubuntu.com/ubuntu-ports</span></span><br><span class="line">  <span class="attr">drivers:</span></span><br><span class="line">    <span class="attr">install:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">identity:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">Client1.hanhai.scc.ustc.edu.cn</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">$6$dIUrqz$MJN/0cc47EFl8OJBsbxm/o37ScqlZtXb8r63rGa0JLnbwpYQSLrCq7qgEcOAJc6RlkNbIicK6VlPPK402FD7wMQv.sHqNIl1</span></span><br><span class="line">    <span class="attr">realname:</span> <span class="string">hmli</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmli</span></span><br><span class="line">  <span class="attr">kernel:</span></span><br><span class="line">    <span class="attr">package:</span> <span class="string">linux-generic</span></span><br><span class="line">  <span class="attr">keyboard:</span></span><br><span class="line">    <span class="attr">layout:</span> <span class="string">us</span></span><br><span class="line">    <span class="attr">toggle:</span> <span class="literal">null</span></span><br><span class="line">    <span class="attr">variant:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">locale:</span> <span class="string">en_US.UTF-8</span></span><br><span class="line">  <span class="attr">network:</span></span><br><span class="line">    <span class="attr">ethernets:</span></span><br><span class="line">      <span class="attr">enp1s0:</span></span><br><span class="line">        <span class="attr">addresses:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="number">192.168</span><span class="number">.22</span><span class="number">.1</span><span class="string">/24</span></span><br><span class="line">        <span class="attr">gateway4:</span> <span class="number">192.168</span><span class="number">.22</span><span class="number">.254</span></span><br><span class="line">        <span class="attr">nameservers:</span></span><br><span class="line">          <span class="attr">addresses:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="number">202.38</span><span class="number">.64</span><span class="number">.7</span></span><br><span class="line">          <span class="attr">search:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ustc.edu.cn</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">ssh:</span></span><br><span class="line">    <span class="attr">allow-pw:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">authorized-keys:</span> []</span><br><span class="line">    <span class="attr">install-server:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">storage:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ptable:</span> <span class="string">gpt</span></span><br><span class="line"><span class="comment">#      serial: c9d3b07e01624ab69df6</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/dev/vda</span></span><br><span class="line">      <span class="attr">wipe:</span> <span class="string">superblock</span></span><br><span class="line">      <span class="attr">preserve:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="attr">grub_device:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">disk</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">disk-vda</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">device:</span> <span class="string">disk-vda</span></span><br><span class="line">      <span class="attr">size:</span> <span class="number">999292928</span></span><br><span class="line">      <span class="attr">wipe:</span> <span class="string">superblock</span></span><br><span class="line">      <span class="attr">flag:</span> <span class="string">boot</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">preserve:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">grub_device:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">partition</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">partition-0</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">fstype:</span> <span class="string">fat32</span></span><br><span class="line">      <span class="attr">volume:</span> <span class="string">partition-0</span></span><br><span class="line">      <span class="attr">preserve:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">format</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">format-0</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">device:</span> <span class="string">disk-vda</span></span><br><span class="line">      <span class="attr">size:</span> <span class="number">1902116864</span></span><br><span class="line">      <span class="attr">wipe:</span> <span class="string">superblock</span></span><br><span class="line">      <span class="attr">flag:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">preserve:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">grub_device:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">partition</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">partition-1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">fstype:</span> <span class="string">ext4</span></span><br><span class="line">      <span class="attr">volume:</span> <span class="string">partition-1</span></span><br><span class="line">      <span class="attr">preserve:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">format</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">format-1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">device:</span> <span class="string">disk-vda</span></span><br><span class="line">      <span class="attr">size:</span> <span class="number">18571329536</span></span><br><span class="line">      <span class="attr">wipe:</span> <span class="string">superblock</span></span><br><span class="line">      <span class="attr">flag:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="attr">number:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">preserve:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">grub_device:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">partition</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">partition-2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ubuntu-vg</span></span><br><span class="line">      <span class="attr">devices:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">partition-2</span></span><br><span class="line">      <span class="attr">preserve:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">lvm_volgroup</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">lvm_volgroup-0</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ubuntu-lv</span></span><br><span class="line">      <span class="attr">volgroup:</span> <span class="string">lvm_volgroup-0</span></span><br><span class="line">      <span class="attr">size:</span> <span class="string">10737418240B</span></span><br><span class="line">      <span class="attr">wipe:</span> <span class="string">superblock</span></span><br><span class="line">      <span class="attr">preserve:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">lvm_partition</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">lvm_partition-0</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">fstype:</span> <span class="string">ext4</span></span><br><span class="line">      <span class="attr">volume:</span> <span class="string">lvm_partition-0</span></span><br><span class="line">      <span class="attr">preserve:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">format</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">format-2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">device:</span> <span class="string">format-2</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">mount</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">mount-2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/boot</span></span><br><span class="line">      <span class="attr">device:</span> <span class="string">format-1</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">mount</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">mount-1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/boot/efi</span></span><br><span class="line">      <span class="attr">device:</span> <span class="string">format-0</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">mount</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">mount-0</span></span><br><span class="line">  <span class="attr">updates:</span> <span class="string">security</span></span><br></pre></td></tr></table></figure>

<p>备注：late-commands 等中的字符串在传递给执行安装的主机时，有些特殊字符串需要特殊处理。</p>
</li>
<li><p>生成所需要的文件 <em>meta-data</em> （空文件即可），执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> /var/www/html/jammy/meta-data</span><br></pre></td></tr></table></figure>
</li>
<li><p>供应商数据文件 <em>vendor-data</em> 非必需，可不管。</p>
</li>
<li><p>确保目录 <em>&#x2F;var&#x2F;www&#x2F;html&#x2F;jammy&#x2F;</em> 下的文件对所有人可读：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> -R a+r /var/www/html/jammy/</span><br></pre></td></tr></table></figure></li>
</ol>
<p>上述各项含义参见： <a target="_blank" rel="noopener" href="https://hmli.ustc.edu.cn/doc/linux/ubuntu-autoinstall/ubuntu-autoinstall.html#reference">自动服务器安装配置文件参考</a> 。</p>
<p>备注：做好上述工作后，同一子网内的客户机启动采用PXE引导时，即可自动安装配置所需要的系统。</p>
<h1 id="自动服务器安装配置文件参考"><a href="#自动服务器安装配置文件参考" class="headerlink" title="自动服务器安装配置文件参考"></a>自动服务器安装配置文件参考</h1><h2 id="整体格式-Overall-format"><a href="#整体格式-Overall-format" class="headerlink" title="整体格式(Overall format)"></a>整体格式(Overall format)</h2><p>自动安装 <strong>autoinstall</strong> 文件是 <strong>YAML</strong> 格式的。在顶层，它必须是包含本文档中描述的关键字 <strong>key</strong> 的映射。无法识别的关键字将被忽略。</p>
<h2 id="概要-Schema"><a href="#概要-Schema" class="headerlink" title="概要(Schema)"></a>概要(Schema)</h2><p>自动安装配置在使用前会根据 <strong>JSON</strong> 模式进行转换并进行验证。</p>
<h2 id="命令列表-Command-lists"><a href="#命令列表-Command-lists" class="headerlink" title="命令列表(Command lists)"></a>命令列表(Command lists)</h2><p>几个配置关键字是要执行的命令列表。每个命令可以是字符串（在这种情况下通过 <code>sh -c</code> 执行）或列表，在这种情况下直接执行。任何以非零返回码退出的命令都被视为错误并中止安装（错误命令除外，它被忽略）。</p>
<h2 id="顶级关键字-Top-level-keys"><a href="#顶级关键字-Top-level-keys" class="headerlink" title="顶级关键字(Top-level keys)"></a>顶级关键字(Top-level keys)</h2><ul>
<li><p>version</p>
<ul>
<li><p>名称：版本</p>
</li>
<li><p>类型：整型</p>
</li>
<li><p>默认值：无</p>
<p>为将来不同版本准备的版本信息，目前只能为 <strong>1</strong> 。</p>
</li>
</ul>
</li>
<li><p>interactive-sections</p>
<ul>
<li><p>名称：交互式部分</p>
</li>
<li><p>类型：字符串列表</p>
</li>
<li><p>默认值：[]</p>
<p>仍然显示在用户界面 <strong>UI</strong> 中的配置键列表，如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">interactive-sections:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">network</span></span><br><span class="line"><span class="attr">identity:</span></span><br><span class="line"> <span class="attr">username:</span> <span class="string">ubuntu</span></span><br><span class="line"> <span class="attr">password:</span> <span class="string">$crypted_pass</span></span><br></pre></td></tr></table></figure>

<p>交互式操作，将在网络屏幕上停止并允许用户更改默认值。如果为交互式部分提供了值，则将其用作默认值。</p>
<p>可以使用特殊的块名称 “*” 来指示安装程序应该询问所有常见问题——在这种情况下，文件 <code>autoinstall.yaml </code>根本不是真正的“自动安装”文件，而只是一种用于更改用户界面中的默认值的文件。</p>
<p>并非所有配置关键字都对应于用户界面中的屏幕。该文档指示给定块是否可以交互。</p>
<p>如果有任何交互块，则忽略报告关键字 <strong>reporting</strong> 。</p>
</li>
</ul>
</li>
<li><p>early-commands</p>
<ul>
<li><p>名称：早期命令</p>
</li>
<li><p>默认值：无</p>
</li>
<li><p>是否可交互：不可</p>
<p>安装程序启动后立即调用的shell命令列表，特别是在执行探测块和网络设备操作之前执行。自动安装配置在 <em>&#x2F;autoinstall.yaml</em> 中可用（不管它是如何被提供），并且在早期命令 <strong>early-commands</strong> 运行后将重新读取该文件，以允许它们在必要时更改配置。</p>
</li>
</ul>
</li>
<li><p>locale</p>
<p>名称：语言环境</p>
<p>类型：字符串</p>
<p>默认值：en_US.UTF-8</p>
<p>是否可交互：可，对于任何块中是的话，总是可以交互</p>
<p>为已安装系统配置的语言环境。</p>
</li>
<li><p>refresh-installer</p>
<ul>
<li>名称：更新安装</li>
<li>类型：映射</li>
<li>默认值：参见下面</li>
<li>是否可交互：可</li>
</ul>
<p>控制安装程序在继续之前是否更新到给定频道 channel 中可用的新版本。</p>
<p>映射包含关键字：</p>
<ul>
<li><p>update</p>
<ul>
<li>名称：更新</li>
<li>类型：布尔型</li>
<li>默认值：无</li>
</ul>
<p>控制是否执行系统更新。</p>
</li>
<li><p>channel</p>
<ul>
<li>名称：频道、通道</li>
<li>类型：字符串</li>
<li>默认值：stable&#x2F;ubuntu-$REL</li>
</ul>
<p>用于检查系统更新的频道。</p>
</li>
</ul>
</li>
<li><p>keyboard</p>
<ul>
<li>名称：键盘</li>
<li>类型：映射，参见下面</li>
<li>默认值：US English keyboard</li>
<li>是否可交互：可</li>
</ul>
<p>任何附属键盘的布局。通常自动安装的系统根本没有键盘，在这种情况下，此处使用的值无关紧要。</p>
<p>映射的关键字对应于 <em>&#x2F;etc&#x2F;default&#x2F;keyboard</em> 配置文件中的设置。有关更多详细信息，请参阅其手册页。</p>
<p>映射包含关键字：</p>
<ul>
<li><p>layout</p>
<ul>
<li>名称：布局</li>
<li>类型：字符串</li>
<li>默认值：us</li>
</ul>
<p>对应于键盘 <strong>XKBLAYOUT</strong> 设置。</p>
</li>
<li><p>variant</p>
<ul>
<li><p>名称：变种</p>
</li>
<li><p>类型：字符串</p>
</li>
<li><p>默认值：””</p>
</li>
</ul>
<p>对应于键盘 <strong>XKBVARIANT</strong> 设置。</p>
</li>
<li><p>toggle</p>
<ul>
<li>名称：切换</li>
<li>类型：字符串或null</li>
<li>默认值：null</li>
</ul>
<p>对应于 <strong>grp</strong> 值: 来自键盘 <strong>XKBOPTIONS</strong> 设置的选项的值。可接受的值是（但请注意，安装程序不会验证这些）：caps_toggle、toggle、rctrl_toggle、rshift_toggle、rwin_toggle、menu_toggle、alt_shift_toggle、ctrl_shift_toggle、ctrl_alt_toggle、alt_caps_toggle、lctrl_lshift_toggle、lalt_toggle、lctrl_toggle、lwinshift_toggle</p>
</li>
</ul>
<p>与20.04 GA一起发布的 <strong>subiquity</strong> 版本由于一个bug不接受该字段为null。</p>
</li>
<li><p>network</p>
<ul>
<li>名称：网络</li>
<li>类型：netplan-format映射，参看下面</li>
<li>默认值：用于DHCP协议的名字为eth<em>en</em>的网卡</li>
<li>是否可交互：可</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://netplan.io/reference?_ga=2.114730432.698614161.1664162991-1711338095.1646124381">netplan</a> 格式的网络配置。将在安装期间以及已安装的系统中应用。默认是解释安装媒介的配置，它在名称匹配 <strong>“eth*”</strong> 或 <strong>“en*”</strong> 的任何网卡上运行 <strong>DHCPv4</strong> 请求，并随后禁用任何未获取到IP地址的网卡。</p>
<p>例如，要在特定网卡 <strong>enp0s31f6</strong> 上运行 <strong>dhcp6</strong> 请求：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">ethernets:</span></span><br><span class="line">    <span class="attr">enp0s31f6:</span></span><br><span class="line">      <span class="attr">dhcp6:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>

<p>请注意，由于一个错误，随 <strong>20.04 GA</strong> 发布的 <strong>subiquity</strong> 版本强制您使用额外的 <strong>“network:”</strong> 关键字编写此代码，如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line"><span class="comment">#多了上一层network:</span></span><br><span class="line">  <span class="attr">network:</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">ethernets:</span></span><br><span class="line">      <span class="attr">enp0s31f6:</span></span><br><span class="line">        <span class="attr">dhcp6:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>

<p>更高版本也支持此语法（以实现兼容性），但如果可以确定采用修复后的新版本，则应使用前者（无需使用额外的 <strong>“network:”</strong> 关键字）。</p>
</li>
<li><p>proxy</p>
<ul>
<li>名称：代理</li>
<li>类型：URL或null</li>
<li>默认值：null</li>
<li>是否可交互：可</li>
</ul>
<p>在安装期间以及在目标系统中为 <strong>apt</strong> 和 <strong>snapd</strong> 配置的代理，以便访问网络。</p>
</li>
<li><p>apt</p>
<ul>
<li>名称：APT高级包管理工具</li>
<li>类型：映射</li>
<li>默认值：参看下面</li>
<li>是否可交互：可</li>
</ul>
<p>APT配置，在安装期间和引导到目标系统后都使用。</p>
<p>这使用与 <a target="_blank" rel="noopener" href="https://curtin.readthedocs.io/en/latest/topics/apt_source.html">https://curtin.readthedocs.io/en/latest/topics/apt_source.html</a> 中描述的 <strong>curtin</strong> (the curt installer) 安装格式相同的格式，但有一个扩展：关键字 <strong>geoip</strong> 控制是否完成地理IP(geoip)查找。</p>
<p>默认值为：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apt:</span></span><br><span class="line">    <span class="attr">preserve_sources_list:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">primary:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">arches:</span> [<span class="string">i386</span>, <span class="string">amd64</span>]</span><br><span class="line">          <span class="attr">uri:</span> <span class="string">&quot;http://archive.ubuntu.com/ubuntu&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">arches:</span> [<span class="string">default</span>]</span><br><span class="line">          <span class="attr">uri:</span> <span class="string">&quot;http://ports.ubuntu.com/ubuntu-ports&quot;</span></span><br><span class="line">    <span class="attr">geoip:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>如关键字 <strong>geoip</strong> 为 <strong>true</strong> 并且要使用的镜像源是默认值（ <strong><a target="_blank" rel="noopener" href="http://archive.ubuntu.com/ubuntu">http://archive.ubuntu.com/ubuntu</a></strong> 或 <strong><a target="_blank" rel="noopener" href="http://ports.ubuntu.com/ubuntu-ports">http://ports.ubuntu.com/ubuntu-ports</a></strong> 等），则向 <strong><a target="_blank" rel="noopener" href="https://geoip.ubuntu.com/lookup">https://geoip.ubuntu.com/lookup</a></strong> 发出请求，并且将使用的镜像URI更改为 <strong><a target="_blank" rel="noopener" href="http://cc.archive.ubuntu.com/ubuntu">http://CC.archive.ubuntu.com/ubuntu</a></strong> , 其中 <strong>CC</strong> 是查找返回的国家代码（或类似的端口，对于中国为 <strong>CN</strong> ），这将使用所在国家区域的源，提升网络更新速度。如果此部分不是交互式的，则请求会在10秒后超时。</p>
<p>任何提供的配置都会与默认配置合并，而不是替换它。</p>
<p>如果您只想设置镜像源，请使用如下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apt:</span></span><br><span class="line">    <span class="attr">primary:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">arches:</span> [<span class="string">default</span>]</span><br><span class="line">          <span class="attr">uri:</span> <span class="string">YOUR_MIRROR_GOES_HERE</span></span><br></pre></td></tr></table></figure>

<p>增加一个 <strong>PPA</strong> 源：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apt:</span></span><br><span class="line">    <span class="attr">sources:</span></span><br><span class="line">        <span class="attr">curtin-ppa:</span></span><br><span class="line">            <span class="attr">source:</span> <span class="string">ppa:curtin-dev/test-archive</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>storage</p>
<ul>
<li>名称：存储</li>
<li>类型：映射，参看下面</li>
<li>默认值：对于单块硬盘为 <strong>lvm</strong> ，对于多块硬盘则无默认值</li>
<li>是否可交互：可</li>
</ul>
<p>存储配置是一个复杂的话题，自动安装文件中所需配置的描述也可能很复杂。安装程序支持“布局layouts”，即表达常见配置的简单方法。</p>
<ul>
<li><p>支持的布局</p>
<p>目前支持的布局就两种，分别是逻辑卷模式 <strong>lvm</strong> 和直通模式 <strong>direct</strong> 。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">layout:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">lvm</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">layout:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">direct</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，这些将安装到系统中容量最大的磁盘，但您可以提供匹配规范（“match: {}”，见下文）来指示要使用的磁盘：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">layout:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">lvm</span></span><br><span class="line">    <span class="attr">match:</span></span><br><span class="line">      <span class="attr">serial:</span> <span class="string">CT*</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">layout:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">disk</span></span><br><span class="line">    <span class="attr">match:</span></span><br><span class="line">      <span class="attr">ssd:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>

<p>（可以用“match: {}”来匹配任意磁盘）</p>
<p>默认采用 <strong>lvm</strong> 。</p>
</li>
<li><p>基于动作的配置</p>
<p>为了获得完全的灵活性，安装程序允许使用一种语法完成存储配置，该语法是 <strong>curtin</strong> 支持的语法的超集，在 <a target="_blank" rel="noopener" href="https://curtin.readthedocs.io/en/latest/topics/storage.html">https://curtin.readthedocs.io/en/latest/topics/storage.html</a> 中进行了描述。</p>
<p>如果使用 <strong>layout</strong> 功能配置磁盘，则不会使用 <strong>config</strong> 部分。</p>
<p>除了将操作列表放在关键字 <strong>config</strong> 下之外， <a target="_blank" rel="noopener" href="https://curtin.readthedocs.io/en/latest/topics/config.html#grub">grub</a> 和 <a target="_blank" rel="noopener" href="https://curtin.readthedocs.io/en/latest/topics/config.html#swap">swap</a> curtin配置项也可以放在此处。因此存储部分可能如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">storage:</span></span><br><span class="line">    <span class="attr">swap:</span></span><br><span class="line">        <span class="attr">size:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">disk</span></span><br><span class="line">          <span class="attr">id:</span> <span class="string">disk0</span></span><br><span class="line">          <span class="attr">serial:</span> <span class="string">ADATA_SX8200PNP_XXXXXXXXXXX</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">partition</span></span><br><span class="line">          <span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>Curtin语法的扩展围绕磁盘选择和分区&#x2F;逻辑卷大小调整。</p>
</li>
<li><p>磁盘选择扩展</p>
<p>Curtin支持通过串行（如 <em>Crucial_CT512MX100SSD1_14250C57FECE</em> ）或路径（如 <em>&#x2F;dev&#x2F;sdc</em> ）识别磁盘，服务器安装程序也支持这一点。安装程序还支持磁盘操作上的 <strong>match spec</strong> ，支持更灵活的匹配。</p>
<p>存储配置中的操作按照它们在自动安装文件中的顺序进行处理。任何磁盘操作都会被分配一个匹配的磁盘——如果有多个磁盘，则从一组未分配的磁盘中任意选择，如果没有未分配的匹配磁盘，则会导致安装失败。</p>
<p>匹配规范支持以下关键字： - <strong>model: foo</strong> ：匹配 <strong>udev</strong> 中 <strong>ID_VENDOR&#x3D;foo</strong> 的磁盘，支持通配符 - <strong>path: foo</strong> ：匹配 <strong>udev</strong> 中 <strong>DEVPATH&#x3D;foo</strong> 的磁盘，支持通配符（通配符支持将此与直接在磁盘操作中指定 <strong>path: foo</strong> 区分开来） - <strong>serial: foo</strong> ：匹配 <strong>udev</strong> 中 <strong>ID_SERIAL&#x3D;foo</strong> 的磁盘，支持通配符（通配符支持将此与直接在磁盘操作中指定 <strong>serial: foo</strong> 区分开来） - <strong>ssd: yes|no</strong> ：匹配是或不是 <strong>SSD</strong> 的磁盘（相对于机械硬盘） - <strong>size: largest|smallest</strong> ：如果有多个匹配项，则取最大或最小的磁盘而不是任意一个（在 20.06.1 版本中添加了对最小 <strong>smallest</strong> 的支持）</p>
<p>因此，例如，要匹配任意磁盘，只需：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">disk</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">disk0</span></span><br></pre></td></tr></table></figure>

<p>匹配容量最大的SSD硬盘：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">disk</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">big-fast-disk</span></span><br><span class="line">  <span class="attr">match:</span></span><br><span class="line">    <span class="attr">ssd:</span> <span class="literal">yes</span></span><br><span class="line">    <span class="attr">size:</span> <span class="string">largest</span></span><br></pre></td></tr></table></figure>

<p>匹配希捷Seagate硬盘：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">disk</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">data-disk</span></span><br><span class="line">  <span class="attr">match:</span></span><br><span class="line">    <span class="attr">model:</span> <span class="string">Seagate</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分区&#x2F;逻辑卷扩展</p>
<p>curtin中的分区或逻辑卷的大小指定为字节数。自动安装配置更加灵活：</p>
<ul>
<li>您可以使用安装程序用户界面中支持的“1G”、“512M”语法指定大小</li>
<li>您可以将大小指定为包含磁盘（或RAID）的百分比，例如“50%”</li>
<li>对于为特定设备指定的最后一个分区，您可以将大小指定为“-1”以指示该分区应填充剩余空间。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">partition</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">boot-partition</span></span><br><span class="line">  <span class="attr">device:</span> <span class="string">root-disk</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">10</span><span class="string">%</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">partition</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">root-partition</span></span><br><span class="line">  <span class="attr">size:</span> <span class="string">20G</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">partition</span></span><br><span class="line">  <span class="attr">id:</span> <span class="string">data-partition</span></span><br><span class="line">  <span class="attr">device:</span> <span class="string">root-disk</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>identity</p>
<ul>
<li>名称：身份</li>
<li>类型：映射，参看下面</li>
<li>默认值：无</li>
<li>是否可交互：可</li>
</ul>
<p>配置系统的初始用户。这是唯一必须存在的配置关键字（除非存在用户数据部分，在这种情况下它是可选的）。</p>
<p>可以包含关键字的映射，所有关键字都采用字符串值：</p>
<ul>
<li>realname：实际名</li>
<li>username：用户名</li>
<li>hostname： 主机名</li>
<li>password：密码，加密的。这是与 sudo 一起使用时所必需的，即使配置了 SSH 访问。</li>
</ul>
</li>
<li><p>ssh</p>
<ul>
<li>名称： <strong>SSH</strong> 服务</li>
<li>类型：映射，参看下面</li>
<li>默认值：参看下面</li>
<li>是否可交互：可</li>
</ul>
<p>为已安装的系统配置 <strong>SSH</strong> 服务。可以包含关键字的映射：</p>
<ul>
<li><p>install-server</p>
<ul>
<li>名称：安装 <strong>SSH</strong> 服务</li>
<li>类型：布尔型</li>
<li>默认值：false，不安装</li>
</ul>
<p>是否安装 <strong>OpenSSH</strong> 服务。</p>
</li>
<li><p>authorized-keys</p>
<ul>
<li>名称： <strong>SSH</strong> 认证公钥</li>
<li>类型：字符串列表</li>
<li>默认值：[]</li>
</ul>
<p>要安装在初始用户帐户中的 SSH 公钥列表，方便其他主机采用密钥通过 <strong>SSH</strong> 访问该主机。</p>
</li>
<li><p>allow-pw</p>
<ul>
<li>名称：是否允许密码</li>
<li>类型：布尔型</li>
<li>默认值：当 <strong>authorized_keys</strong> 为空时为真 <strong>true</strong> ，否则为否 <strong>false</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>snaps</p>
<ul>
<li>名称：snap包</li>
<li>类型：列表</li>
<li>默认值：不安装其他snap</li>
<li>是否可交互：可</li>
</ul>
<p>要安装的snap包列表。每个snap都表示为具有必需的关键字 <strong>name</strong> 和可选的关键字 <strong>chanel</strong> （默认为 <strong>stable</strong> ）和 <strong>classic</strong> （经典默认为 <strong>false</strong> ）的映射。如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">snaps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">etcd</span></span><br><span class="line">      <span class="attr">channel:</span> <span class="string">edge</span></span><br><span class="line">      <span class="attr">classic:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>debconf-selections</p>
<ul>
<li>名称：采用 <strong>debconf</strong> 设置包选择</li>
<li>类型：字符串</li>
<li>默认值：无</li>
<li>是否可交互：否</li>
</ul>
<p>安装程序将使用 <strong>debconf</strong> 设置选择值更新目标。用户需要熟悉软件包 <strong>debconf</strong> 选项。</p>
</li>
<li><p>packages</p>
<ul>
<li>名称：软件包</li>
<li>类型：列表</li>
<li>默认值：无软件包</li>
<li>是否可交互：否</li>
</ul>
<p>要安装到目标系统中的软件包列表。更准确地说，是传递给命令 <code>apt-get install</code> 的字符串列表，因此这包括任务选择（ <strong>dns-server^</strong> ）和安装特定版本的包（ <strong>my-package&#x3D;1-1</strong> ）。</p>
</li>
<li><p>late-commands</p>
<ul>
<li>名称：后期命令</li>
<li>类型：命令列表</li>
<li>默认值：无命令</li>
<li>是否可交互：否</li>
</ul>
<p>在安装成功完成并安装任何更新和软件包之后运行的 Shell 命令，就在系统重新启动之前。它们在安装程序环境中运行，已安装的系统安装在目录 <em>&#x2F;target</em> 。您可以运行 <code>curtin in-target -- $shell_command</code> （使用20.04 GA发布的subiquity安装程序版本，采用 <strong>curtin</strong> 格式，您需要将其指定为 <code>curtin in-target --target=/target -- $shell_command</code> ）以在目标系统中运行（类似了解如何在 <strong>d-i preseed&#x2F;late_command</strong> 中使用简单的目标内）。</p>
</li>
<li><p>error-commands</p>
<ul>
<li>名称：出错处理命令</li>
<li>类型：命令列表</li>
<li>默认值：无命令</li>
<li>是否可交互：否</li>
</ul>
<p>安装失败后运行的Shell命令。它们在安装程序环境中运行，并且目标系统（或安装程序设法配置的尽可能多的系统）将安装在目录 <em>&#x2F;target</em> 。日志将在实时会话中的目录 <em>&#x2F;var&#x2F;log&#x2F;installer</em> 中可用。</p>
</li>
<li><p>reporting</p>
<ul>
<li>名称：报告</li>
<li>类型：映射</li>
<li>默认值： <strong>type: print</strong> ，导致tty1和任何已配置的串行控制台上的输出</li>
<li>是否可交互：否</li>
</ul>
<p>安装程序支持向各种目的地报告进度。请注意，如果有任何交互部分，则忽略此部分；它仅适用于全自动安装。</p>
<p>配置，实际上实现，与<a target="_blank" rel="noopener" href="https://curtin.readthedocs.io/en/latest/topics/reporting.html">curtin使用</a>的90%相同。</p>
<p>配置中报告映射中的每个键都定义了一个目标，其中子关键字 <strong>type</strong> 是以下之一：</p>
<p>（原文在该处有 <strong>The rsyslog reporter does not yet exist</strong> ，没理解为什么在这个位置说这个，也不清楚什么含义）</p>
<ul>
<li><strong>print</strong> ：在tty1和任何配置的串行控制台上打印进度信息。没有其他配置。</li>
<li><strong>rsyslog</strong> ：通过rsyslog报告进度。目标键指定将输出发送到何处。</li>
<li><strong>webhook</strong> ：通过将JSON报告发布到 URL 来报告进度。接受与curtin相同的配置。</li>
<li><strong>none</strong> ：不报告进度。仅对禁止默认输出有用。</li>
</ul>
<p>例子：</p>
<p>默认配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">reporting:</span></span><br><span class="line"> <span class="attr">builtin:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">print</span></span><br></pre></td></tr></table></figure>

<p>输出到 <strong>rsyslog</strong> ：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">reporting:</span></span><br><span class="line"> <span class="attr">central:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">rsyslog</span></span><br><span class="line">  <span class="attr">destination:</span> <span class="string">@192.168.0.1</span></span><br></pre></td></tr></table></figure>

<p>抑制默认输出：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">reporting:</span></span><br><span class="line"> <span class="attr">builtin:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">none</span></span><br></pre></td></tr></table></figure>

<p>输出到 <strong>curtin</strong> 样式的 <strong>webhook</strong> ：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">reporting:</span></span><br><span class="line"> <span class="attr">hook:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">webhook</span></span><br><span class="line">  <span class="attr">endpoint:</span> <span class="string">http://example.com/endpoint/path</span></span><br><span class="line">  <span class="attr">consumer_key:</span> <span class="string">&quot;ck_foo&quot;</span></span><br><span class="line">  <span class="attr">consumer_secret:</span> <span class="string">&quot;cs_foo&quot;</span></span><br><span class="line">  <span class="attr">token_key:</span> <span class="string">&quot;tk_foo&quot;</span></span><br><span class="line">  <span class="attr">token_secret:</span> <span class="string">&quot;tk_secret&quot;</span></span><br><span class="line">  <span class="attr">level:</span> <span class="string">INFO</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>user-data</p>
<ul>
<li>名称：用户数据</li>
<li>类型：映射</li>
<li>默认值：{}</li>
<li>是否可交互：否</li>
</ul>
<p>提供 <strong>cloud-init</strong> 用户数据，它将与安装程序生成的用户数据 <strong>user-data</strong> 合并。如果您提供此信息，则无需提供身份 ** identity** 部分（但您有责任确保您可以登录到已安装的系统！）。</p>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>网络启动： <a target="_blank" rel="noopener" href="https://ubuntu.com/server/docs/install/netboot-amd64">https://ubuntu.com/server/docs/install/netboot-amd64</a></li>
<li>自动安装： <a target="_blank" rel="noopener" href="https://ubuntu.com/server/docs/install/autoinstall">https://ubuntu.com/server/docs/install/autoinstall</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block ljk-index-post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/%E8%BF%90%E7%BB%B4/%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AE%89%E5%85%A8/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/%E8%BF%90%E7%BB%B4/%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AE%89%E5%85%A8/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="post-title-link" itemprop="url">加密和安全</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-09 23:02:30" itemprop="dateCreated datePublished" datetime="2022-12-09T23:02:30+08:00">2022-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-29 16:58:05" itemprop="dateModified" datetime="2023-05-29T16:58:05+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%90%E7%BB%B4/" itemprop="url" rel="index"><span itemprop="name">运维</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%90%E7%BB%B4/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">基础</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%90%E7%BB%B4/%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E5%92%8C%E5%AE%89%E5%85%A8/" itemprop="url" rel="index"><span itemprop="name">加密和安全</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h2><p>加密：数据使用对称加密，对称加密的密钥使用公钥加密</p>
<p><img data-src="//img.to2b.cn/blog/lujinkai/1666495876939.png"></p>
<p>解密：先使用私钥解密 AES 密钥，然后用 AES 密钥解密数据</p>
<p><img data-src="//img.to2b.cn/blog/lujinkai/1666495942356.png"></p>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>计算数据的哈希值，然后对哈希值使用私钥加密，就得到了 <strong>数字签名</strong></p>
<p><img data-src="//img.to2b.cn/blog/lujinkai/1666495976092.png"></p>
<h2 id="数据加密-数字签名"><a href="#数据加密-数字签名" class="headerlink" title="数据加密+数字签名"></a>数据加密+数字签名</h2><p>数据加密 无法验证数据完整性和来源。</p>
<p>数字加密 + 数字签名，既实现数据加密，又可以保证数据来源的可靠性、数据的完整性和一致性。</p>
<p>加密：</p>
<p><img data-src="//img.to2b.cn/blog/lujinkai/1666499276529.png"></p>
<p>解密：</p>
<p><img data-src="//img.to2b.cn/blog/lujinkai/1666500708643.png"></p>
<p>得到原文与原文哈希，然后计算原文哈希，与传过来的原文哈希进行对比，如果一致，说明原文是完整可靠的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">鲁ICP备18016600号-3 </a>
  </div>

<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">像方便面一样的男子</span>
</div>

    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="//s1.lujinkai.cn/libs/animejs/3.2.1/anime.min.js"></script>
  <script src="//s1.lujinkai.cn/libs/lozad.js/1.16.0/lozad.min.js"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  <script src="//s1.lujinkai.cn/libs/algoliasearch/4.11.0/algoliasearch-lite.umd.min.js"></script>
<script src="//s1.lujinkai.cn/libs/instantsearch.js/4.36.0/instantsearch.production.min.js"></script><script src="/js/third-party/search/algolia-search.js"></script>






  





</body>
</html>
