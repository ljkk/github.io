<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="//img.lujinkai.cn/blog/ljk/1607154764582.png">
  <link rel="icon" type="image/png" sizes="32x32" href="//img.lujinkai.cn/blog/ljk/1607154764582.png">
  <link rel="icon" type="image/png" sizes="16x16" href="//img.lujinkai.cn/blog/ljk/1607154764582.png">
  <link rel="mask-icon" href="//img.lujinkai.cn/blog/ljk/1607154764582.png" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//s1.lujinkai.cn/libs/fontawesome-free/5.15.4/css/all.min.css">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.lujinkai.cn","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":10},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"KN3H1V8A6V","apiKey":"c5d73d0dde2dd770ce49b505f938553d","indexName":"hexo","hits":{"per_page":20,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We did not find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}}}}</script><script src="/js/config.js"></script>

    <meta name="description" content="基础模板语法attribute&amp;#123;&amp;#123;&amp;#125;&amp;#125;不能在 HTML attributes 中使用。想要响应式的绑定一个 attribute，应该使用v-bind指令是： 1&lt;div v-bind:id&#x3D;&quot;dynamicId&quot;&gt;&lt;&#x2F;div&gt;  因为v-bind非常常用，我们提供了特定的简写语法： 1&lt;div :id&#x3D;&amp;qu">
<meta property="og:type" content="article">
<meta property="og:title" content="快速开始">
<meta property="og:url" content="http://blog.lujinkai.cn/%E5%89%8D%E7%AB%AF/Vue3/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/index.html">
<meta property="og:site_name" content="LJKのBlog">
<meta property="og:description" content="基础模板语法attribute&amp;#123;&amp;#123;&amp;#125;&amp;#125;不能在 HTML attributes 中使用。想要响应式的绑定一个 attribute，应该使用v-bind指令是： 1&lt;div v-bind:id&#x3D;&quot;dynamicId&quot;&gt;&lt;&#x2F;div&gt;  因为v-bind非常常用，我们提供了特定的简写语法： 1&lt;div :id&#x3D;&amp;qu">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.to2b.cn/blog/ljk/1676878242776.png">
<meta property="og:image" content="http://img.to2b.cn/blog/ljk/1677055310606.png">
<meta property="og:image" content="http://img.to2b.cn/blog/ljk/1677055853340.png">
<meta property="og:image" content="http://img.to2b.cn/blog/ljk/1677062368602.png">
<meta property="og:image" content="http://img.to2b.cn/blog/ljk/1677062470008.png">
<meta property="article:published_time" content="2023-02-23T07:45:05.000Z">
<meta property="article:modified_time" content="2023-05-29T08:58:22.370Z">
<meta property="article:author" content="像方便面一样的男子">
<meta property="article:tag" content="vue3">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.to2b.cn/blog/ljk/1676878242776.png">


<link rel="canonical" href="http://blog.lujinkai.cn/%E5%89%8D%E7%AB%AF/Vue3/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://blog.lujinkai.cn/%E5%89%8D%E7%AB%AF/Vue3/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/","path":"前端/Vue3/快速开始/","title":"快速开始"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>快速开始 | LJKのBlog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">LJKのBlog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">学无止境</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">模板语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#attribute"><span class="nav-number">1.1.1.</span> <span class="nav-text">attribute</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-js-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.1.2.</span> <span class="nav-text">使用 js 表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4"><span class="nav-number">1.1.3.</span> <span class="nav-text">指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9F%BA%E7%A1%80"><span class="nav-number">1.2.</span> <span class="nav-text">响应式基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#reactive"><span class="nav-number">1.2.1.</span> <span class="nav-text">reactive()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lt-script-setup-gt"><span class="nav-number">1.2.2.</span> <span class="nav-text">&lt;script setup&gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DOM-%E6%9B%B4%E6%96%B0%E6%97%B6%E6%9C%BA"><span class="nav-number">1.2.3.</span> <span class="nav-text">DOM 更新时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%B1%82%E5%93%8D%E5%BA%94%E6%80%A7"><span class="nav-number">1.2.4.</span> <span class="nav-text">深层响应性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E4%BB%A3%E7%90%86-vs-%E5%8E%9F%E5%A7%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.5.</span> <span class="nav-text">响应式代理 vs 原始对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reactive-%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number">1.2.6.</span> <span class="nav-text">reactive()的局限性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ref"><span class="nav-number">1.2.7.</span> <span class="nav-text">ref()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ref-%E5%9C%A8%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%8C%85"><span class="nav-number">1.2.8.</span> <span class="nav-text">ref 在模板中的解包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ref-%E5%9C%A8%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E8%A7%A3%E5%8C%85"><span class="nav-number">1.2.9.</span> <span class="nav-text">ref 在响应式对象中的解包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84-ref-%E8%A7%A3%E5%8C%85"><span class="nav-number">1.2.10.</span> <span class="nav-text">数组和集合类型的 ref 解包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="nav-number">1.3.</span> <span class="nav-text">计算属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%BC%93%E5%AD%98-vs-%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">计算属性缓存 vs 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%86%99%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="nav-number">1.3.2.</span> <span class="nav-text">可写计算属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">1.3.3.</span> <span class="nav-text">最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Getter-%E4%B8%8D%E5%BA%94%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">Getter 不应有副作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%80%BC"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">避免直接修改计算属性值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class-%E4%B8%8E-Style-%E7%BB%91%E5%AE%9A"><span class="nav-number">1.4.</span> <span class="nav-text">Class 与 Style 绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A-HTML-class"><span class="nav-number">1.4.1.</span> <span class="nav-text">绑定 HTML class</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">绑定对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E6%95%B0%E7%BB%84"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">绑定数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">在组件上使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%86%85%E8%81%94%E6%A0%B7%E5%BC%8F"><span class="nav-number">1.4.2.</span> <span class="nav-text">绑定内联样式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%AF%B9%E8%B1%A1-1"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">绑定对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E6%95%B0%E7%BB%84-1"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">绑定数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%89%8D%E7%BC%80"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">自动前缀</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%B7%E5%BC%8F%E5%A4%9A%E5%80%BC"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">样式多值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="nav-number">1.5.</span> <span class="nav-text">条件渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#v-if"><span class="nav-number">1.5.1.</span> <span class="nav-text">v-if</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#v-show"><span class="nav-number">1.5.2.</span> <span class="nav-text">v-show</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#v-if-%E5%92%8C-v-show"><span class="nav-number">1.5.3.</span> <span class="nav-text">v-if 和 v-show</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93"><span class="nav-number">1.6.</span> <span class="nav-text">列表渲染</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#v-for"><span class="nav-number">1.6.1.</span> <span class="nav-text">v-for</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#v-for-%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.6.2.</span> <span class="nav-text">v-for 与对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8-v-for-%E9%87%8C%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4%E5%80%BC"><span class="nav-number">1.6.3.</span> <span class="nav-text">在 v-for 里使用范围值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lt-template-gt-%E4%B8%8A%E7%9A%84-v-for"><span class="nav-number">1.6.4.</span> <span class="nav-text">&lt;template&gt; 上的 v-for</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#v-for-%E5%92%8C-v-if"><span class="nav-number">1.6.5.</span> <span class="nav-text">v-for 和 v-if</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-key-%E7%AE%A1%E7%90%86%E7%8A%B6%E6%80%81"><span class="nav-number">1.6.6.</span> <span class="nav-text">通过 key 管理状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8v-for"><span class="nav-number">1.6.7.</span> <span class="nav-text">组件上使用v-for</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B"><span class="nav-number">1.6.8.</span> <span class="nav-text">数组变化侦测</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%98%E6%9B%B4%E6%96%B9%E6%B3%95"><span class="nav-number">1.6.8.1.</span> <span class="nav-text">变更方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9B%BF%E6%8D%A2%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="nav-number">1.6.8.2.</span> <span class="nav-text">替换一个数组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%95%E7%A4%BA%E8%BF%87%E6%BB%A4%E6%88%96%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="nav-number">1.6.9.</span> <span class="nav-text">展示过滤或排序后的结果</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="nav-number">1.7.</span> <span class="nav-text">事件处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.7.1.</span> <span class="nav-text">监听事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%81%94%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">1.7.2.</span> <span class="nav-text">内联事件处理器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">1.7.3.</span> <span class="nav-text">方法事件处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%8E%E5%86%85%E8%81%94%E4%BA%8B%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">方法与内联事件判断</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E5%86%85%E8%81%94%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%AD%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.7.4.</span> <span class="nav-text">在内联处理器中调用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E5%86%85%E8%81%94%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%AD%E8%AE%BF%E9%97%AE%E4%BA%8B%E4%BB%B6%E5%8F%82%E6%95%B0"><span class="nav-number">1.7.5.</span> <span class="nav-text">在内联事件处理器中访问事件参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.7.6.</span> <span class="nav-text">事件修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.7.7.</span> <span class="nav-text">按键修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%89%E9%94%AE%E5%88%AB%E5%90%8D"><span class="nav-number">1.7.7.1.</span> <span class="nav-text">按键别名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.7.7.2.</span> <span class="nav-text">系统按键修饰符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#exact%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.7.7.3.</span> <span class="nav-text">.exact修饰符</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BC%A0%E6%A0%87%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.7.8.</span> <span class="nav-text">鼠标按键修饰符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E4%B8%8E%E7%BB%91%E5%AE%9A"><span class="nav-number">1.8.</span> <span class="nav-text">表单输入与绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%BB%91%E5%AE%9A"><span class="nav-number">1.8.1.</span> <span class="nav-text">值绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E9%80%89%E6%A1%86"><span class="nav-number">1.8.2.</span> <span class="nav-text">复选框</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.8.3.</span> <span class="nav-text">修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#lazy"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">.lazy</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#number"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">.number</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#trim"><span class="nav-number">1.8.3.3.</span> <span class="nav-text">.trim</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E4%B8%8A%E7%9A%84v-model"><span class="nav-number">1.8.4.</span> <span class="nav-text">组件上的v-model</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="nav-number">1.9.</span> <span class="nav-text">生命周期钩子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%A6%E5%90%AC%E5%99%A8"><span class="nav-number">1.10.</span> <span class="nav-text">侦听器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%A6%E5%90%AC%E5%99%A8-%E5%92%8C-%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="nav-number">1.10.1.</span> <span class="nav-text">侦听器 和 计算属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#watch"><span class="nav-number">1.10.2.</span> <span class="nav-text">watch()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E5%B1%82%E4%BE%A6%E5%90%AC%E5%99%A8"><span class="nav-number">1.10.3.</span> <span class="nav-text">深层侦听器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%B3%E6%97%B6%E5%9B%9E%E8%B0%83%E7%9A%84%E4%BE%A6%E5%90%AC%E5%99%A8"><span class="nav-number">1.10.4.</span> <span class="nav-text">即时回调的侦听器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#watchEffect"><span class="nav-number">1.10.5.</span> <span class="nav-text">watchEffect()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#watch-%E5%92%8C-watchEffect"><span class="nav-number">1.10.6.</span> <span class="nav-text">watch 和 watchEffect</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E7%9A%84%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="nav-number">1.10.7.</span> <span class="nav-text">回调的触发时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%9C%E6%AD%A2%E4%BE%A6%E5%90%AC%E5%99%A8"><span class="nav-number">1.10.8.</span> <span class="nav-text">停止侦听器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8"><span class="nav-number">1.11.</span> <span class="nav-text">模板引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8"><span class="nav-number">1.11.1.</span> <span class="nav-text">访问模板引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#v-for%E4%B8%AD%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8"><span class="nav-number">1.11.2.</span> <span class="nav-text">v-for中的模板引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%BC%95%E7%94%A8"><span class="nav-number">1.11.3.</span> <span class="nav-text">函数模板引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E4%B8%8A%E7%9A%84-ref"><span class="nav-number">1.11.4.</span> <span class="nav-text">组件上的 ref</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80"><span class="nav-number">1.12.</span> <span class="nav-text">组件基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E9%80%92-props"><span class="nav-number">1.12.1.</span> <span class="nav-text">传递 props</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6-1"><span class="nav-number">1.12.2.</span> <span class="nav-text">监听事件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E7%BB%84%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">深入组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C"><span class="nav-number">2.1.</span> <span class="nav-text">注册</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C"><span class="nav-number">2.1.1.</span> <span class="nav-text">全局注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C"><span class="nav-number">2.1.2.</span> <span class="nav-text">局部注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E5%90%8D%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.1.3.</span> <span class="nav-text">组件名格式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#props"><span class="nav-number">2.2.</span> <span class="nav-text">props</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#props-%E5%A3%B0%E6%98%8E"><span class="nav-number">2.2.1.</span> <span class="nav-text">props 声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E9%80%92-prop-%E7%BB%86%E8%8A%82"><span class="nav-number">2.2.2.</span> <span class="nav-text">传递 prop 细节</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#prop-%E5%90%8D%E5%AD%97%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">prop 名字格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81-%E5%92%8C-%E5%8A%A8%E6%80%81-prop"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">静态 和 动态 prop</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">传递不同的值类型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A%E5%A4%9A%E4%B8%AA-prop"><span class="nav-number">2.2.3.</span> <span class="nav-text">使用一个对象绑定多个 prop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-number">2.2.4.</span> <span class="nav-text">单向数据流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E5%AF%B9%E8%B1%A1-x2F-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E7%9A%84-props"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">更改对象 &#x2F; 数组类型的 props</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.3.</span> <span class="nav-text">组件事件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E4%B8%8E%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.3.1.</span> <span class="nav-text">触发与监听事件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E8%A7%A6%E5%8F%91%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="nav-number">2.3.2.</span> <span class="nav-text">声明触发的事件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6-v-model"><span class="nav-number">2.4.</span> <span class="nav-text">组件 v-model</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#v-model-%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">2.4.1.</span> <span class="nav-text">v-model 的参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AAv-model%E7%BB%91%E5%AE%9A"><span class="nav-number">2.4.2.</span> <span class="nav-text">多个v-model绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86v-model%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">2.4.3.</span> <span class="nav-text">处理v-model修饰符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%8F%E4%BC%A0-attributes"><span class="nav-number">2.5.</span> <span class="nav-text">透传 attributes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#attributes-%E7%BB%A7%E6%89%BF"><span class="nav-number">2.5.1.</span> <span class="nav-text">attributes 继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9-class-%E5%92%8C-style-%E7%9A%84%E5%90%88%E5%B9%B6"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">对 class 和 style 的合并</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#v-on-%E7%9B%91%E5%90%AC%E5%99%A8%E7%BB%A7%E6%89%BF"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">v-on 监听器继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%B1%E5%B1%82%E7%BB%84%E4%BB%B6%E7%BB%A7%E6%89%BF"><span class="nav-number">2.5.1.3.</span> <span class="nav-text">深层组件继承</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A6%81%E7%94%A8-attributes-%E7%BB%A7%E6%89%BF"><span class="nav-number">2.5.2.</span> <span class="nav-text">禁用 attributes 继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%A0%B9%E8%8A%82%E7%82%B9%E7%9A%84-attributes-%E7%BB%A7%E6%89%BF"><span class="nav-number">2.5.3.</span> <span class="nav-text">多根节点的 attributes 继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8-JavaScript-%E4%B8%AD%E8%AE%BF%E9%97%AE%E9%80%8F%E4%BC%A0-Attributes"><span class="nav-number">2.5.4.</span> <span class="nav-text">在 JavaScript 中访问透传 Attributes</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E6%A7%BD-slots"><span class="nav-number">2.6.</span> <span class="nav-text">插槽 slots</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E6%8F%92%E6%A7%BD"><span class="nav-number">2.6.1.</span> <span class="nav-text">多个插槽</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%91%E6%8F%92%E6%A7%BD%E4%BC%A0%E5%8F%82"><span class="nav-number">2.6.2.</span> <span class="nav-text">向插槽传参</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E6%B8%B2%E6%9F%93%E7%BB%84%E4%BB%B6"><span class="nav-number">2.6.3.</span> <span class="nav-text">无渲染组件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-number">2.7.</span> <span class="nav-text">依赖注入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#provide%EF%BC%88%E6%8F%90%E4%BE%9B%EF%BC%89"><span class="nav-number">2.7.1.</span> <span class="nav-text">provide（提供）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82-provide"><span class="nav-number">2.7.1.1.</span> <span class="nav-text">应用层 provide</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inject%EF%BC%88%E6%B3%A8%E5%85%A5%EF%BC%89"><span class="nav-number">2.7.2.</span> <span class="nav-text">inject（注入）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E5%85%A5%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="nav-number">2.7.2.1.</span> <span class="nav-text">注入默认值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%92%8C%E5%93%8D%E5%BA%94%E5%BC%8F%E6%95%B0%E6%8D%AE%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-number">2.7.3.</span> <span class="nav-text">和响应式数据配合使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-symbol-%E4%BD%9C%E4%B8%BA%E6%B3%A8%E5%85%A5%E5%90%8D"><span class="nav-number">2.7.4.</span> <span class="nav-text">使用 symbol 作为注入名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6"><span class="nav-number">2.8.</span> <span class="nav-text">异步组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">2.8.1.</span> <span class="nav-text">基本用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E4%B8%8E%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81"><span class="nav-number">2.8.2.</span> <span class="nav-text">加载与错误状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%90%AD%E9%85%8D-Suspense-%E4%BD%BF%E7%94%A8"><span class="nav-number">2.8.3.</span> <span class="nav-text">搭配 Suspense 使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">逻辑复用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E5%BC%8F%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.</span> <span class="nav-text">组合式函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E7%8A%B6%E6%80%81%E7%A4%BA%E4%BE%8B%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.1.1.</span> <span class="nav-text">异步状态示例示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A6%E5%AE%9A%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">3.1.2.</span> <span class="nav-text">约定和最佳实践</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%91%BD%E5%90%8D"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">命名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">输入参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">返回值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="nav-number">3.1.2.4.</span> <span class="nav-text">副作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6"><span class="nav-number">3.1.2.5.</span> <span class="nav-text">使用限制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="nav-number">3.2.</span> <span class="nav-text">自定义指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E9%92%A9%E5%AD%90"><span class="nav-number">3.2.1.</span> <span class="nav-text">指令钩子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%92%A9%E5%AD%90%E5%8F%82%E6%95%B0"><span class="nav-number">3.2.2.</span> <span class="nav-text">钩子参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E5%BD%A2%E5%BC%8F"><span class="nav-number">3.2.3.</span> <span class="nav-text">简化形式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">3.2.4.</span> <span class="nav-text">对象字面量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-1"><span class="nav-number">3.2.5.</span> <span class="nav-text">在组件上使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E4%BB%B6"><span class="nav-number">3.3.</span> <span class="nav-text">插件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%8F%92%E4%BB%B6"><span class="nav-number">3.3.1.</span> <span class="nav-text">编写一个插件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6"><span class="nav-number">4.</span> <span class="nav-text">内置组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Transition"><span class="nav-number">4.1.</span> <span class="nav-text">Transition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TransitionGroup"><span class="nav-number">4.2.</span> <span class="nav-text">TransitionGroup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KeepAlive"><span class="nav-number">4.3.</span> <span class="nav-text">KeepAlive</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Teleport"><span class="nav-number">4.4.</span> <span class="nav-text">Teleport</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Suspense"><span class="nav-number">4.5.</span> <span class="nav-text">Suspense</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E8%A7%84%E6%A8%A1%E5%8C%96"><span class="nav-number">5.</span> <span class="nav-text">应用规模化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-pinia"><span class="nav-number">5.1.</span> <span class="nav-text">状态管理 pinia</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-number">5.2.</span> <span class="nav-text">测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93-SSR"><span class="nav-number">5.3.</span> <span class="nav-text">服务端渲染 (SSR)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-1"><span class="nav-number">6.</span> <span class="nav-text">最佳实践</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TypeScript"><span class="nav-number">7.</span> <span class="nav-text">TypeScript</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E4%B8%BB%E9%A2%98"><span class="nav-number">8.</span> <span class="nav-text">进阶主题</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="像方便面一样的男子"
      src="//img.lujinkai.cn/blog/ljk/1607154764582.png">
  <p class="site-author-name" itemprop="name">像方便面一样的男子</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">340</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">73</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ljkk" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ljkk" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/%E5%89%8D%E7%AB%AF/Vue3/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="快速开始 | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          快速开始
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-02-23 15:45:05" itemprop="dateCreated datePublished" datetime="2023-02-23T15:45:05+08:00">2023-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-29 16:58:22" itemprop="dateModified" datetime="2023-05-29T16:58:22+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">前端</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%89%8D%E7%AB%AF/Vue3/" itemprop="url" rel="index"><span itemprop="name">Vue3</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><h4 id="attribute"><a href="#attribute" class="headerlink" title="attribute"></a>attribute</h4><p><code>&#123;&#123;&#125;&#125;</code>不能在 HTML attributes 中使用。想要响应式的绑定一个 attribute，应该使用<code>v-bind</code>指令是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>因为<code>v-bind</code>非常常用，我们提供了特定的简写语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="使用-js-表达式"><a href="#使用-js-表达式" class="headerlink" title="使用 js 表达式"></a>使用 js 表达式</h4><p>实际上，vue 在所有的数据绑定中都支持完整的 js 表达式。</p>
<p>每个帮顶仅支持<strong>单一表达式</strong>，也就是一段能够被求值的 js 代码。一个简单的判断是是否可以合法的写在<code>return</code>后面。</p>
<blockquote>
<p>绑定在表达式中的方法在组件每次更新时都会被重新调用，因此<strong>不</strong>应该产生任何副作用，比如改变数据或触发异步操作。</p>
</blockquote>
<p><strong>受限的全局访问：</strong></p>
<p>模板中的表达式将被沙盒化，仅能够访问到<a target="_blank" rel="noopener" href="https://github.com/vuejs/core/blob/main/packages/shared/src/globalsWhitelist.ts#L3">有限的全局对象列表</a>。该列表中会暴露常用的内置全局对象，比如 <code>Math</code> 和 <code>Date</code>。</p>
<p>没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在 <code>window</code> 上的属性。然而，你也可以自行在 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/application.html#app-config-globalproperties"><code>app.config.globalProperties</code></a> 上显式地添加它们，供所有的 Vue 表达式使用。</p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p>指令是带有<code>v-</code>前缀的特殊 attribute，vue 提供了许多<a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/built-in-directives.html">内置指令</a>，包括上面提到的<code>v-bind</code>。</p>
<p>指令 attribute 的期望值是一个 js 表达式（除了<code>v-for</code>、<code>v-on</code>、<code>v-slot</code> 这几个少数的例外）。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。</p>
<p>以<code>v-if</code>为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>这里，<code>v-if</code> 指令会基于表达式 <code>seen</code> 的值的真假来移除&#x2F;插入该 <code>&lt;p&gt;</code> 元素。</p>
<h3 id="响应式基础"><a href="#响应式基础" class="headerlink" title="响应式基础"></a>响应式基础</h3><h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive()"></a><code>reactive()</code></h4><p>我们可以使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-core.html#reactive"><code>reactive()</code></a> 函数创建一个响应式对象或数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="lt-script-setup-gt"><a href="#lt-script-setup-gt" class="headerlink" title="&lt;script setup&gt;"></a><code>&lt;script setup&gt;</code></h4><p>要在组件模板中使用响应式状态，需要在 <code>setup()</code> 函数中定义并返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; reactive &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line"> setup() &#123;</span><br><span class="line">  const state = reactive(&#123; count: 0 &#125;)</span><br><span class="line"></span><br><span class="line">  function increment() &#123;</span><br><span class="line">   state.count++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 不要忘记同时暴露 increment 函数</span><br><span class="line">  return &#123;</span><br><span class="line">   state,</span><br><span class="line">   increment,</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在 setup() 函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过使用构建工具来简化该操作。当使用单文件组件（SFC）时，我们可以使用 <code>&lt;script setup&gt;</code> 来大幅度地简化代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const state = reactive(&#123; count: 0 &#125;)</span><br><span class="line"></span><br><span class="line">function increment() &#123;</span><br><span class="line"> state.count++</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;script setup&gt;</code> 中的顶层的导入和变量声明可在同一组件的模板中直接使用。你可以理解为模板中的表达式和 <code>&lt;script setup&gt;</code> 中的代码处在同一个作用域中。</p>
<h4 id="DOM-更新时机"><a href="#DOM-更新时机" class="headerlink" title="DOM 更新时机"></a>DOM 更新时机</h4><p>当你更改响应式状态后，DOM 会自动更新。然而，你得注意 DOM 的更新并不是同步的。相反，Vue 将缓冲它们直到更新周期的 “下个时机” 以确保无论你进行了多少次状态更改，每个组件都只更新一次。</p>
<p>若要等待一个状态改变后的 DOM 更新完成，你可以使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/general.html#nexttick">nextTick()</a> 这个全局 API：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line"> state.<span class="property">count</span>++</span><br><span class="line"> <span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// DOM更新后执行...</span></span><br><span class="line">  <span class="comment">// 访问更新后的DOM</span></span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="深层响应性"><a href="#深层响应性" class="headerlink" title="深层响应性"></a>深层响应性</h4><p>在 Vue 中，状态都是默认深层响应式的。这意味着即使在更改深层次的对象或数组，你的改动也能被检测到。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123;</span><br><span class="line"> <span class="attr">nested</span>: &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;,</span><br><span class="line"> <span class="attr">arr</span>: [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mutateDeeply</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="comment">// 以下都会按照期望工作</span></span><br><span class="line"> obj.<span class="property">nested</span>.<span class="property">count</span>++</span><br><span class="line"> obj.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="string">&quot;baz&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以直接创建一个<a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive">浅层响应式对象</a>。它们仅在顶层具有响应性，一般仅在某些特殊场景中需要。</p>
<h4 id="响应式代理-vs-原始对象"><a href="#响应式代理-vs-原始对象" class="headerlink" title="响应式代理 vs 原始对象"></a>响应式代理 vs 原始对象</h4><p>值得注意的是，reactive() 返回的是一个原始对象的 Proxy，它和原始对象是不相等的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> raw = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="title function_">reactive</span>(raw)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理对象和原始对象不是全等的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy === raw) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>只有代理对象是响应式的，更改原始对象不会触发更新。因此，使用 vue 的响应式系统的最佳实践是 <strong>仅使用你声明对象的代理版本</strong>。</p>
<p>为保证访问代理的一致性，对同一个原始对象调用<code>reactive()</code>总是返回同样的代理对象，而对一个已存在的代理对象调用<code>reactive()</code>会返回其本身：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在同一个对象上调用 reactive() 会返回相同的代理</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reactive</span>(raw) === proxy) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个代理上调用 reactive() 会返回它自己</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reactive</span>(proxy) === proxy) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这个规则对嵌套对象也适用。依靠深层响应性，<strong>响应式对象内的嵌套对象依然是代理</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="title function_">reactive</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> raw = &#123;&#125;</span><br><span class="line">proxy.<span class="property">nested</span> = raw</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(proxy.<span class="property">nested</span> === raw) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="reactive-的局限性"><a href="#reactive-的局限性" class="headerlink" title="reactive()的局限性"></a><code>reactive()</code>的局限性</h4><p>因为 js 没有可以作用于所有值类型的“引用”机制。所以<code>reactive()</code> API 有两条限制：</p>
<ol>
<li>仅对对象类型有效（对象、数组和 <code>Map</code>、<code>Set</code> 这样的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects#%E4%BD%BF%E7%94%A8%E9%94%AE%E7%9A%84%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1">集合类型</a>），而对 <code>string</code>、<code>number</code> 和 <code>boolean</code> 这样的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive">原始类型</a> 无效。</li>
<li>必须始终保持对响应式对象的相同引用。不可以随意地“替换”一个响应式对象，因为这将导致对初始引用的响应性连接丢失：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的引用(&#123;&#123;count: 0&#125;)将不再被追踪（响应性连接已丢失！）</span></span><br><span class="line">state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>同时这也意味着当我们将响应式对象的属性赋值或解构至本地变量时，或是将该属性传入一个函数时，我们会失去响应性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = state.<span class="property">count</span> <span class="comment">// n是一个局部变量，同 state.count 失去响应性连接</span></span><br><span class="line">n++ <span class="comment">// 不影响原始的state.count</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; count &#125; = state <span class="comment">// count也和state.count失去了响应性连接</span></span><br><span class="line">count++ <span class="comment">// 不会影响到原始的state</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">callSomeFunction</span>(state.<span class="property">count</span>) <span class="comment">// 该函数接收一个普通数字，并且将无法跟踪state.count的变化</span></span><br></pre></td></tr></table></figure>

<h4 id="ref"><a href="#ref" class="headerlink" title="ref()"></a><code>ref()</code></h4><p>js 没有可以作用于所有值类型的“引用”机制，为此，vue 提供了一个<code>ref()</code>方法来允许我们创建可以使用任何值类型的响应式 ref：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><code>ref()</code>将传入参数的值包装为一个带<code>.value</code>属性的 ref 对象：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">count</span>: <span class="title class_">Ref</span>&lt;<span class="built_in">number</span>&gt; = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count) <span class="comment">// &#123; value: 0 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">count.<span class="property">value</span>++</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>和响应式对象的属性类似，ref 的 <code>.value</code> 属性也是响应式的。同时，当值为对象类型时，会用 <code>reactive()</code> 自动转换它的 <code>.value</code>。</p>
<p>一个包含对象类型值的 ref 可以响应式地替换整个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> objectRef = <span class="title function_">ref</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是响应式的替换</span></span><br><span class="line">objectRef.<span class="property">value</span> = &#123; <span class="attr">count</span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<p>ref 被传递给函数或是从一般对象上被解构时，不会丢失响应性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="attr">foo</span>: <span class="title function_">ref</span>(<span class="number">1</span>),</span><br><span class="line"> <span class="attr">bar</span>: <span class="title function_">ref</span>(<span class="number">2</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数接收一个 ref</span></span><br><span class="line"><span class="comment">// 需要通过 .value 取值</span></span><br><span class="line"><span class="comment">// 但它会保持响应性</span></span><br><span class="line"><span class="title function_">callSomeFunction</span>(obj.<span class="property">foo</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仍然是响应式的</span></span><br><span class="line"><span class="keyword">const</span> &#123; foo, bar &#125; = obj</span><br></pre></td></tr></table></figure>

<p>简言之，<code>ref()</code> 让我们能创造一种对任意值的 “引用”，并能够在不丢失响应性的前提下传递这些引用。这个功能很重要，因为它经常用于将逻辑提取到 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/reusability/composables.html">组合函数</a> 中。</p>
<h4 id="ref-在模板中的解包"><a href="#ref-在模板中的解包" class="headerlink" title="ref 在模板中的解包"></a>ref 在模板中的解包</h4><p>当 ref 在模板中作为顶层属性被访问时，它们会自动“解包”，所以不需要使用<code>.value</code>，示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const count = ref(0)</span><br><span class="line"></span><br><span class="line">function increment() &#123;</span><br><span class="line"> count.value++</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;button @click=&quot;increment&quot;&gt;</span><br><span class="line">  &#123;&#123; count &#125;&#125;</span><br><span class="line">  &lt;!-- 无需 .value --&gt;</span><br><span class="line"> &lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>请注意，仅当 ref 是模板渲染上下文的顶层属性时才适用自动“解包”。 例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">foo</span>: <span class="title function_">ref</span>(<span class="number">1</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>下面的表达式将<strong>不会</strong>像预期的那样工作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &#123;</span><br><span class="line">  object.<span class="property">foo</span> + <span class="number">1</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为此时 ref 所在的上下文是<code>object</code>而不是模板。我们可以将<code>foo</code>提取出来，这样 ref 的上下文就是模板了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; foo &#125; = object</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &#123;</span><br><span class="line">  foo + <span class="number">1</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果是下面这种情况，直接渲染，不参与计算，则也会被自动解包：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &#123;</span><br><span class="line">  object.<span class="property">foo</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="comment">// 相当于 &#123;&#123; object.foo.value &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="ref-在响应式对象中的解包"><a href="#ref-在响应式对象中的解包" class="headerlink" title="ref 在响应式对象中的解包"></a>ref 在响应式对象中的解包</h4><p>当一个<code>ref</code>被嵌套在一个响应式对象中，作为属性被访问或更改时，它会自动解包，因此会表现的和一般属性一样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line"> count,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">count</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">state.<span class="property">count</span> = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>如果将一个新的 ref 赋值给一个关联了已有 ref 的属性，那么它会替换掉旧的 ref：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> otherCount = <span class="title function_">ref</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">state.<span class="property">count</span> = otherCount</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(state.<span class="property">count</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 原始 ref 现在已经和 state.count 失去了联系</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count.<span class="property">value</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>只有当嵌套在一个深层响应式对象内时，才会发生 ref 解包，当其作为<a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive">浅层响应式对象</a>的属性被访问时不会解包。</p>
<h4 id="数组和集合类型的-ref-解包"><a href="#数组和集合类型的-ref-解包" class="headerlink" title="数组和集合类型的 ref 解包"></a>数组和集合类型的 ref 解包</h4><p>跟响应式对象不同，当 ref 作为响应式数组或像 <code>Map</code> 这种原生集合类型的元素被访问时，不会进行解包。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> books = <span class="title function_">reactive</span>([<span class="title function_">ref</span>(<span class="string">&quot;Vue 3 Guide&quot;</span>)])</span><br><span class="line"><span class="comment">// 这里需要 .value</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(books[<span class="number">0</span>].<span class="property">value</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="title function_">reactive</span>(<span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&quot;count&quot;</span>, <span class="title function_">ref</span>(<span class="number">0</span>)]]))</span><br><span class="line"><span class="comment">// 这里需要 .value</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="string">&quot;count&quot;</span>).<span class="property">value</span>)</span><br></pre></td></tr></table></figure>

<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; reactive, computed &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const author = reactive(&#123;</span><br><span class="line"> name: &quot;John Doe&quot;,</span><br><span class="line"> books: [&quot;Vue 2 - Advanced Guide&quot;, &quot;Vue 3 - Basic Guide&quot;, &quot;Vue 4 - The Mystery&quot;],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 一个计算属性 ref</span><br><span class="line">const publishedBooksMessage = computed&lt;&quot;Yes&quot; | &quot;No&quot;&gt;(() =&gt; &#123;</span><br><span class="line"> return author.books.length &gt; 0 ? &quot;Yes&quot; : &quot;No&quot;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;p&gt;Has published books:&lt;/p&gt;</span><br><span class="line"> &lt;span&gt;&#123;&#123; publishedBooksMessage &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>我们在这里定义了一个计算属性 <code>publishedBooksMessage</code>。<code>computed()</code> 方法期望接收一个 getter 函数，返回值为一个<strong>计算属性 ref</strong>。和其他一般的 ref 类似，你可以通过 <code>publishedBooksMessage.value</code> 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 <code>.value</code>。</p>
<p>vue 的计算属性会自动追踪响应式依赖。它会检测到 <code>publishedBooksMessage</code> 依赖于 <code>author.books</code>，所以当 <code>author.books</code> 改变时，任何依赖于 <code>publishedBooksMessage</code> 的绑定都会同时更新。</p>
<h4 id="计算属性缓存-vs-方法"><a href="#计算属性缓存-vs-方法" class="headerlink" title="计算属性缓存 vs 方法"></a>计算属性缓存 vs 方法</h4><p>你可能注意到我们在表达式中像这样调用一个函数也会获得和计算属性相同的结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; <span class="title function_">calculateBooksMessage</span>() &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件中</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateBooksMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> author.<span class="property">books</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于<strong>计算属性值会基于其响应式依赖被缓存</strong>。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 <code>author.books</code> 不改变，无论多少次访问 <code>publishedBooksMessage</code> 都会立即返回先前的计算结果，而不用重复执行 getter 函数。</p>
<p>这也解释了为什么下面的计算属性永远不会更新，因为 <code>Date.now()</code> 并不是一个响应式依赖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> now = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> <span class="title class_">Date</span>.<span class="title function_">now</span>())</span><br></pre></td></tr></table></figure>

<p>相比之下，方法调用<strong>总是</strong>会在重渲染发生时再次执行函数。</p>
<p>为什么需要缓存呢？想象一下我们有一个非常耗性能的计算属性 <code>list</code>，需要循环一个巨大的数组并做许多计算逻辑，并且可能也有其他计算属性依赖于 <code>list</code>。没有缓存的话，我们会重复执行非常多次 <code>list</code> 的 getter，然而这实际上没有必要！如果你确定不需要缓存，那么也可以使用方法调用。</p>
<h4 id="可写计算属性"><a href="#可写计算属性" class="headerlink" title="可写计算属性"></a>可写计算属性</h4><p>计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> firstName = <span class="title function_">ref</span>(<span class="string">&#x27;John&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> lastName = <span class="title function_">ref</span>(<span class="string">&#x27;Doe&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">  <span class="comment">// getter</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName.<span class="property">value</span> + <span class="string">&#x27; &#x27;</span> + lastName.<span class="property">value</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// setter</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="comment">// 注意：我们这里使用的是解构赋值语法</span></span><br><span class="line">    [firstName.<span class="property">value</span>, lastName.<span class="property">value</span>] = newValue.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>现在当你再运行 <code>fullName.value = &#39;John Doe&#39;</code> 时，setter 会被调用而 <code>firstName</code> 和 <code>lastName</code> 会随之更新。</p>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><h5 id="Getter-不应有副作用"><a href="#Getter-不应有副作用" class="headerlink" title="Getter 不应有副作用"></a>Getter 不应有副作用</h5><p>计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。举例来说，<strong>不要在 getter 中做异步请求或者更改 DOM</strong>！一个计算属性的声明中描述的是如何根据其他值派生一个值。因此 getter 的职责应该仅为计算和返回该值。在之后的指引中我们会讨论如何使用<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/watchers.html">监听器</a>根据其他响应式状态的变更来创建副作用。</p>
<h5 id="避免直接修改计算属性值"><a href="#避免直接修改计算属性值" class="headerlink" title="避免直接修改计算属性值"></a>避免直接修改计算属性值</h5><p>从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。</p>
<h3 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h3><p>因为 <code>class</code> 和 <code>style</code> 都是 attribute，我们可以和其他 attribute 一样使用 <code>v-bind</code> 将它们和动态的字符串绑定。但是，在处理比较复杂的绑定时，通过拼接生成字符串是麻烦且易出错的。因此，Vue 专门为 <code>class</code> 和 <code>style</code> 的 <code>v-bind</code> 用法提供了特殊的功能增强。除了字符串外，表达式的值也可以是对象或数组。</p>
<h4 id="绑定-HTML-class"><a href="#绑定-HTML-class" class="headerlink" title="绑定 HTML class"></a>绑定 HTML class</h4><h5 id="绑定对象"><a href="#绑定对象" class="headerlink" title="绑定对象"></a>绑定对象</h5><p><code>:class</code> 是 <code>v-bind:class</code> 的缩写。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以直接绑定一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> classObject = <span class="title function_">reactive</span>(&#123;</span><br><span class="line"> <span class="attr">active</span>: <span class="literal">true</span>,</span><br><span class="line"> <span class="string">&quot;text-danger&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;classObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也可以绑定一个返回对象的<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/computed.html">计算属性</a>。这是一个常见且很有用的技巧：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isActive = <span class="title function_">ref</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">const</span> error = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> classObject = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> (&#123;</span><br><span class="line"> <span class="attr">active</span>: isActive.<span class="property">value</span> &amp;&amp; !error.<span class="property">value</span>,</span><br><span class="line"> <span class="string">&quot;text-danger&quot;</span>: error.<span class="property">value</span> &amp;&amp; error.<span class="property">value</span>.<span class="property">type</span> === <span class="string">&quot;fatal&quot;</span>,</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;classObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="绑定数组"><a href="#绑定数组" class="headerlink" title="绑定数组"></a>绑定数组</h5><p>我们可以给 <code>:class</code> 绑定一个数组来渲染多个 CSS class：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> activeClass = <span class="title function_">ref</span>(<span class="string">&quot;active&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> errorClass = <span class="title function_">ref</span>(<span class="string">&quot;text-danger&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>渲染的结果是：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;active text-danger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你也想在数组中有条件地渲染某个 class，你可以使用三元表达式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然而，这可能在有多个依赖条件的 class 时会有些冗长。因此也可以在数组中嵌套对象：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[&#123; active: isActive &#125;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="在组件上使用"><a href="#在组件上使用" class="headerlink" title="在组件上使用"></a>在组件上使用</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子组件模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;foo bar&quot;</span>&gt;</span>Hi!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在使用组件时 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">class</span>=<span class="string">&quot;baz boo&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 渲染出的 HTML 为 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;foo bar baz boo&quot;</span>&gt;</span>Hi<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h4><h5 id="绑定对象-1"><a href="#绑定对象-1" class="headerlink" title="绑定对象"></a>绑定对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> activeColor = <span class="title function_">ref</span>(<span class="string">&quot;red&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> fontSize = <span class="title function_">ref</span>(<span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; &#x27;font-size&#x27;: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>直接绑定一个样式对象通常是一个好主意，这样可以使模板更加简洁：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> styleObject = <span class="title function_">reactive</span>(&#123;</span><br><span class="line"> <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line"> <span class="attr">fontSize</span>: <span class="string">&quot;13px&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;styleObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同样的，如果样式对象需要更复杂的逻辑，也可以使用返回样式对象的计算属性。</p>
<h5 id="绑定数组-1"><a href="#绑定数组-1" class="headerlink" title="绑定数组"></a>绑定数组</h5><p>我们还可以给 <code>:style</code> 绑定一个包含多个样式对象的数组。这些对象会被合并后渲染到同一元素上：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;[baseStyles, overridingStyles]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="自动前缀"><a href="#自动前缀" class="headerlink" title="自动前缀"></a>自动前缀</h5><h5 id="样式多值"><a href="#样式多值" class="headerlink" title="样式多值"></a>样式多值</h5><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a><code>v-if</code></h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span>B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span>C<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>Not A/B/C<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个 <code>v-else</code> 元素必须跟在一个 <code>v-if</code> 或者 <code>v-else-if</code> 元素后面，否则它将不会被识别。</p>
<p><code>v-if</code>、<code>v-else</code> 和 <code>v-else-if</code> 也可以在 <code>&lt;template&gt;</code> 上使用。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;ok&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a><code>v-show</code></h4><p>另一个可以用来按条件显示一个元素的指令是 <code>v-show</code>。其用法基本一样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;ok&quot;</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>不同之处在于 <code>v-show</code> 会在 DOM 渲染中保留该元素；<code>v-show</code> 仅切换了该元素上名为 <code>display</code> 的 CSS 属性。</p>
<p><code>v-show</code> 不支持在 <code>&lt;template&gt;</code> 元素上使用，也不能和 <code>v-else</code> 搭配使用。</p>
<h4 id="v-if-和-v-show"><a href="#v-if-和-v-show" class="headerlink" title="v-if 和 v-show"></a><code>v-if</code> 和 <code>v-show</code></h4><p><code>v-if</code> 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。</p>
<p><code>v-if</code> 也是<strong>惰性</strong>的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。</p>
<p>相比之下，<code>v-show</code> 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS <code>display</code> 属性会被切换。</p>
<p><strong>总的来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 <code>v-show</code> 较好；如果在运行时绑定条件很少改变，则 <code>v-if</code> 会更合适。</strong></p>
<h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a><code>v-for</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="title function_">ref</span>([&#123; <span class="attr">message</span>: <span class="string">&quot;Foo&quot;</span> &#125;, &#123; <span class="attr">message</span>: <span class="string">&quot;Bar&quot;</span> &#125;])</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span>&#123;&#123; item.message &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>你也可以使用 <code>of</code> 作为分隔符来替代 <code>in</code>，这更接近 JavaScript 的迭代器语法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item of items&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-for-与对象"><a href="#v-for-与对象" class="headerlink" title="v-for 与对象"></a><code>v-for</code> 与对象</h4><p>你也可以使用 <code>v-for</code> 来遍历一个对象的所有属性。遍历的顺序会基于对该对象调用 <code>Object.keys()</code> 的返回值来决定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObject = <span class="title function_">reactive</span>(&#123;</span><br><span class="line"> <span class="attr">title</span>: <span class="string">&quot;How to do lists in Vue&quot;</span>,</span><br><span class="line"> <span class="attr">author</span>: <span class="string">&quot;Jane Doe&quot;</span>,</span><br><span class="line"> <span class="attr">publishedAt</span>: <span class="string">&quot;2016-04-10&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in myObject&quot;</span>&gt;</span>&#123;&#123; value &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 可以通过提供第二个参数表示属性名 (例如 key) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key) in myObject&quot;</span>&gt;</span>&#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第三个参数表示位置索引 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key, index) in myObject&quot;</span>&gt;</span>&#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="在-v-for-里使用范围值"><a href="#在-v-for-里使用范围值" class="headerlink" title="在 v-for 里使用范围值"></a>在 v-for 里使用范围值</h4><p><code>v-for</code> 可以直接接受一个整数值。在这种用例中，会将该模板基于 <code>1...n</code> 的取值范围重复多次。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">&quot;n in 10&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意此处 <code>n</code> 的初值是从 <code>1</code> 开始而非 <code>0</code>。</p>
<h4 id="lt-template-gt-上的-v-for"><a href="#lt-template-gt-上的-v-for" class="headerlink" title="&lt;template&gt; 上的 v-for"></a><code>&lt;template&gt;</code> 上的 <code>v-for</code></h4><p>与模板上的 <code>v-if</code> 类似，你也可以在 <code>&lt;template&gt;</code> 标签上使用 <code>v-for</code> 来渲染一个包含多个元素的块。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; item.msg &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;divider&quot;</span> <span class="attr">role</span>=<span class="string">&quot;presentation&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="v-for-和-v-if"><a href="#v-for-和-v-if" class="headerlink" title="v-for 和 v-if"></a><code>v-for</code> 和 <code>v-if</code></h4><blockquote>
<p>警告：</p>
<p>同时使用 <code>v-if</code> 和 <code>v-for</code> 是<strong>不推荐的</strong>，因为这样二者的优先级不明显。请查看<a target="_blank" rel="noopener" href="https://cn.vuejs.org/style-guide/rules-essential.html#avoid-v-if-with-v-for">风格指南</a>获得更多信息。</p>
</blockquote>
<p>当它们同时存在于一个节点上时，<code>v-if</code> 比 <code>v-for</code> 的优先级更高。这意味着 <code>v-if</code> 的条件将无法访问到 <code>v-for</code> 作用域内定义的变量别名：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 这会抛出一个错误，因为属性 todo 此时</span></span><br><span class="line"><span class="comment"> 没有在该实例上定义</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;!todo.isComplete&quot;</span>&gt;</span>&#123;&#123; todo.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在外新包装一层 <code>&lt;template&gt;</code> 再在其上使用 <code>v-for</code> 可以解决这个问题 (这也更加明显易读)：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-if</span>=<span class="string">&quot;!todo.isComplete&quot;</span>&gt;</span>&#123;&#123; todo.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="通过-key-管理状态"><a href="#通过-key-管理状态" class="headerlink" title="通过 key 管理状态"></a>通过 key 管理状态</h4><p>vue 默认按照“就地更新”的策略来更新通过 <code>v-for</code> 渲染的元素列表。当数据项的顺序改变时，vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。</p>
<p>默认模式是高效的，但<strong>只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况</strong>。</p>
<p>为了给 vue 一个提示，以便它可以跟踪每个节点的标识，从而重用和重新排序现有的元素，你需要为每个元素对应的块提供一个唯一的 <code>key</code> attribute：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当你使用 <code>&lt;template v-for&gt;</code> 时，<code>key</code> 应该被放置在这个 <code>&lt;template&gt;</code> 容器上：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;todo.name&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; todo.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：<code>key</code> 在这里是一个通过 <code>v-bind</code> 绑定的特殊 attribute。请不要和<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/list.html#v-for-with-an-object">在 <code>v-for</code> 中使用对象</a>里所提到的对象属性名相混淆。</p>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/style-guide/rules-essential.html#use-keyed-v-for">推荐</a>在任何可行的时候为 <code>v-for</code> 提供一个 <code>key</code> attribute，除非所迭代的 DOM 内容非常简单 (例如：不包含组件或有状态的 DOM 元素)，或者你想有意采用默认行为来提高性能。</p>
<p><code>key</code> 绑定的值期望是一个基础类型的值，例如字符串或 number 类型。不要用对象作为 <code>v-for</code> 的 key。关于 <code>key</code> attribute 的更多用途细节，请参阅 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/built-in-special-attributes.html#key"><code>key</code> API 文档</a>。</p>
<h4 id="组件上使用v-for"><a href="#组件上使用v-for" class="headerlink" title="组件上使用v-for"></a>组件上使用<code>v-for</code></h4><p>我们可以直接在组件上使用 <code>v-for</code>，和在一般的元素上使用没有区别 (别忘记提供一个 <code>key</code>)：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是，这不会自动将任何数据传递给组件，因为组件有自己独立的作用域。为了将迭代后的数据传递到组件中，我们还需要传递 props：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">MyComponent</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in items&quot;</span> <span class="attr">:item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">:index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>不自动将 <code>item</code> 注入组件的原因是，这会使组件与 <code>v-for</code> 的工作方式紧密耦合。明确其数据的来源可以使组件在其他情况下重用。</p>
<h4 id="数组变化侦测"><a href="#数组变化侦测" class="headerlink" title="数组变化侦测"></a>数组变化侦测</h4><h5 id="变更方法"><a href="#变更方法" class="headerlink" title="变更方法"></a>变更方法</h5><p>vue 能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新。这些变更方法包括：</p>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
<h5 id="替换一个数组"><a href="#替换一个数组" class="headerlink" title="替换一个数组"></a>替换一个数组</h5><p>变更方法，顾名思义，就是会对调用它们的原数组进行变更。相对地，也有一些不可变 (immutable) 方法，例如 <code>filter()</code>，<code>concat()</code> 和 <code>slice()</code>，这些都不会更改原数组，而总是<strong>返回一个新数组</strong>。当遇到的是非变更方法时，我们需要将旧的数组替换为新的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `items` 是一个数组的 ref</span></span><br><span class="line">items.<span class="property">value</span> = items.<span class="property">value</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">message</span>.<span class="title function_">match</span>(<span class="regexp">/Foo/</span>))</span><br></pre></td></tr></table></figure>

<p>你可能认为这将导致 vue 丢弃现有的 DOM 并重新渲染整个列表——幸运的是，情况并非如此。vue 实现了一些巧妙的方法来最大化对 DOM 元素的重用，因此用另一个包含部分重叠对象的数组来做替换，仍会是一种非常高效的操作。</p>
<h4 id="展示过滤或排序后的结果"><a href="#展示过滤或排序后的结果" class="headerlink" title="展示过滤或排序后的结果"></a>展示过滤或排序后的结果</h4><p>有时，我们希望显示数组经过过滤或排序后的内容，而不实际变更或重置原始数据。在这种情况下，你可以创建返回已过滤或已排序数组的计算属性。</p>
<p>举例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = <span class="title function_">ref</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> evenNumbers = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> numbers.<span class="property">value</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;n in evenNumbers&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在计算属性不可行的情况下 (例如在多层嵌套的 <code>v-for</code> 循环中)，你可以使用以下方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sets = <span class="title function_">ref</span>([</span><br><span class="line"> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line"> [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>],</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">even</span>(<span class="params">numbers</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> numbers.<span class="title function_">filter</span>(<span class="function"><span class="params">number</span> =&gt;</span> number % <span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-for</span>=<span class="string">&quot;numbers in sets&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;n in even(numbers)&quot;</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在计算属性中使用 <code>reverse()</code> 和 <code>sort()</code> 的时候务必小心！这两个方法将变更原始数组，计算函数中不应该这么做。请在调用这些方法之前创建一个原数组的副本：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- return numbers.reverse()</span></span><br><span class="line"><span class="addition">+ return [...numbers].reverse()</span></span><br></pre></td></tr></table></figure>

<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><h4 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h4><p>我们可以使用 <code>v-on</code> 指令 (简写为 <code>@</code>) 来监听 DOM 事件，并在事件触发时执行对应的 JavaScript。用法：<code>v-on:click=&quot;methodName&quot;</code> 或 <code>@click=&quot;handler&quot;</code>。</p>
<p>事件处理器的值可以是：</p>
<ol>
<li><strong>内联事件处理器</strong>：事件被触发时执行的内联 JavaScript 语句 (与 <code>onclick</code> 类似)。</li>
<li><strong>方法事件处理器</strong>：一个指向组件上定义的方法的属性名或是路径。</li>
</ol>
<h4 id="内联事件处理器"><a href="#内联事件处理器" class="headerlink" title="内联事件处理器"></a>内联事件处理器</h4><p>内联事件处理器通常用于简单场景，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>Add 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Count is: &#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="方法事件处理器"><a href="#方法事件处理器" class="headerlink" title="方法事件处理器"></a>方法事件处理器</h4><p>随着事件处理器的逻辑变得愈发复杂，内联代码方式变得不够灵活。因此 <code>v-on</code> 也可以接受一个方法名或对某个方法的调用。</p>
<p>举例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="title function_">ref</span>(<span class="string">&quot;Vue.js&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">event</span>) &#123;</span><br><span class="line"> <span class="title function_">alert</span>(<span class="string">`Hello <span class="subst">$&#123;name.value&#125;</span>!`</span>)</span><br><span class="line"> <span class="comment">// `event` 是 DOM 原生事件</span></span><br><span class="line"> <span class="keyword">if</span> (event) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(event.<span class="property">target</span>.<span class="property">tagName</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- `greet` 是上面定义过的方法名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;greet&quot;</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方法事件处理器会自动接收原生 DOM 事件并触发执行。在上面的例子中，我们能够通过被触发事件的 <code>event.target.tagName</code> 访问到该 DOM 元素。</p>
<h5 id="方法与内联事件判断"><a href="#方法与内联事件判断" class="headerlink" title="方法与内联事件判断"></a>方法与内联事件判断</h5><p>模板编译器会通过检查 <code>v-on</code> 的值是否是合法的 JavaScript 标识符或属性访问路径来断定是何种形式的事件处理器。举例来说，<code>foo</code>、<code>foo.bar</code> 和 <code>foo[&#39;bar&#39;]</code> 会被视为方法事件处理器，而 <code>foo()</code> 和 <code>count++</code> 会被视为内联事件处理器。</p>
<h4 id="在内联处理器中调用方法"><a href="#在内联处理器中调用方法" class="headerlink" title="在内联处理器中调用方法"></a>在内联处理器中调用方法</h4><p>除了直接绑定方法名，你还可以在内联事件处理器中调用方法。这允许我们向方法传入自定义参数以代替原生事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">say</span>(<span class="params">message</span>) &#123;</span><br><span class="line"> <span class="title function_">alert</span>(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;say(&#x27;hello&#x27;)&quot;</span>&gt;</span>Say hello<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;say(&#x27;bye&#x27;)&quot;</span>&gt;</span>Say bye<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="在内联事件处理器中访问事件参数"><a href="#在内联事件处理器中访问事件参数" class="headerlink" title="在内联事件处理器中访问事件参数"></a>在内联事件处理器中访问事件参数</h4><p>有时我们需要在内联事件处理器中访问原生 DOM 事件。你可以向该处理器方法传入一个特殊的 <code>$event</code> 变量，或者使用内联箭头函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 使用特殊的 $event 变量 --&gt;</span><br><span class="line">&lt;button @click=&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用内联箭头函数 --&gt;</span><br><span class="line">&lt;button @click=&quot;e =&gt; warn(&#x27;Form cannot be submitted yet.&#x27;, e)&quot;&gt;</span><br><span class="line">  Submit</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">warn</span>(<span class="params">message, event</span>) &#123;</span><br><span class="line"> <span class="comment">// 这里可以访问原生事件</span></span><br><span class="line"> <span class="keyword">if</span> (event) &#123;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>()</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="title function_">alert</span>(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><p>在处理事件时调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是很常见的。尽管我们可以直接在方法内调用，但如果方法能更专注于数据逻辑而不用去处理 DOM 事件的细节会更好。</p>
<p>为解决这一问题，Vue 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。修饰符是用 <code>.</code> 表示的指令后缀，包含以下这些：</p>
<ul>
<li><code>.stop</code></li>
<li><code>.prevent</code></li>
<li><code>.self</code></li>
<li><code>.capture</code></li>
<li><code>.once</code></li>
<li><code>.passive</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 单击事件将停止传递 --&gt;</span><br><span class="line">&lt;a @click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交事件将不再重新加载页面 --&gt;</span><br><span class="line">&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰语可以使用链式书写 --&gt;</span><br><span class="line">&lt;a @click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 也可以只有修饰符 --&gt;</span><br><span class="line">&lt;form @submit.prevent&gt;&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 仅当 event.target 是元素本身时才会触发事件处理器 --&gt;</span><br><span class="line">&lt;!-- 例如：事件处理器不来自子元素 --&gt;</span><br><span class="line">&lt;div @click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>使用修饰符时需要注意调用顺序，因为相关代码是以相同的顺序生成的。因此使用 <code>@click.prevent.self</code> 会阻止<strong>元素及其子元素的所有点击事件的默认行为，</strong>而 <code>@click.self.prevent</code> 则只会阻止对元素本身的点击事件的默认行为。</p>
<p><code>.capture</code>、<code>.once</code> 和 <code>.passive</code> 修饰符与<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#options">原生 <code>addEventListener</code> 事件</a>相对应：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 添加事件监听器时，使用 `capture` 捕获模式 --&gt;</span><br><span class="line">&lt;!-- 例如：指向内部元素的事件，在被内部元素处理前，先被外部处理 --&gt;</span><br><span class="line">&lt;div @click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 点击事件最多被触发一次 --&gt;</span><br><span class="line">&lt;a @click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 滚动事件的默认行为 (scrolling) 将立即发生而非等待 `onScroll` 完成 --&gt;</span><br><span class="line">&lt;!-- 以防其中包含 `event.preventDefault()` --&gt;</span><br><span class="line">&lt;div @scroll.passive=&quot;onScroll&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><code>.passive</code> 修饰符一般用于触摸事件的监听器，可以用来<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#%E4%BD%BF%E7%94%A8_passive_%E6%94%B9%E5%96%84%E6%BB%9A%E5%B1%8F%E6%80%A7%E8%83%BD">改善移动端设备的滚屏性能</a>。</p>
<p>请勿同时使用 <code>.passive</code> 和 <code>.prevent</code>，因为 <code>.passive</code> 已经向浏览器表明了你<em>不想</em>阻止事件的默认行为。如果你这么做了，则 <code>.prevent</code> 会被忽略，并且浏览器会抛出警告。</p>
<h4 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h4><p>在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许在 <code>v-on</code> 或 <code>@</code> 监听按键事件时添加按键修饰符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 仅在 `key` 为 `Enter` 时调用 `submit` --&gt;</span><br><span class="line">&lt;input @keyup.enter=&quot;submit&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>你可以直接使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/KeyboardEvent/key/Key_Values"><code>KeyboardEvent.key</code></a> 暴露的按键名称作为修饰符，但需要转为 kebab-case 形式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input @keyup.page-down=&quot;onPageDown&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，仅会在 <code>$event.key</code> 为 <code>&#39;PageDown&#39;</code> 时调用事件处理。</p>
<h5 id="按键别名"><a href="#按键别名" class="headerlink" title="按键别名"></a>按键别名</h5><p>Vue 为一些常用的按键提供了别名：</p>
<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code> (捕获“Delete”和“Backspace”两个按键)</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
<h5 id="系统按键修饰符"><a href="#系统按键修饰符" class="headerlink" title="系统按键修饰符"></a>系统按键修饰符</h5><p>你可以使用以下系统按键修饰符来触发鼠标或键盘事件监听器，只有当按键被按下时才会触发。</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<blockquote>
<p>在 Mac 键盘上，meta 是 Command 键 (⌘)。在 Windows 键盘上，meta 键是 Windows 键 (⊞)。在 Sun 微机系统键盘上，meta 是钻石键 (◆)。在某些键盘上，特别是 MIT 和 Lisp 机器的键盘及其后代版本的键盘，如 Knight 键盘，space-cadet 键盘，meta 都被标记为“META”。在 Symbolics 键盘上，meta 也被标识为“META”或“Meta”。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Alt + Enter --&gt;</span><br><span class="line">&lt;input @keyup.alt.enter=&quot;clear&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Ctrl + 点击 --&gt;</span><br><span class="line">&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>请注意，系统按键修饰符和常规按键不同。与 <code>keyup</code> 事件一起使用时，该按键必须在事件发出时处于按下状态。换句话说，<code>keyup.ctrl</code> 只会在你仍然按住 <code>ctrl</code> 但松开了另一个键时被触发。若你单独松开 <code>ctrl</code> 键将不会触发。</p>
<h5 id="exact修饰符"><a href="#exact修饰符" class="headerlink" title=".exact修饰符"></a><code>.exact</code>修饰符</h5><p><code>.exact</code> 修饰符允许控制触发一个事件所需的确定组合的系统按键修饰符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 当按下 Ctrl 时，即使同时按下 Alt 或 Shift 也会触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 仅当没有按下任何系统按键时触发 --&gt;</span><br><span class="line">&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h4 id="鼠标按键修饰符"><a href="#鼠标按键修饰符" class="headerlink" title="鼠标按键修饰符"></a>鼠标按键修饰符</h4><ul>
<li><code>.left</code></li>
<li><code>.right</code></li>
<li><code>.middle</code></li>
</ul>
<p>这些修饰符将处理程序限定为由特定鼠标按键触发的事件。</p>
<h3 id="表单输入与绑定"><a href="#表单输入与绑定" class="headerlink" title="表单输入与绑定"></a>表单输入与绑定</h3><p>在前端处理表单时，我们常常需要将表单输入框的内容同步给 JavaScript 中相应的变量。手动连接值绑定和更改事件监听器可能会很麻烦：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  :value=&quot;text&quot;</span><br><span class="line">  @input=&quot;event =&gt; text = event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><code>v-model</code> 指令帮我们简化了这一步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;text&quot;&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p><code>v-model</code> 会忽略任何表单元素上初始的 <code>value</code>、<code>checked</code> 或 <code>selected</code> attribute。它将始终将当前绑定的 JavaScript 状态视为数据的正确来源。你应该在 JavaScript 中使用响应式系统的 API 来声明该初始值。</p>
</blockquote>
<h4 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h4><p>有时我们可能希望将该值绑定到当前组件实例上的动态数据。这可以通过使用 <code>v-bind</code> 来实现。此外，使用 <code>v-bind</code> 还使我们可以将选项值绑定为非字符串的数据类型。</p>
<h4 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; true-value=&quot;yes&quot; false-value=&quot;no&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><code>true-value</code> 和 <code>false-value</code> 是 Vue 特有的 attributes，仅支持和 <code>v-model</code> 配套使用。这里 <code>toggle</code> 属性的值会在选中时被设为 <code>&#39;yes&#39;</code>，取消选择时设为 <code>&#39;no&#39;</code>。你同样可以通过 <code>v-bind</code> 将其绑定为其他动态值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot; :true-value=&quot;dynamicTrueValue&quot; :false-value=&quot;dynamicFalseValue&quot; /&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：</p>
<p><code>true-value</code> 和 <code>false-value</code> attributes 不会影响 <code>value</code> attribute，因为浏览器在表单提交时，并不会包含未选择的复选框。为了保证这两个值 (例如：“yes”和“no”) 的其中之一被表单提交，请使用单选按钮作为替代。</p>
</blockquote>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><h5 id="lazy"><a href="#lazy" class="headerlink" title=".lazy"></a><code>.lazy</code></h5><p>默认情况下，<code>v-model</code> 会在每次 <code>input</code> 事件后更新数据 (<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/forms.html#vmodel-ime-tip">IME 拼字阶段的状态</a>例外)。你可以添加 <code>lazy</code> 修饰符来改为在每次 <code>change</code> 事件后更新数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在 &quot;change&quot; 事件后同步更新而不是 &quot;input&quot; --&gt;</span><br><span class="line">&lt;input v-model.lazy=&quot;msg&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h5 id="number"><a href="#number" class="headerlink" title=".number"></a><code>.number</code></h5><p>如果你想让用户输入自动转换为数字，你可以在 <code>v-model</code> 后添加 <code>.number</code> 修饰符来管理输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.number=&quot;age&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>如果该值无法被 <code>parseFloat()</code> 处理，那么将返回原始值。</p>
<p><code>number</code> 修饰符会在输入框有 <code>type=&quot;number&quot;</code> 时自动启用。</p>
<h5 id="trim"><a href="#trim" class="headerlink" title=".trim"></a><code>.trim</code></h5><p>如果你想要默认自动去除用户输入内容中两端的空格，你可以在 <code>v-model</code> 后添加 <code>.trim</code> 修饰符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model.trim=&quot;msg&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h4 id="组件上的v-model"><a href="#组件上的v-model" class="headerlink" title="组件上的v-model"></a>组件上的<code>v-model</code></h4><p>HTML 的内置表单输入类型并不总能满足所有需求。幸运的是，我们可以使用 Vue 构建具有自定义行为的可复用输入组件，并且这些输入组件也支持 <code>v-model</code>！要了解更多关于此的内容，请在组件指引中阅读<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/components/v-model.html">配合 <code>v-model</code> 使用</a>。</p>
<h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><p>每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM，以及在数据改变时更新 DOM。在此过程中，它也会运行被称为生命周期钩子的函数，让开发者有机会在特定阶段运行自己的代码。</p>
<p><img data-src="//img.to2b.cn/blog/ljk/1676878242776.png"></p>
<h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><p>计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。</p>
<h4 id="侦听器-和-计算属性"><a href="#侦听器-和-计算属性" class="headerlink" title="侦听器 和 计算属性"></a>侦听器 和 计算属性</h4><p>有“副作用”，使用侦听器；没有“副作用”，使用计算属性。</p>
<h4 id="watch"><a href="#watch" class="headerlink" title="watch()"></a><code>watch()</code></h4><p>在组合式 API 中，我们可以使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-core.html#watch"><code>watch</code> 函数</a>在每次响应式状态发生变化时触发回调函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, watch &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const question = ref(&quot;&quot;)</span><br><span class="line">const answer = ref(&quot;Questions usually contain a question mark. ;-)&quot;)</span><br><span class="line"></span><br><span class="line">// 可以直接侦听一个 ref</span><br><span class="line">watch(question, async (newQuestion, oldQuestion) =&gt; &#123;</span><br><span class="line"> if (newQuestion.indexOf(&quot;?&quot;) &gt; -1) &#123;</span><br><span class="line">  answer.value = &quot;Thinking...&quot;</span><br><span class="line">  try &#123;</span><br><span class="line">   const res = await fetch(&quot;https://yesno.wtf/api&quot;)</span><br><span class="line">   answer.value = (await res.json()).answer</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">   answer.value = &quot;Error! Could not reach the API. &quot; + error</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;p&gt;</span><br><span class="line">  Ask a yes/no question:</span><br><span class="line">  &lt;input v-model=&quot;question&quot; /&gt;</span><br><span class="line"> &lt;/p&gt;</span><br><span class="line"> &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p><code>watch</code> 的第一个参数可以是不同形式的“数据源”：它可以是一个 ref (包括计算属性)、一个响应式对象、一个 getter 函数、或多个数据源组成的数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> y = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个 ref</span></span><br><span class="line"><span class="title function_">watch</span>(x, <span class="function"><span class="params">newX</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`x is <span class="subst">$&#123;newX&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter 函数</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line"> <span class="function">() =&gt;</span> x.<span class="property">value</span> + y.<span class="property">value</span>,</span><br><span class="line"> <span class="function"><span class="params">sum</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`sum of x + y is: <span class="subst">$&#123;sum&#125;</span>`</span>)</span><br><span class="line"> &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个来源组成的数组</span></span><br><span class="line"><span class="title function_">watch</span>([x, <span class="function">() =&gt;</span> y.<span class="property">value</span>], <span class="function">(<span class="params">[newX, newY]</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`x is <span class="subst">$&#123;newX&#125;</span> and y is <span class="subst">$&#123;newY&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意，你不能直接侦听响应式对象的属性值，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，因为 watch() 得到的参数是一个 number</span></span><br><span class="line"><span class="title function_">watch</span>(obj.<span class="property">count</span>, <span class="function"><span class="params">count</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`count is: <span class="subst">$&#123;count&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这里需要用一个返回该属性的 getter 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供一个 getter 函数</span></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line"> <span class="function">() =&gt;</span> obj.<span class="property">count</span>,</span><br><span class="line"> <span class="function"><span class="params">count</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`count is: <span class="subst">$&#123;count&#125;</span>`</span>)</span><br><span class="line"> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="深层侦听器"><a href="#深层侦听器" class="headerlink" title="深层侦听器"></a>深层侦听器</h4><p>直接给 <code>watch()</code> 传入一个响应式对象，会隐式地创建一个深层侦听器——该回调函数在所有嵌套的变更时都会被触发：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(obj, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">// 在嵌套的属性变更时触发</span></span><br><span class="line"> <span class="comment">// 注意：`newValue` 此处和 `oldValue` 是相等的</span></span><br><span class="line"> <span class="comment">// 因为它们是同一个对象！</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">count</span>++</span><br></pre></td></tr></table></figure>

<p>相比之下，一个返回响应式对象的 getter 函数，只有在返回不同的对象时，才会触发回调：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(</span><br><span class="line"> <span class="function">() =&gt;</span> state.<span class="property">someObject</span>,</span><br><span class="line"> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 仅当 state.someObject 被替换时触发</span></span><br><span class="line"> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>你也可以给上面这个例子显式地加上 <code>deep</code> 选项，强制转成深层侦听器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(</span><br><span class="line"> <span class="function">() =&gt;</span> state.<span class="property">someObject</span>,</span><br><span class="line"> <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 注意：`newValue` 此处和 `oldValue` 是相等的</span></span><br><span class="line">  <span class="comment">// *除非* state.someObject 被整个替换了</span></span><br><span class="line"> &#125;,</span><br><span class="line"> &#123; <span class="attr">deep</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>谨慎使用：</p>
<p>深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请只在必要时才使用它，并且要留意性能。</p>
</blockquote>
<h4 id="即时回调的侦听器"><a href="#即时回调的侦听器" class="headerlink" title="即时回调的侦听器"></a>即时回调的侦听器</h4><p><code>watch</code> 默认是懒执行的：仅当数据源变化时，才会执行回调。但在某些场景中，我们希望在创建侦听器时，立即执行一遍回调。举例来说，我们想请求一些初始数据，然后在相关状态更改时重新请求数据。</p>
<p>我们可以通过传入 <code>immediate: true</code> 选项来强制侦听器的回调立即执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(</span><br><span class="line"> source,</span><br><span class="line"> <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 立即执行，且当 `source` 改变时再次执行</span></span><br><span class="line"> &#125;,</span><br><span class="line"> &#123; <span class="attr">immediate</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect()"></a><code>watchEffect()</code></h4><p>下面的例子中，在每当 <code>todoId</code> 的引用发生变化时使用侦听器来加载一个远程资源：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoId = <span class="title function_">ref</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(</span><br><span class="line"> todoId,</span><br><span class="line"> <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`https://jsonplaceholder.typicode.com/todos/<span class="subst">$&#123;todoId.value&#125;</span>`</span>)</span><br><span class="line">  data.<span class="property">value</span> = <span class="keyword">await</span> response.<span class="title function_">json</span>()</span><br><span class="line"> &#125;,</span><br><span class="line"> &#123; <span class="attr">immediate</span>: <span class="literal">true</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>侦听的数据源是<code>todoId</code>，而回调中也使用到了<code>todoId</code>，这种情况是很常见的。</p>
<p>我们可以用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-core.html#watcheffect"><code>watchEffect</code> 函数</a> 来简化上面的代码。<code>watchEffect()</code> 允许我们自动跟踪回调的响应式依赖。上面的侦听器可以重写为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watchEffect</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line"> <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`https://jsonplaceholder.typicode.com/todos/<span class="subst">$&#123;todoId.value&#125;</span>`</span>)</span><br><span class="line"> data.<span class="property">value</span> = <span class="keyword">await</span> response.<span class="title function_">json</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这个例子中，回调会立即执行，不需要指定 <code>immediate: true</code>。在执行期间，它会自动追踪 <code>todoId.value</code> 作为依赖（和计算属性类似）。每当 <code>todoId.value</code> 变化时，回调会再次执行。有了 <code>watchEffect()</code>，我们不再需要明确传递 <code>todoId</code> 作为源值。</p>
<p>对于这种只有一个依赖项的例子来说，<code>watchEffect()</code> 的好处相对较小。但是对于有多个依赖项的侦听器来说，使用 <code>watchEffect()</code> 可以消除手动维护依赖列表的负担。此外，如果你需要侦听一个嵌套数据结构中的几个属性，<code>watchEffect()</code> 可能会比深度侦听器更有效，因为它将只跟踪回调中被使用到的属性，而不是递归地跟踪所有的属性。</p>
<blockquote>
<p>提示：</p>
<p><code>watchEffect</code> 仅会在其<strong>同步</strong>执行期间，才追踪依赖。在使用异步回调时，只有在第一个 <code>await</code> 正常工作前访问到的属性才会被追踪。</p>
</blockquote>
<h4 id="watch-和-watchEffect"><a href="#watch-和-watchEffect" class="headerlink" title="watch 和 watchEffect"></a><code>watch</code> 和 <code>watchEffect</code></h4><p><code>watch</code> 和 <code>watchEffect</code> 都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式：</p>
<ul>
<li><code>watch</code> 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。<code>watch</code> 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。</li>
<li><code>watchEffect</code>，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。</li>
</ul>
<h4 id="回调的触发时机"><a href="#回调的触发时机" class="headerlink" title="回调的触发时机"></a>回调的触发时机</h4><p>当你更改了响应的状态，它可能会同时触发 vue 组件更新和侦听器回调。</p>
<p>默认情况下，用户创建的侦听器回调，都会在 vue 组件更新<strong>之前</strong>被调用。这意味着你在侦听器回调中访问的 DOM 将是被 vue 更新的状态。</p>
<p>如果想在侦听器回调中能访问被 vue 更新<strong>之后</strong>的 DOM，你需要指明<code>flush &#39;post&#39;</code>选项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watch</span>(source, callback, &#123;</span><br><span class="line"> <span class="attr">flush</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(callback, &#123;</span><br><span class="line"> <span class="attr">flush</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>后置刷新的<code>watchEffect()</code>有个更方便的别名<code>watchPostEffect()</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; watchPostEffect &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">watchPostEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="comment">/* 在 Vue 更新后执行 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="停止侦听器"><a href="#停止侦听器" class="headerlink" title="停止侦听器"></a>停止侦听器</h4><p>在 <code>setup()</code> 或 <code>&lt;script setup&gt;</code> 中用同步语句创建的侦听器，会自动绑定到宿主组件实例上，并且会在宿主组件卸载时自动停止。因此，在大多数情况下，你无需关心怎么停止一个侦听器。</p>
<p>一个关键点是，侦听器必须用<strong>同步</strong>语句创建：如果用异步回调创建一个侦听器，那么它不会绑定到当前组件上，你必须手动停止它，以防内存泄漏。如下方这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; watchEffect &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">// 它会自动停止</span><br><span class="line">watchEffect(() =&gt; &#123;&#125;)</span><br><span class="line"></span><br><span class="line">// ...这个则不会！</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line"> watchEffect(() =&gt; &#123;&#125;)</span><br><span class="line">&#125;, 100)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>要手动停止一个侦听器，请调用 <code>watch</code> 或 <code>watchEffect</code> 返回的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unwatch = <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...当该侦听器不再需要时</span></span><br><span class="line"><span class="title function_">unwatch</span>()</span><br></pre></td></tr></table></figure>

<p>注意，需要异步创建侦听器的情况很少，请尽可能选择同步创建。如果需要等待一些异步数据，你可以使用条件式的侦听逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要异步请求得到的数据</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (data.<span class="property">value</span>) &#123;</span><br><span class="line">  <span class="comment">// 数据加载后执行某些操作...</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="模板引用"><a href="#模板引用" class="headerlink" title="模板引用"></a>模板引用</h3><p>虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素。要实现这一点，我们可以使用特殊的 <code>ref</code> attribute：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=<span class="string">&quot;input&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p><code>ref</code> 是一个特殊的 attribute，和 <code>v-for</code> 章节中提到的 <code>key</code> 类似。它允许我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用。这可能很有用，比如说在组件挂载时将焦点设置到一个 input 元素上，或在一个元素上初始化一个第三方库。</p>
<h4 id="访问模板引用"><a href="#访问模板引用" class="headerlink" title="访问模板引用"></a>访问模板引用</h4><p>为了通过组合式 API 获得该模板引用，我们需要声明一个同名的 ref：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, onMounted &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">// 声明一个 ref 来存放该元素的引用</span><br><span class="line">// 必须和模板里的 ref 同名</span><br><span class="line">const input = ref(null)</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line"> input.value.focus()</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;input ref=&quot;input&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>注意，你只可以<strong>在组件挂载后</strong>才能访问模板引用。如果你想在模板中的表达式上访问 <code>input</code>，在初次渲染时会是 <code>null</code>。这是因为在初次渲染前这个元素还不存在呢！</p>
<p>如果你需要侦听一个模板引用 ref 的变化，确保考虑到其值为 <code>null</code> 的情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (input.<span class="property">value</span>) &#123;</span><br><span class="line">  input.<span class="property">value</span>.<span class="title function_">focus</span>()</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 此时还未挂载，或此元素已经被卸载（例如通过 v-if 控制）</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="v-for中的模板引用"><a href="#v-for中的模板引用" class="headerlink" title="v-for中的模板引用"></a><code>v-for</code>中的模板引用</h4><p>当在 <code>v-for</code> 中使用模板引用时，对应的 ref 中包含的值是一个数组，它将在元素被挂载后包含对应整个列表的所有元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, onMounted &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const list = ref([</span><br><span class="line"> /* ... */</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">const itemRefs = ref([])</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; console.log(itemRefs.value))</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;item in list&quot; ref=&quot;itemRefs&quot;&gt;</span><br><span class="line">   &#123;&#123; item &#125;&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line"> &lt;/ul&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>应该注意的是，ref 数组<strong>并不</strong>保证与源数组相同的顺序。</p>
<h4 id="函数模板引用"><a href="#函数模板引用" class="headerlink" title="函数模板引用"></a>函数模板引用</h4><p>除了使用字符串值作名字，<code>ref</code> attribute 还可以绑定为一个函数，会在每次组件更新时都被调用。该函数会收到元素引用作为其第一个参数：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:ref</span>=<span class="string">&quot;(el) =&gt; &#123; /* 将 el 赋值给一个数据属性或 ref 变量 */ &#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意我们这里需要使用动态的 <code>:ref</code> 绑定才能够传入一个函数。当绑定的元素被卸载时，函数也会被调用一次，此时的 <code>el</code> 参数会是 <code>null</code>。你当然也可以绑定一个组件方法而不是内联函数。</p>
<h4 id="组件上的-ref"><a href="#组件上的-ref" class="headerlink" title="组件上的 ref"></a>组件上的 ref</h4><p>模板引用也可以被用在一个子组件上。这种情况下引用中获得的值是组件实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, onMounted &#125; from &quot;vue&quot;</span><br><span class="line">import Child from &quot;./Child.vue&quot;</span><br><span class="line"></span><br><span class="line">const child = ref(null)</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line"> // child.value 是 &lt;Child /&gt; 组件的实例</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;Child ref=&quot;child&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>如果一个子组件使用的是选项式 API 或没有使用 <code>&lt;script setup&gt;</code>，被引用的组件实例和该子组件的 <code>this</code> 完全一致，这意味着父组件对子组件的每一个属性和方法都有完全的访问权。这使得在父组件和子组件之间创建紧密耦合的实现细节变得很容易，当然也因此，应该只在绝对需要时才使用组件引用。大多数情况下，你应该首先使用标准的 props 和 emit 接口来实现父子组件交互。</p>
<p>有一个例外的情况，使用了 <code>&lt;script setup&gt;</code> 的组件是<strong>默认私有</strong>的：一个父组件无法访问到一个使用了 <code>&lt;script setup&gt;</code> 的子组件中的任何东西，除非子组件在其中通过 <code>defineExpose</code> 宏显式暴露：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const a = 1</span><br><span class="line">const b = ref(2)</span><br><span class="line"></span><br><span class="line">// 像 defineExpose 这样的编译器宏不需要导入</span><br><span class="line">defineExpose(&#123;</span><br><span class="line"> a,</span><br><span class="line"> b,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当父组件通过模板引用获取到了该组件的实例时，得到的实例类型为 <code>&#123; a: number, b: number &#125;</code> (ref 都会自动解包，和一般的实例一样)。</p>
<h3 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h3><h4 id="传递-props"><a href="#传递-props" class="headerlink" title="传递 props"></a>传递 props</h4><p>props 是一种特别的 attributes，你可以在组件上声明注册。要传递给博客文章组件一个标题，我们必须在组件的 props 列表上声明它。这里要用到 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits"><code>defineProps</code></a> 宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- BlogPost.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps([&quot;title&quot;])</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p><code>defineProps</code> 是一个仅 <code>&lt;script setup&gt;</code> 中可用的编译宏命令，并不需要显式地导入。声明的 props 会自动暴露给模板。<code>defineProps</code> 会返回一个对象，其中包含了可以传递给组件的所有 props：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>([<span class="string">&quot;title&quot;</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">title</span>)</span><br></pre></td></tr></table></figure>

<h4 id="监听事件-1"><a href="#监听事件-1" class="headerlink" title="监听事件"></a>监听事件</h4><p>父组件可以通过 <code>v-on</code> 或 <code>@</code> 来选择性地监听子组件上抛的事件，就像监听原生 DOM 事件那样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BlogPost ... @enlarge-text=&quot;postFontSize += 0.1&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>子组件可以通过调用内置的 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/component-instance.html#emit"><strong><code>$emit</code></strong> 方法</a>，通过传入事名称来抛出一个事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- BlogPost.vue, 省略了 &lt;script&gt; --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;div class=&quot;blog-post&quot;&gt;</span><br><span class="line">  &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;/h4&gt;</span><br><span class="line">  &lt;button @click=&quot;$emit(&#x27;enlarge-text&#x27;)&quot;&gt;Enlarge text&lt;/button&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>因为有了 <code>@enlarge-text=&quot;postFontSize += 0.1&quot;</code> 的监听，父组件会接收这一事件，从而更新 <code>postFontSize</code> 的值。</p>
<p>我们可以通过 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits"><code>defineEmits</code></a> 宏来声明需要抛出的事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- BlogPost.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps([&quot;title&quot;])</span><br><span class="line">defineEmits([&quot;enlarge-text&quot;])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这声明了一个组件可能触发的所有事件，还可以对事件的参数进行<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/components/events.html#validate-emitted-events">验证</a>。同时，这还可以让 Vue 避免将它们作为原生事件监听器隐式地应用于子组件的根元素。</p>
<p>和 <code>defineProps</code> 类似，<code>defineEmits</code> 仅可用于 <code>&lt;script setup&gt;</code> 之中，并且不需要导入，它返回一个等同于 <code>$emit</code> 方法的 <code>emit</code> 函数。它可以被用于在组件的 <code>&lt;script setup&gt;</code> 中抛出事件，因为此处无法直接访问 <code>$emit</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const emit = defineEmits([&quot;enlarge-text&quot;])</span><br><span class="line"></span><br><span class="line">emit(&quot;enlarge-text&quot;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="深入组件"><a href="#深入组件" class="headerlink" title="深入组件"></a>深入组件</h2><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>一个 Vue 组件在使用前需要先被“注册”，这样 Vue 才能在渲染模板时找到其对应的实现。组件注册有两种方式：全局注册和局部注册。</p>
<h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><p>我们可以使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/application.html">Vue 应用实例</a>的 <code>app.component()</code> 方法，让组件在当前 Vue 应用中全局可用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&quot;MyComponent&quot;</span>, <span class="title class_">MyComponent</span>)</span><br></pre></td></tr></table></figure>

<p><code>app.component()</code> 方法可以被链式调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">component</span>(<span class="string">&quot;ComponentA&quot;</span>, <span class="title class_">ComponentA</span>).<span class="title function_">component</span>(<span class="string">&quot;ComponentB&quot;</span>, <span class="title class_">ComponentB</span>).<span class="title function_">component</span>(<span class="string">&quot;ComponentC&quot;</span>, <span class="title class_">ComponentC</span>)</span><br></pre></td></tr></table></figure>

<p>全局注册的组件可以在此应用的任意组件的模板中使用。并且相互可以在彼此内部使用。</p>
<h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><p>局部注册的组件需要在使用它的父组件中显式导入，并且只能在该父组件中使用。它的优点是使组件之间的依赖关系更加明确，并且对 tree-shaking 更加友好。</p>
<h4 id="组件名格式"><a href="#组件名格式" class="headerlink" title="组件名格式"></a>组件名格式</h4><p>在 SFC 中，推荐为子组件使用<code>PascalCase</code>的标签名，以此来和原声的 HTML 元素作区分。</p>
<p>但是，PascalCase 的标签名在 DOM 模板中是不可用的，详情参见 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/component-basics.html#dom-template-parsing-caveats">DOM 模板解析注意事项</a>，在这种情况下，需要使用 <code>kebab-case</code> 形式。</p>
<p>什么是 DOM 模板？就是直接写在 DOM 中的模板，会被浏览器直接解析：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE &lt;html&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue Component<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 在 HTML 中是 kebab-case (短横线命名) 的会被渲染 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">my-Component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-Component</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">My-component</span>&gt;</span><span class="tag">&lt;/<span class="name">My-component</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">My-Component</span>&gt;</span><span class="tag">&lt;/<span class="name">My-Component</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 注册时：PascalCase (首字母大写命名)、camelCase (驼峰命名)、kebab-case (短横线命名) 都可以</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyComponent&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;Hello Vue&lt;/div&gt;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">new</span> <span class="title class_">Vue</span> (&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;my-component&gt;&lt;/my-component&gt;</code> 就是 DOM 模板。</p>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><h4 id="props-声明"><a href="#props-声明" class="headerlink" title="props 声明"></a>props 声明</h4><p>一个组件需要显式声明它所接受的 props，这样 Vue 才能知道外部传入的哪些是 props，哪些是透传 attribute (关于透传 attribute，我们会在<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/components/attrs.html">专门的章节</a>中讨论)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps([&quot;foo&quot;])</span><br><span class="line"></span><br><span class="line">console.log(props.foo)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如果使用了 ts，也可以这么声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">interface Props &#123;</span><br><span class="line"> foo: string</span><br><span class="line"> bar?: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const props = defineProps&lt;Props&gt;()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这被称之为“基于类型的声明”。感觉怪怪的。</p>
<p>当使用基于类型的声明时，我们失去了为 props 声明默认值的能力。这可以通过 <code>withDefaults</code> 编译器宏解决：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Props</span> &#123;</span><br><span class="line"> msg?: <span class="built_in">string</span></span><br><span class="line"> labels?: <span class="built_in">string</span>[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> props = <span class="title function_">withDefaults</span>(defineProps&lt;<span class="title class_">Props</span>&gt;(), &#123;</span><br><span class="line"> <span class="attr">msg</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line"> <span class="attr">labels</span>: <span class="function">() =&gt;</span> [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="传递-prop-细节"><a href="#传递-prop-细节" class="headerlink" title="传递 prop 细节"></a>传递 prop 细节</h4><h5 id="prop-名字格式"><a href="#prop-名字格式" class="headerlink" title="prop 名字格式"></a>prop 名字格式</h5><p>prop 名字使用 camelCase 形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">defineProps</span>(&#123;</span><br><span class="line"> <span class="attr">greetingMessage</span>: <span class="title class_">String</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然而对于传递 props 来说，使用 camelCase 并没有太多优势，因此我们推荐更贴近 HTML 的书写风格，使用 kebab-case 形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent greeting-message=&quot;hello&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h5 id="静态-和-动态-prop"><a href="#静态-和-动态-prop" class="headerlink" title="静态 和 动态 prop"></a>静态 和 动态 prop</h5><p>静态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BlogPost title=&quot;My journey with Vue&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>动态绑定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 根据一个变量的值动态传入 --&gt;</span><br><span class="line">&lt;BlogPost :title=&quot;post.title&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 根据一个更复杂表达式的值动态传入 --&gt;</span><br><span class="line">&lt;BlogPost :title=&quot;post.title + &#x27; by &#x27; + post.author.name&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h5 id="传递不同的值类型"><a href="#传递不同的值类型" class="headerlink" title="传递不同的值类型"></a>传递不同的值类型</h5><p>不仅仅是字符串，实际上<strong>任何</strong>类型的值都可以作为 props 的值被传递。</p>
<p><strong>Number：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 虽然 `42` 是个常量，我们还是需要使用 v-bind --&gt;</span><br><span class="line">&lt;!-- 因为这是一个 JavaScript 表达式而不是一个字符串 --&gt;</span><br><span class="line">&lt;BlogPost :likes=&quot;42&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 根据一个变量的值动态传入 --&gt;</span><br><span class="line">&lt;BlogPost :likes=&quot;post.likes&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>Boolean：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 仅写上 prop 但不传值，会隐式转换为 `true` --&gt;</span><br><span class="line">&lt;BlogPost is-published /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 虽然 `false` 是静态的值，我们还是需要使用 v-bind --&gt;</span><br><span class="line">&lt;!-- 因为这是一个 JavaScript 表达式而不是一个字符串 --&gt;</span><br><span class="line">&lt;BlogPost :is-published=&quot;false&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 根据一个变量的值动态传入 --&gt;</span><br><span class="line">&lt;BlogPost :is-published=&quot;post.isPublished&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>Array：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 虽然这个数组是个常量，我们还是需要使用 v-bind --&gt;</span><br><span class="line">&lt;!-- 因为这是一个 JavaScript 表达式而不是一个字符串 --&gt;</span><br><span class="line">&lt;BlogPost :comment-ids=&quot;[234, 266, 273]&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 根据一个变量的值动态传入 --&gt;</span><br><span class="line">&lt;BlogPost :comment-ids=&quot;post.commentIds&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>Object：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 虽然这个对象字面量是个常量，我们还是需要使用 v-bind --&gt;</span><br><span class="line">&lt;!-- 因为这是一个 JavaScript 表达式而不是一个字符串 --&gt;</span><br><span class="line">&lt;BlogPost</span><br><span class="line"> :author=&quot;&#123;</span><br><span class="line">  name: &#x27;Veronica&#x27;,</span><br><span class="line">  company: &#x27;Veridian Dynamics&#x27;,</span><br><span class="line"> &#125;&quot;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 根据一个变量的值动态传入 --&gt;</span><br><span class="line">&lt;BlogPost :author=&quot;post.author&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h4 id="使用一个对象绑定多个-prop"><a href="#使用一个对象绑定多个-prop" class="headerlink" title="使用一个对象绑定多个 prop"></a>使用一个对象绑定多个 prop</h4><p>如果你想要将一个对象的所有属性都当作 props 传入，你可以使用<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/template-syntax.html#dynamically-binding-multiple-attributes">没有参数的 <code>v-bind</code></a>，即只使用 <code>v-bind</code> 而非 <code>:prop-name</code>。例如，这里有一个 <code>post</code> 对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> post = &#123;</span><br><span class="line"> <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="attr">title</span>: <span class="string">&quot;My Journey with Vue&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BlogPost v-bind=&quot;post&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BlogPost :id=&quot;post.id&quot; :title=&quot;post.title&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h4 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h4><p>所有的 props 都遵循着<strong>单向绑定</strong>原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递。这避免了子组件意外修改父组件的状态的情况，不然应用的数据流将很容易变得混乱而难以理解。</p>
<p>另外，每次父组件更新后，所有的子组件中的 props 都会被更新到最新值，这意味着你<strong>不应该</strong>在子组件中去更改一个 prop。若你这么做了，Vue 会在控制台上向你抛出警告。</p>
<h5 id="更改对象-x2F-数组类型的-props"><a href="#更改对象-x2F-数组类型的-props" class="headerlink" title="更改对象 &#x2F; 数组类型的 props"></a>更改对象 &#x2F; 数组类型的 props</h5><p>当对象或数组作为 props 被传入时，虽然子组件无法更改 props 绑定，但仍然<strong>可以</strong>更改对象或数组内部的值。这是因为 JavaScript 的对象和数组是按引用传递，而对 Vue 来说，禁止这样的改动，虽然可能生效，但有很大的性能损耗，比较得不偿失。</p>
<p>这种更改的主要缺陷是它允许了子组件以某种不明显的方式影响父组件的状态，可能会使数据流在将来变得更难以理解。在最佳实践中，你应该尽可能避免这样的更改，除非父子组件在设计上本来就需要紧密耦合。在大多数场景下，子组件应该<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/components/events.html">抛出一个事件</a>来通知父组件做出改变。</p>
<h3 id="组件事件"><a href="#组件事件" class="headerlink" title="组件事件"></a>组件事件</h3><h4 id="触发与监听事件"><a href="#触发与监听事件" class="headerlink" title="触发与监听事件"></a>触发与监听事件</h4><p>在组件的模板表达式中，可以直接使用 <code>$emit</code> 方法触发自定义事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- MyComponent --&gt;</span><br><span class="line">&lt;button @click=&quot;$emit(&#x27;increaseBy&#x27;, 1)&quot;&gt;</span><br><span class="line">  Increase by 1</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>父组件监听事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyButton @increase-by=&quot;n =&gt; (count += n)&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>同样，组件的事件监听器也支持 <code>.once</code> 修饰符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent @some-event.once=&quot;callback&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>像组件与 prop 一样，事件的名字也提供了自动的格式转换。注意这里我们触发了一个以 camelCase 形式命名的事件，但在父组件中可以使用 kebab-case 形式来监听。与 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/components/props.html#prop-name-casing">prop 大小写格式</a>一样，在模板中我们也推荐使用 kebab-case 形式来编写监听器。</p>
<blockquote>
<p>提示：</p>
<p>和原生 DOM 事件不一样，组件触发的事件<strong>没有冒泡机制</strong>。你只能监听直接子组件触发的事件。平级组件或是跨越多层嵌套的组件间通信，应使用一个外部的事件总线，或是使用一个<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/scaling-up/state-management.html">全局状态管理方案</a>。</p>
</blockquote>
<h4 id="声明触发的事件"><a href="#声明触发的事件" class="headerlink" title="声明触发的事件"></a>声明触发的事件</h4><p>组件可以显式地通过 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits"><code>defineEmits()</code></a> 宏来声明它要触发的事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">const emit = defineEmits&lt;&#123;</span><br><span class="line"> (e: &quot;change&quot;, id: number): void</span><br><span class="line"> (e: &quot;update&quot;, value: string): void</span><br><span class="line">&#125;&gt;()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>我们在 <code>&lt;template&gt;</code> 中使用的 <code>$emit</code> 方法不能在组件的 <code>&lt;script setup&gt;</code> 部分中使用，但 <code>defineEmits()</code> 会返回一个相同作用的函数供我们使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const emit = defineEmits&lt;&#123;</span><br><span class="line">  (e: &#x27;change&#x27;, id: number): void</span><br><span class="line">  (e: &#x27;update&#x27;, value: string): void</span><br><span class="line">&#125;&gt;()</span><br><span class="line"></span><br><span class="line">function buttonClick() &#123;</span><br><span class="line">  emit(&#x27;submit&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="组件-v-model"><a href="#组件-v-model" class="headerlink" title="组件 v-model"></a>组件 v-model</h3><p><code>v-model</code> 可以在组件上使用以实现双向绑定。</p>
<p>首先让我们回忆一下 <code>v-model</code> 在原生元素上的用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;searchText&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>模板编译器会对 <code>v-model</code> 进行冗长的等价展开。因此上面的代码其实等价于下面这段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input :value=&quot;searchText&quot; @input=&quot;searchText = $event.target.value&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>而当使用在一个组件上时，<code>v-model</code> 会被展开为如下的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;CustomInput :modelValue=&quot;searchText&quot; @update:modelValue=&quot;newValue =&gt; (searchText = newValue)&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>所以，<code>&lt;CustomInput&gt;</code> 组件内部需要做两件事：</p>
<ol>
<li>将内部原生 <code>&lt;input&gt;</code> 元素的 <code>value</code> attribute 绑定到 <code>modelValue</code> prop</li>
<li>当原生的 <code>input</code> 事件触发时，触发一个携带了新值的 <code>update:modelValue</code> 自定义事件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- CustomInput.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps([&quot;modelValue&quot;])</span><br><span class="line">defineEmits([&quot;update:modelValue&quot;])</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;input :value=&quot;modelValue&quot; @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>现在 <code>v-model</code> 可以在这个组件上正常工作了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;CustomInput v-model=&quot;searchText&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>另一种在组件内实现 <code>v-model</code> 的方式是使用一个可写的，同时具有 getter 和 setter 的 <code>computed</code> 属性。<code>get</code> 方法需返回 <code>modelValue</code> prop，而 <code>set</code> 方法需触发相应的事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- CustomInput.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; computed &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const props = defineProps([&quot;modelValue&quot;])</span><br><span class="line">const emit = defineEmits([&quot;update:modelValue&quot;])</span><br><span class="line"></span><br><span class="line">const value = computed(&#123;</span><br><span class="line"> get() &#123;</span><br><span class="line">  return props.modelValue</span><br><span class="line"> &#125;,</span><br><span class="line"> set(value) &#123;</span><br><span class="line">  emit(&quot;update:modelValue&quot;, value)</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;input v-model=&quot;value&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="v-model-的参数"><a href="#v-model-的参数" class="headerlink" title="v-model 的参数"></a><code>v-model</code> 的参数</h4><p>默认情况下，<code>v-model</code> 在组件上都是使用 <code>modelValue</code> 作为 prop，并以 <code>update:modelValue</code> 作为对应的事件。我们可以通过给 <code>v-model</code> 指定一个参数来更改这些名字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent v-model:title=&quot;bookTitle&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，子组件应声明一个 <code>title</code> prop，并通过触发 <code>update:title</code> 事件更新父组件值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- MyComponent.vue --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps([&quot;title&quot;])</span><br><span class="line">defineEmits([&quot;update:title&quot;])</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;input type=&quot;text&quot; :value=&quot;title&quot; @input=&quot;$emit(&#x27;update:title&#x27;, $event.target.value)&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="多个v-model绑定"><a href="#多个v-model绑定" class="headerlink" title="多个v-model绑定"></a>多个<code>v-model</code>绑定</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;UserName v-model:first-name=&quot;first&quot; v-model:last-name=&quot;last&quot; /&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps(&#123;</span><br><span class="line"> firstName: String,</span><br><span class="line"> lastName: String,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">defineEmits([&quot;update:firstName&quot;, &quot;update:lastName&quot;])</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;input type=&quot;text&quot; :value=&quot;firstName&quot; @input=&quot;$emit(&#x27;update:firstName&#x27;, $event.target.value)&quot; /&gt;</span><br><span class="line"> &lt;input type=&quot;text&quot; :value=&quot;lastName&quot; @input=&quot;$emit(&#x27;update:lastName&#x27;, $event.target.value)&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="处理v-model修饰符"><a href="#处理v-model修饰符" class="headerlink" title="处理v-model修饰符"></a>处理<code>v-model</code>修饰符</h4><p>在学习输入绑定时，我们知道了 <code>v-model</code> 有一些<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/forms.html#modifiers">内置的修饰符</a>，例如 <code>.trim</code>，<code>.number</code> 和 <code>.lazy</code>。在某些场景下，你可能想要一个自定义组件的 <code>v-model</code> 支持自定义的修饰符。</p>
<p>我们来创建一个自定义的修饰符 <code>capitalize</code>，它会自动将 <code>v-model</code> 绑定输入的字符串值第一个字母转为大写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent v-model.capitalize=&quot;myText&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>组件的 <code>v-model</code> 上所添加的修饰符，可以通过 <code>modelModifiers</code> prop 在组件内访问到。在下面的组件中，我们声明了 <code>modelModifiers</code> 这个 prop，它的默认值是一个空对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line"> modelValue: String,</span><br><span class="line"> modelModifiers: &#123; default: () =&gt; (&#123;&#125;) &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">defineEmits([&quot;update:modelValue&quot;])</span><br><span class="line"></span><br><span class="line">console.log(props.modelModifiers) // &#123; capitalize: true &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;$emit(&#x27;update:modelValue&#x27;, $event.target.value)&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>注意这里组件的 <code>modelModifiers</code> prop 包含了 <code>capitalize</code> 且其值为 <code>true</code>，因为它在模板中的 <code>v-model</code> 绑定 <code>v-model.capitalize=&quot;myText&quot;</code> 上被使用了。</p>
<p>有了这个 prop，我们就可以检查 <code>modelModifiers</code> 对象的键，并编写一个处理函数来改变抛出的值。在下面的代码里，我们就是在每次 <code>&lt;input /&gt;</code> 元素触发 <code>input</code> 事件时将值的首字母大写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line"> modelValue: String,</span><br><span class="line"> modelModifiers: &#123; default: () =&gt; (&#123;&#125;) &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const emit = defineEmits([&quot;update:modelValue&quot;])</span><br><span class="line"></span><br><span class="line">function emitValue(e) &#123;</span><br><span class="line"> let value = e.target.value</span><br><span class="line"> if (props.modelModifiers.capitalize) &#123;</span><br><span class="line">  value = value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line"> &#125;</span><br><span class="line"> emit(&quot;update:modelValue&quot;, value)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;emitValue&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>对于又有参数又有修饰符的 <code>v-model</code> 绑定，生成的 prop 名将是 <code>arg + &quot;Modifiers&quot;</code>。举例来说：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent v-model:title.capitalize=&quot;myText&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>相应的声明应该是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>([<span class="string">&quot;title&quot;</span>, <span class="string">&quot;titleModifiers&quot;</span>])</span><br><span class="line"><span class="title function_">defineEmits</span>([<span class="string">&quot;update:title&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">titleModifiers</span>) <span class="comment">// &#123; capitalize: true &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="透传-attributes"><a href="#透传-attributes" class="headerlink" title="透传 attributes"></a>透传 attributes</h3><h4 id="attributes-继承"><a href="#attributes-继承" class="headerlink" title="attributes 继承"></a>attributes 继承</h4><p>“透传 attribute”指的是传递给一个组件，却没有被该组件声明为 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/components/props.html">props</a> 或 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/components/events.html#defining-custom-events">emits</a> 的 attribute 或者 <code>v-on</code> 事件监听器。最常见的例子就是 <code>class</code>、<code>style</code> 和 <code>id</code>。</p>
<p>当一个组件以单个元素为根作渲染时，透传的 attribute 会自动被添加到<strong>根元素</strong>上。举例来说，假如我们有一个 <code>&lt;MyButton&gt;</code> 组件，它的模板长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;MyButton&gt; 的模板 --&gt;</span><br><span class="line">&lt;button&gt;click me&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>一个父组件使用了这个组件，并且传入了 <code>class</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyButton class=&quot;large&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>最后渲染出的 DOM 结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button class=&quot;large&quot;&gt;click me&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>这里，<code>&lt;MyButton&gt;</code> 并没有将 <code>class</code> 声明为一个它所接受的 prop，所以 <code>class</code> 被视作透传 attribute，自动透传到了 <code>&lt;MyButton&gt;</code> 的根元素上。</p>
<h5 id="对-class-和-style-的合并"><a href="#对-class-和-style-的合并" class="headerlink" title="对 class 和 style 的合并"></a>对 <code>class</code> 和 <code>style</code> 的合并</h5><p>如果一个子组件的根元素已经有了 <code>class</code> 或 <code>style</code> attribute，它会和从父组件上继承的值合并。如果我们将之前的 <code>&lt;MyButton&gt;</code> 组件的模板改成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;MyButton&gt; 的模板 --&gt;</span><br><span class="line">&lt;button class=&quot;btn&quot;&gt;click me&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>则最后渲染出的 DOM 结果会变成：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn large&quot;</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="v-on-监听器继承"><a href="#v-on-监听器继承" class="headerlink" title="v-on 监听器继承"></a><code>v-on</code> 监听器继承</h5><p>同样的规则也适用于 <code>v-on</code> 事件监听器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyButton @click=&quot;onClick&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><code>click</code> 监听器会被添加到 <code>&lt;MyButton&gt;</code> 的根元素，即那个原生的 <code>&lt;button&gt;</code> 元素之上。当原生的 <code>&lt;button&gt;</code> 被点击，会触发父组件的 <code>onClick</code> 方法。同样的，如果原生 <code>button</code> 元素自身也通过 <code>v-on</code> 绑定了一个事件监听器，则这个监听器和从父组件继承的监听器都会被触发。</p>
<h5 id="深层组件继承"><a href="#深层组件继承" class="headerlink" title="深层组件继承"></a>深层组件继承</h5><p>有些情况下一个组件会在根节点上渲染另一个组件。例如，我们重构一下 <code>&lt;MyButton&gt;</code>，让它在根节点上渲染 <code>&lt;BaseButton&gt;</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- &lt;MyButton/&gt; 的模板，只是渲染另一个组件 --&gt;</span><br><span class="line">&lt;BaseButton /&gt;</span><br></pre></td></tr></table></figure>

<p>此时 <code>&lt;MyButton&gt;</code> 接收的透传 attribute 会直接继续传给 <code>&lt;BaseButton&gt;</code>。</p>
<p>请注意：</p>
<ol>
<li>透传的 attribute 不会包含 <code>&lt;MyButton&gt;</code> 上声明过的 props 或是针对 <code>emits</code> 声明事件的 <code>v-on</code> 侦听函数，换句话说，<strong>声明过的 props 和侦听函数被 <code>&lt;MyButton&gt;</code>“消费”了</strong>。</li>
<li>透传的 attribute 若符合声明，也可以作为 props 传入 <code>&lt;BaseButton&gt;</code>。</li>
</ol>
<h4 id="禁用-attributes-继承"><a href="#禁用-attributes-继承" class="headerlink" title="禁用 attributes 继承"></a>禁用 attributes 继承</h4><p>如果你<strong>不想要</strong>一个组件自动地继承 attribute，你可以在组件选项中设置 <code>inheritAttrs: false</code>。</p>
<p>如果你使用了 <code>&lt;script setup&gt;</code>，你需要一个额外的 <code>&lt;script&gt;</code> 块来书写这个选项声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">// 使用普通的 &lt;script&gt; 来声明选项</span><br><span class="line">export default &#123;</span><br><span class="line"> inheritAttrs: false,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">// ...setup 部分逻辑</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>最常见的需要禁用 attribute 继承的场景就是 attribute 需要应用在根节点以外的其他元素上。通过设置 <code>inheritAttrs</code> 选项为 <code>false</code>，你可以完全控制透传进来的 attribute 被如何使用。</p>
<p>这些透传进来的 attribute 可以在模板的表达式中直接用 <code>$attrs</code> 访问到。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;Fallthrough attribute: &#123;&#123; $attrs &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>这个 <code>$attrs</code> 对象包含了除组件所声明的 <code>props</code> 和 <code>emits</code> 之外的所有其他 attribute，例如 <code>class</code>，<code>style</code>，<code>v-on</code> 监听器等等。</p>
<p>有几点需要注意：</p>
<ul>
<li>和 props 有所不同，透传 attributes 在 JavaScript 中保留了它们原始的大小写，所以像 <code>foo-bar</code> 这样的一个 attribute 需要通过 <code>$attrs[&#39;foo-bar&#39;]</code> 来访问。</li>
<li>像 <code>@click</code> 这样的一个 <code>v-on</code> 事件监听器将在此对象下被暴露为一个函数 <code>$attrs.onClick</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;btn-wrapper&quot;&gt;</span><br><span class="line">  &lt;button class=&quot;btn&quot; v-bind=&quot;$attrs&quot;&gt;click me&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>小提示：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/template-syntax.html#dynamically-binding-multiple-attributes">没有参数的 <code>v-bind</code></a> 会将一个对象的所有属性都作为 attribute 应用到目标元素上。</p>
<h4 id="多根节点的-attributes-继承"><a href="#多根节点的-attributes-继承" class="headerlink" title="多根节点的 attributes 继承"></a>多根节点的 attributes 继承</h4><p>和单根节点组件有所不同，有着多个根节点的组件没有自动 attribute 透传行为。如果 <code>$attrs</code> 没有被显式绑定，将会抛出一个运行时警告。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;CustomLayout id=&quot;custom-layout&quot; @click=&quot;changeValue&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>如果 <code>&lt;CustomLayout&gt;</code> 有下面这样的多根节点模板，由于 Vue 不知道要将 attribute 透传到哪里，所以会抛出一个警告。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>...<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>...<span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>...<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果 <code>$attrs</code> 被显式绑定，则不会有警告：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;...&lt;/header&gt;</span><br><span class="line">&lt;main v-bind=&quot;$attrs&quot;&gt;...&lt;/main&gt;</span><br><span class="line">&lt;footer&gt;...&lt;/footer&gt;</span><br></pre></td></tr></table></figure>

<h4 id="在-JavaScript-中访问透传-Attributes"><a href="#在-JavaScript-中访问透传-Attributes" class="headerlink" title="在 JavaScript 中访问透传 Attributes"></a>在 JavaScript 中访问透传 Attributes</h4><p>如果需要，你可以在 <code>&lt;script setup&gt;</code> 中使用 <code>useAttrs()</code> API 来访问一个组件的所有透传 attribute：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useAttrs &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const attrs = useAttrs()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，虽然这里的 <code>attrs</code> 对象总是反映为最新的透传 attribute，但它并不是响应式的 (考虑到性能因素)。你不能通过侦听器去监听它的变化。如果你需要响应性，可以使用 prop。或者你也可以使用声明周期函数 <code>onUpdated()</code> 使得在每次更新时结合最新的 <code>attrs</code> 执行副作用。</p>
<h3 id="插槽-slots"><a href="#插槽-slots" class="headerlink" title="插槽 slots"></a>插槽 slots</h3><p>依靠 props 传值，还是不够，如果要传递模板内容，则需要使用插槽 slots。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;FancyButton&gt;</span><br><span class="line">  Click me! &lt;!-- 插槽内容 --&gt;</span><br><span class="line">&lt;/FancyButton&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;FancyButton&gt;</code> 模板是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button class=&quot;fancy-btn&quot;&gt;</span><br><span class="line">  &lt;slot&gt;&lt;/slot&gt; &lt;!-- 插槽出口 --&gt;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;slot&gt;</code> 元素是一个<strong>插槽出口</strong> (slot outlet)，标示了父元素提供的<strong>插槽内容</strong> (slot content) 将在哪里被渲染。</p>
<p><img data-src="//img.to2b.cn/blog/ljk/1677055310606.png"></p>
<p>最终渲染出的 DOM 是这样：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;fancy-btn&quot;</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="多个插槽"><a href="#多个插槽" class="headerlink" title="多个插槽"></a>多个插槽</h4><p>如果有多个插槽，需要给插槽命名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>这类带 <code>name</code> 的插槽被称为具名插槽 (named slots)。没有提供 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会隐式地命名为“default”。</p>
<p>要为具名插槽传入内容，我们需要使用一个含 <code>v-slot</code> 指令的 <code>&lt;template&gt;</code> 元素，并将目标插槽的名字传给该指令，<code>v-slot</code> 有对应的简写 <code>#</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;BaseLayout&gt;</span><br><span class="line">  &lt;template #header&gt;</span><br><span class="line">    &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template #default&gt;</span><br><span class="line">    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template #footer&gt;</span><br><span class="line">    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/BaseLayout&gt;</span><br></pre></td></tr></table></figure>

<p><img data-src="//img.to2b.cn/blog/ljk/1677055853340.png"></p>
<p>当一个组件同时接收默认插槽和具名插槽时，所有位于顶级的非 <code>&lt;template&gt;</code> 节点都被隐式地视为默认插槽的内容。所以上面也可以写成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;BaseLayout&gt;</span><br><span class="line">  &lt;template #header&gt;</span><br><span class="line">    &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 隐式的默认插槽 --&gt;</span><br><span class="line">  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template #footer&gt;</span><br><span class="line">    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/BaseLayout&gt;</span><br></pre></td></tr></table></figure>

<h4 id="向插槽传参"><a href="#向插槽传参" class="headerlink" title="向插槽传参"></a>向插槽传参</h4><p>Vue 模板中的表达式只能访问其定义时所处的作用域，这和 JavaScript 的词法作用域规则是一致的。</p>
<p>子组件定义插槽，父组件中使用子组件的时候，定义插槽中的内容。</p>
<p>插槽中内容是在父组件中定义的，所以插槽中只能访问父组件的作用域，但是如果插槽中需要使用到子组件作用域中的数据，怎么办？</p>
<p>子组件在定义插槽的时候，将需要使用到的数据传入插槽，这样，父组件在定义插槽中的内容时，就能使用传入的数据了。</p>
<p>定义组件 <code>FacyList</code>，并将<code>item</code>传入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;item in items&quot;&gt;</span><br><span class="line">    &lt;slot name=&quot;item&quot; :body=&quot;item.body&quot; :username=&quot;item.username&quot; :likes=&quot;item.links&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for=&quot;item in items&quot;&gt;</span><br><span class="line">    &lt;slot name=&quot;item&quot; v-bind=&quot;item&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>

<p>注意：插槽上的 <code>name</code> 是一个 Vue 特别保留的 attribute，不会作为 props 传递给插槽。</p>
<p>在父组件中引用子组件 <code>FancyList</code>，可以使用传入的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;FancyList&gt;</span><br><span class="line">  &lt;template #item=&quot;&#123; body, username, likes &#125;&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;</span><br><span class="line">      &lt;p&gt;&#123;&#123; body &#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;by &#123;&#123; username &#125;&#125; | &#123;&#123; likes &#125;&#125; likes&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/FancyList&gt;</span><br></pre></td></tr></table></figure>

<h4 id="无渲染组件"><a href="#无渲染组件" class="headerlink" title="无渲染组件"></a>无渲染组件</h4><p>一些组件可能只包括了逻辑而不需要自己渲染内容，视图输出通过作用域插槽全权交给了消费者组件。我们将这种类型的组件称为<strong>无渲染组件</strong>。</p>
<p>大部分能用无渲染组件实现的功能都可以通过组合式 API 以另一种更高效的方式实现，并且还不会带来额外组件嵌套的开销。</p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>深层的组件需要顶层的数据，如果通过层层组件逐级传递 props，会很麻烦，中间层的组件可能根本不关系这些 props。</p>
<p>这个问题被称为 “<strong>prop 逐级透传</strong>”。</p>
<img data-src="//img.to2b.cn/blog/ljk/1677062368602.png" style="zoom:50%;" />

<p><code>provide</code>（提供） 和 <code>inject</code>（注入） 可以帮助我们解决这一问题。一个父组件相对于其所有的后代组件，会作为<strong>依赖提供者</strong>。任何后代的组件树，无论层级有多深，都可以<strong>注入</strong>由父组件提供给整条链路的依赖。</p>
<img data-src="//img.to2b.cn/blog/ljk/1677062470008.png" style="zoom:50%;" />

<h4 id="provide（提供）"><a href="#provide（提供）" class="headerlink" title="provide（提供）"></a>provide（提供）</h4><p>要为组件后代提供数据，需要使用到 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/composition-api-dependency-injection.html#provide"><code>provide()</code></a> 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; provide &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">provide(/* 注入名 */ &quot;message&quot;, /* 值 */ &quot;hello!&quot;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注入名</strong> 可以是字符串或是 <code>Symbol</code>。</p>
<p>后代组件会用注入名来查找期望注入的值。</p>
<p>可以多次调用 <code>provide()</code>，使用不同的注入名，注入不同的依赖值。</p>
<p><strong>值</strong> 可以是任意类型，包括响应式的状态，比如一个 ref：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, provide &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line"><span class="title function_">provide</span>(<span class="string">&quot;key&quot;</span>, count)</span><br></pre></td></tr></table></figure>

<p>提供的响应式状态使后代组件可以由此和提供者建立响应式的联系。</p>
<h5 id="应用层-provide"><a href="#应用层-provide" class="headerlink" title="应用层 provide"></a>应用层 provide</h5><p>除了在一个组件中提供依赖，我们还可以在整个应用层面提供依赖：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">provide</span>(<span class="comment">/* 注入名 */</span> <span class="string">&quot;message&quot;</span>, <span class="comment">/* 值 */</span> <span class="string">&quot;hello!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在应用级别提供的数据在该应用内的所有组件中都可以注入。这在你编写<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/reusability/plugins.html">插件</a>时会特别有用，因为插件一般都不会使用组件形式来提供值。</p>
<h4 id="inject（注入）"><a href="#inject（注入）" class="headerlink" title="inject（注入）"></a>inject（注入）</h4><p>要注入上层组件提供的数据，需使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/composition-api-dependency-injection.html#inject"><code>inject()</code></a> 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; inject &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const message = inject(&quot;message&quot;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如果提供的值是一个 ref，注入进来的会是该 ref 对象，而<strong>不会</strong>自动解包为其内部的值。这使得注入方组件能够通过 ref 对象保持了和供给方的响应性链接。</p>
<h5 id="注入默认值"><a href="#注入默认值" class="headerlink" title="注入默认值"></a>注入默认值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果没有祖先组件提供 &quot;message&quot;</span></span><br><span class="line"><span class="comment">// `value` 会是 &quot;这是默认值&quot;</span></span><br><span class="line"><span class="keyword">const</span> value = <span class="title function_">inject</span>(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;这是默认值&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><figcaption><span>s</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const value = inject(&#x27;key&#x27;, () =&gt; new ExpensiveClass())</span><br></pre></td></tr></table></figure>

<h4 id="和响应式数据配合使用"><a href="#和响应式数据配合使用" class="headerlink" title="和响应式数据配合使用"></a>和响应式数据配合使用</h4><p>当提供 &#x2F; 注入响应式的数据时，<strong>建议尽可能将任何对响应式状态的变更都保持在供给方组件中</strong>。这样可以确保所提供状态的声明和变更操作都内聚在同一个组件内，使其更容易维护。</p>
<p>有的时候，我们可能需要在注入方组件中更改数据。在这种情况下，我们推荐在供给方组件内声明并提供一个更改数据的方法函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在供给方组件内 --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; provide, ref &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const location = ref(&quot;North Pole&quot;)</span><br><span class="line"></span><br><span class="line">function updateLocation() &#123;</span><br><span class="line"> location.value = &quot;South Pole&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">provide(&quot;location&quot;, &#123;</span><br><span class="line"> location,</span><br><span class="line"> updateLocation,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在注入方组件 --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; inject &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const &#123; location, updateLocation &#125; = inject(&quot;location&quot;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;button @click=&quot;updateLocation&quot;&gt;&#123;&#123; location &#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>最后，如果你想确保提供的数据不能被注入方的组件更改，你可以使用 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/reactivity-core.html#readonly"><code>readonly()</code></a> 来包装提供的值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, provide, readonly &#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">const count = ref(0)</span><br><span class="line">provide(&quot;read-only-count&quot;, readonly(count))</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="使用-symbol-作为注入名"><a href="#使用-symbol-作为注入名" class="headerlink" title="使用 symbol 作为注入名"></a>使用 symbol 作为注入名</h4><p>如果你正在构建大型的应用，包含非常多的依赖提供，或者你正在编写提供给其他开发者使用的组件库，建议最好使用 Symbol 来作为注入名以避免潜在的冲突。</p>
<p>我们通常推荐在一个单独的文件中导出这些注入名 Symbol：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// keys.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> myInjectionKey = <span class="title class_">Symbol</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在供给方组件中</span></span><br><span class="line"><span class="keyword">import</span> &#123; provide &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; myInjectionKey &#125; <span class="keyword">from</span> <span class="string">&quot;./keys.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">provide</span>(myInjectionKey, &#123;</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  要提供的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入方组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; myInjectionKey &#125; <span class="keyword">from</span> <span class="string">&quot;./keys.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> injected = <span class="title function_">inject</span>(myInjectionKey)</span><br></pre></td></tr></table></figure>

<h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>在大型项目中，我们可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件。Vue 提供了 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/general.html#defineasynccomponent"><code>defineAsyncComponent</code></a> 方法来实现此功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...从服务器获取组件</span></span><br><span class="line">  <span class="title function_">resolve</span>(<span class="comment">/* 获取到的组件 */</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ... 像使用其他一般组件一样使用 `AsyncComp`</span></span><br></pre></td></tr></table></figure>

<p>如你所见，<code>defineAsyncComponent</code> 方法接收一个返回 Promise 的加载函数。这个 Promise 的 <code>resolve</code> 回调方法应该在从服务器获得组件定义时调用。你也可以调用 <code>reject(reason)</code> 表明加载失败。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import">ES 模块动态导入</a>也会返回一个 Promise，所以多数情况下我们会将它和 <code>defineAsyncComponent</code> 搭配使用。类似 Vite 和 Webpack 这样的构建工具也支持此语法 (并且会将它们作为打包时的代码分割点)，因此我们也可以用它来导入 Vue 单文件组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineAsyncComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./components/MyComponent.vue&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>最后得到的 <code>AsyncComp</code> 是一个外层包装过的组件，仅在页面需要它渲染时才会调用加载内部实际组件的函数。它会将接收到的 props 和插槽传给内部组件，所以你可以使用这个异步的包装组件无缝地替换原始组件，同时实现延迟加载。</p>
<h4 id="加载与错误状态"><a href="#加载与错误状态" class="headerlink" title="加载与错误状态"></a>加载与错误状态</h4><p>异步操作不可避免地会涉及到加载和错误状态，因此 <code>defineAsyncComponent()</code> 也支持在高级选项中处理这些状态：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">AsyncComp</span> = <span class="title function_">defineAsyncComponent</span>(&#123;</span><br><span class="line"> <span class="comment">// 加载函数</span></span><br><span class="line"> <span class="attr">loader</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./Foo.vue&quot;</span>),</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 加载异步组件时使用的组件</span></span><br><span class="line"> <span class="attr">loadingComponent</span>: <span class="title class_">LoadingComponent</span>,</span><br><span class="line"> <span class="comment">// 展示加载组件前的延迟时间，默认为 200ms</span></span><br><span class="line"> <span class="attr">delay</span>: <span class="number">200</span>,</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 加载失败后展示的组件</span></span><br><span class="line"> <span class="attr">errorComponent</span>: <span class="title class_">ErrorComponent</span>,</span><br><span class="line"> <span class="comment">// 如果提供了一个 timeout 时间限制，并超时了</span></span><br><span class="line"> <span class="comment">// 也会显示这里配置的报错组件，默认值是：Infinity</span></span><br><span class="line"> <span class="attr">timeout</span>: <span class="number">3000</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果提供了一个加载组件，它将在内部组件加载时先行显示。在加载组件显示之前有一个默认的 200ms 延迟——这是因为在网络状况较好时，加载完成得很快，加载组件和最终组件之间的替换太快可能产生闪烁，反而影响用户感受。</p>
<p>如果提供了一个报错组件，则它会在加载器函数返回的 Promise 抛错时被渲染。你还可以指定一个超时时间，在请求耗时超过指定时间时也会渲染报错组件。</p>
<h4 id="搭配-Suspense-使用"><a href="#搭配-Suspense-使用" class="headerlink" title="搭配 Suspense 使用"></a>搭配 Suspense 使用</h4><p>异步组件可以搭配内置的 <code>&lt;Suspense&gt;</code> 组件一起使用，若想了解 <code>&lt;Suspense&gt;</code> 和异步组件之间交互，请参阅 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/built-ins/suspense.html"><code>Suspense</code></a> 章节。</p>
<h2 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h2><h3 id="组合式函数"><a href="#组合式函数" class="headerlink" title="组合式函数"></a>组合式函数</h3><p>复用<strong>无状态逻辑</strong>的库有很多，比如你可能已经用过的 <a target="_blank" rel="noopener" href="https://lodash.com/">lodash</a> 或是 <a target="_blank" rel="noopener" href="https://date-fns.org/">date-fns</a>。</p>
<p>在 Vue 中，复用<strong>有状态逻辑</strong>使用“组合式函数”(Composables) 。</p>
<p>和组件一样，可以在组合式函数中使用所有的 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/#composition-api">组合式 API</a>，并返回需要暴露的状态。</p>
<p>更酷的是，你还可以嵌套多个组合式函数：一个组合式函数可以调用一个或多个其他的组合式函数。这使得我们可以像使用多个组件组合成整个应用一样，用多个较小且逻辑独立的单元来组合形成复杂的逻辑。实际上，这正是为什么我们决定将实现了这一设计模式的 API 集合命名为组合式 API。</p>
<h4 id="异步状态示例示例"><a href="#异步状态示例示例" class="headerlink" title="异步状态示例示例"></a>异步状态示例示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useFetch</span> = (<span class="params">url: string</span>) =&gt; &#123;</span><br><span class="line"> <span class="keyword">const</span> data = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"> <span class="keyword">const</span> loading = <span class="title function_">ref</span>(<span class="literal">true</span>)</span><br><span class="line"> <span class="keyword">const</span> error = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"> <span class="keyword">const</span> <span class="title function_">request</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">  <span class="variable language_">window</span></span><br><span class="line">   .<span class="title function_">fetch</span>(url)</span><br><span class="line">   .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">   .<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> (data.<span class="property">value</span> = json))</span><br><span class="line">   .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> (error.<span class="property">value</span> = err))</span><br><span class="line">   .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> (loading.<span class="property">value</span> = <span class="literal">false</span>))</span><br><span class="line"></span><br><span class="line"> <span class="title function_">request</span>()</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">  data,</span><br><span class="line">  loading,</span><br><span class="line">  error,</span><br><span class="line">  <span class="attr">refetch</span>: request,</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; useFetch &#125; from &quot;@/utils/fetch&quot;</span><br><span class="line"></span><br><span class="line">const &#123; data, loading, error, refetch &#125; = useFetch(&quot;http://101.43.187.22:9501/api/nav/wallPaper&quot;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;el-button @click=&quot;refetch&quot;&gt;refresh&lt;/el-button&gt;</span><br><span class="line"> &lt;el-row v-for=&quot;url of data?.result&quot; :key=&quot;url&quot; v-loading=&quot;loading&quot;&gt;&#123;&#123; url &#125;&#125;&lt;/el-row&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>推荐使用 <a target="_blank" rel="noopener" href="https://tanstack.com/query/latest/docs/vue/reference/useQuery">TanStack Query</a> 库。</p>
<h4 id="约定和最佳实践"><a href="#约定和最佳实践" class="headerlink" title="约定和最佳实践"></a>约定和最佳实践</h4><h5 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h5><p>组合式函数约定用驼峰命名法命名，并以“use”作为开头。</p>
<h5 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h5><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>你可能已经注意到了，我们一直在组合式函数中使用 <code>ref()</code> 而不是 <code>reactive()</code>。我们推荐的约定是组合式函数始终返回一个包含多个 ref 的普通的非响应式对象，这样该对象在组件中被解构为 ref 之后仍可以保持响应性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x 和 y 是两个 ref</span></span><br><span class="line"><span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">useMouse</span>()</span><br></pre></td></tr></table></figure>

<p>从组合式函数返回一个响应式对象会导致在对象解构过程中丢失与组合式函数内状态的响应性连接。与之相反，ref 则可以维持这一响应性连接。</p>
<p>如果你更希望以对象属性的形式来使用组合式函数中返回的状态，你可以将返回的对象用 <code>reactive()</code> 包装一次，这样其中的 ref 会被自动解包，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mouse = <span class="title function_">reactive</span>(<span class="title function_">useMouse</span>())</span><br><span class="line"><span class="comment">// mouse.x 链接到了原来的 x ref</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mouse.<span class="property">x</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mouse position is at: &#123;&#123; mouse.x &#125;&#125;, &#123;&#123; mouse.y &#125;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h5><p>在组合式函数中的确可以执行副作用 (例如：添加 DOM 事件监听器或者请求数据)，但请注意以下规则：</p>
<ul>
<li><p>如果你的应用用到了<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/scaling-up/ssr.html">服务端渲染</a> (SSR)，请确保在组件挂载后才调用的生命周期钩子中执行 DOM 相关的副作用，例如：<code>onMounted()</code>。这些钩子仅会在浏览器中被调用，因此可以确保能访问到 DOM。</p>
</li>
<li><p>确保在 <code>onUnmounted()</code> 时清理副作用。举例来说，如果一个组合式函数设置了一个事件监听器，它就应该在 <code>onUnmounted()</code> 中被移除。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; onMounted, onUnmounted &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useEventListener</span>(<span class="params">target, event, callback</span>) &#123;</span><br><span class="line"> <span class="comment">// 如果你想的话，</span></span><br><span class="line"> <span class="comment">// 也可以用字符串形式的 CSS 选择器来寻找目标 DOM 元素</span></span><br><span class="line"> <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> target.<span class="title function_">addEventListener</span>(event, callback))</span><br><span class="line"> <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> target.<span class="title function_">removeEventListener</span>(event, callback)) <span class="comment">// 清理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h5><p>组合式函数在 <code>&lt;script setup&gt;</code> 或 <code>setup()</code> 钩子中，应始终被<strong>同步地</strong>调用。在某些场景下，你也可以在像 <code>onMounted()</code> 这样的生命周期钩子中使用他们。</p>
<p>这个限制是为了让 Vue 能够确定当前正在被执行的到底是哪个组件实例，只有能确认当前组件实例，才能够：</p>
<ol>
<li>将生命周期钩子注册到该组件实例上；</li>
<li>将计算属性和监听器注册到该组件实例上，以便在该组件被卸载时停止监听，避免内存泄漏。</li>
</ol>
<blockquote>
<p>提示：</p>
<p><code>&lt;script setup&gt;</code> 是唯一在调用 <code>await</code> 之后仍可调用组合式函数的地方。编译器会在异步操作之后自动为你恢复当前的组件实例。</p>
</blockquote>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>除了 Vue 内置的一系列指令 (比如 <code>v-model</code> 或 <code>v-show</code>) 之外，Vue 还允许你注册自定义的指令 (Custom Directives)。</p>
<p>我们已经介绍了两种在 Vue 中重用代码的方式：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/essentials/component-basics.html">组件</a>和<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/reusability/composables.html">组合式函数</a>。组件是主要的构建模块，而组合式函数则侧重于有状态的逻辑。另一方面，自定义指令主要是为了重用涉及普通元素的底层 DOM 访问的逻辑。</p>
<p>一个自定义指令由一个包含类似组件生命周期钩子的对象来定义。钩子函数会接收到指令所绑定元素作为其参数。下面是一个自定义指令的例子，当一个 input 元素被 Vue 插入到 DOM 中后，它会被自动聚焦：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">// 在模板中启用 v-focus</span><br><span class="line">const vFocus = &#123;</span><br><span class="line"> mounted: el =&gt; el.focus(),</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;input v-focus /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>假设你还未点击页面中的其他地方，那么上面这个 input 元素应该会被自动聚焦。该指令比 <code>autofocus</code> attribute 更有用，因为它不仅仅可以在页面加载完成后生效，还可以在 Vue 动态插入元素后生效。</p>
<p>在 <code>&lt;script setup&gt;</code> 中，任何以 <code>v</code> 开头的驼峰式命名的变量都可以被用作一个自定义指令。在上面的例子中，<code>vFocus</code> 即可以在模板中以 <code>v-focus</code> 的形式使用。</p>
<p>将一个自定义指令全局注册到应用层级也是一种常见的做法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使 v-focus 在所有组件中都可用</span></span><br><span class="line">app.<span class="title function_">directive</span>(<span class="string">&quot;focus&quot;</span>, &#123;</span><br><span class="line"> <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：</p>
<p>只有当所需功能只能通过直接的 DOM 操作来实现时，才应该使用自定义指令。其他情况下应该尽可能地使用 <code>v-bind</code> 这样的内置指令来声明式地使用模板，这样更高效，也对服务端渲染更友好。</p>
</blockquote>
<h4 id="指令钩子"><a href="#指令钩子" class="headerlink" title="指令钩子"></a>指令钩子</h4><p>一个指令的定义对象可以提供几种钩子函数 (都是可选的)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myDirective = &#123;</span><br><span class="line"> <span class="comment">// 在绑定元素的 attribute 前</span></span><br><span class="line"> <span class="comment">// 或事件监听器应用前调用</span></span><br><span class="line"> <span class="title function_">created</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;</span><br><span class="line">  <span class="comment">// 下面会介绍各个参数的细节</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="comment">// 在元素被插入到 DOM 前调用</span></span><br><span class="line"> <span class="title function_">beforeMount</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line"> <span class="comment">// 在绑定元素的父组件</span></span><br><span class="line"> <span class="comment">// 及他自己的所有子节点都挂载完成后调用</span></span><br><span class="line"> <span class="title function_">mounted</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line"> <span class="comment">// 绑定元素的父组件更新前调用</span></span><br><span class="line"> <span class="title function_">beforeUpdate</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line"> <span class="comment">// 在绑定元素的父组件</span></span><br><span class="line"> <span class="comment">// 及他自己的所有子节点都更新后调用</span></span><br><span class="line"> <span class="title function_">updated</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line"> <span class="comment">// 绑定元素的父组件卸载前调用</span></span><br><span class="line"> <span class="title function_">beforeUnmount</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line"> <span class="comment">// 绑定元素的父组件卸载后调用</span></span><br><span class="line"> <span class="title function_">unmounted</span>(<span class="params">el, binding, vnode, prevVnode</span>) &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="钩子参数"><a href="#钩子参数" class="headerlink" title="钩子参数"></a>钩子参数</h4><h4 id="简化形式"><a href="#简化形式" class="headerlink" title="简化形式"></a>简化形式</h4><h4 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h4><h4 id="在组件上使用-1"><a href="#在组件上使用-1" class="headerlink" title="在组件上使用"></a>在组件上使用</h4><p>当在组件上使用自定义指令时，它会始终应用于组件的根节点，和<a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/components/attrs.html">透传 attributes</a> 类似。</p>
<p>总的来说，<strong>不</strong>推荐在组件上使用自定义指令。</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>插件 (Plugins) 是一种能为 Vue 添加全局功能的工具代码。下面是如何安装一个插件的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(myPlugin, &#123;</span><br><span class="line"> <span class="comment">/* 可选的选项 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>一个插件可以是一个拥有 <code>install()</code> 方法的对象，也可以直接是一个安装函数本身。安装函数会接收到安装它的<a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/application.html">应用实例</a>和传递给 <code>app.use()</code> 的额外选项作为参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myPlugin = &#123;</span><br><span class="line"> <span class="title function_">install</span>(<span class="params">app, options</span>) &#123;</span><br><span class="line">  <span class="comment">// 配置此应用</span></span><br><span class="line"> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插件没有严格定义的使用范围，但是插件发挥作用的常见场景主要包括以下几种：</p>
<ol>
<li>通过 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/application.html#app-component"><code>app.component()</code></a> 和 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/application.html#app-directive"><code>app.directive()</code></a> 注册一到多个全局组件或自定义指令。</li>
<li>通过 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/application.html#app-provide"><code>app.provide()</code></a> 使一个资源 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/components/provide-inject.html">可被注入</a> 进整个应用。</li>
<li>向 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/api/application.html#app-config-globalproperties"><code>app.config.globalProperties</code></a> 中添加一些全局实例属性或方法</li>
<li>一个可能上述三种都包含了的功能库 (例如 <a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-router-next">vue-router</a>)。</li>
</ol>
<h4 id="编写一个插件"><a href="#编写一个插件" class="headerlink" title="编写一个插件"></a>编写一个插件</h4><p>…</p>
<h2 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h2><h3 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h3><p>在一个元素或组件进入和离开 DOM 时应用动画。</p>
<h3 id="TransitionGroup"><a href="#TransitionGroup" class="headerlink" title="TransitionGroup"></a>TransitionGroup</h3><p>在一个 <code>v-for</code> 列表中的元素或组件被插入，移动，或移除时应用动画。</p>
<h3 id="KeepAlive"><a href="#KeepAlive" class="headerlink" title="KeepAlive"></a>KeepAlive</h3><p>想要组件能在被“切走”的时候保留它们的状态。</p>
<p>可以用 <code>&lt;KeepAlive&gt;</code> 内置组件将这些动态组件包装起来。</p>
<h3 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h3><p>它可以将一个组件内部的一部分模板“传送”到该组件的 DOM 结构外层的位置去。</p>
<h3 id="Suspense"><a href="#Suspense" class="headerlink" title="Suspense"></a>Suspense</h3><blockquote>
<p><code>&lt;Suspense&gt;</code> 是一项实验性功能。它不一定会最终成为稳定功能，并且在稳定之前相关 API 也可能会发生变化。</p>
</blockquote>
<p><code>&lt;Suspense&gt;</code> 是一个内置组件，用来在组件树中协调对异步依赖的处理。它让我们可以在组件树上层等待下层的多个嵌套异步依赖项解析完成，并可以在等待时渲染一个加载状态。</p>
<h2 id="应用规模化"><a href="#应用规模化" class="headerlink" title="应用规模化"></a>应用规模化</h2><h3 id="状态管理-pinia"><a href="#状态管理-pinia" class="headerlink" title="状态管理 pinia"></a><a target="_blank" rel="noopener" href="https://pinia.vuejs.org/zh/introduction.html">状态管理 pinia</a></h3><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h3 id="服务端渲染-SSR"><a href="#服务端渲染-SSR" class="headerlink" title="服务端渲染 (SSR)"></a>服务端渲染 (SSR)</h3><h2 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h2><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><h2 id="进阶主题"><a href="#进阶主题" class="headerlink" title="进阶主题"></a>进阶主题</h2>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="//img.lujinkai.cn/blog/ljk/1607160536339.png" alt="像方便面一样的男子 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="//img.lujinkai.cn/blog/ljk/1607160019009.png" alt="像方便面一样的男子 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/vue3/" rel="tag"><i class="fa fa-tag"></i> vue3</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/Golang/%E8%85%BE%E8%AE%AFgo%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/" rel="prev" title="腾讯go安全指南">
                  <i class="fa fa-chevron-left"></i> 腾讯go安全指南
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/%E5%89%8D%E7%AB%AF/Vue3/Proxy/" rel="next" title="Proxy">
                  Proxy <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">鲁ICP备18016600号-3 </a>
  </div>

<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">像方便面一样的男子</span>
</div>

    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="//s1.lujinkai.cn/libs/animejs/3.2.1/anime.min.js"></script>
  <script src="//s1.lujinkai.cn/libs/lozad.js/1.16.0/lozad.min.js"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  <script src="//s1.lujinkai.cn/libs/algoliasearch/4.11.0/algoliasearch-lite.umd.min.js"></script>
<script src="//s1.lujinkai.cn/libs/instantsearch.js/4.36.0/instantsearch.production.min.js"></script><script src="/js/third-party/search/algolia-search.js"></script>






  





</body>
</html>
