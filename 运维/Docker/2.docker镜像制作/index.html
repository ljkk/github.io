<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="//img.lujinkai.cn/blog/ljk/1607154764582.png">
  <link rel="icon" type="image/png" sizes="32x32" href="//img.lujinkai.cn/blog/ljk/1607154764582.png">
  <link rel="icon" type="image/png" sizes="16x16" href="//img.lujinkai.cn/blog/ljk/1607154764582.png">
  <link rel="mask-icon" href="//img.lujinkai.cn/blog/ljk/1607154764582.png" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//s1.lujinkai.cn/libs/fontawesome-free/5.15.4/css/all.min.css">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.lujinkai.cn","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":10},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"KN3H1V8A6V","apiKey":"c5d73d0dde2dd770ce49b505f938553d","indexName":"hexo","hits":{"per_page":20,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We did not find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}}}}</script><script src="/js/config.js"></script>

    <meta name="description" content="docker 镜像生命周期  制作镜像方法：  手工制作（基于容器） 自动制作（基于 dockerfile），企业通常都是基于 dockerfile 制作镜像  手动构建镜像 commit将现有容器通过 docker commit 或 docker container commit 手动构建镜像 根据容器的更改创建新镜像： # docker container commit --help Usag">
<meta property="og:type" content="article">
<meta property="og:title" content="docker镜像制作">
<meta property="og:url" content="http://blog.lujinkai.cn/%E8%BF%90%E7%BB%B4/Docker/2.docker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/index.html">
<meta property="og:site_name" content="LJKのBlog">
<meta property="og:description" content="docker 镜像生命周期  制作镜像方法：  手工制作（基于容器） 自动制作（基于 dockerfile），企业通常都是基于 dockerfile 制作镜像  手动构建镜像 commit将现有容器通过 docker commit 或 docker container commit 手动构建镜像 根据容器的更改创建新镜像： # docker container commit --help Usag">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.to2b.cn/blog/ljk/1605854412629.png">
<meta property="og:image" content="http://img.to2b.cn/blog/ljk/1605926835392.png">
<meta property="og:image" content="http://img.to2b.cn/blog/lujinkai/1670391994648.png">
<meta property="og:image" content="http://img.to2b.cn/blog/lujinkai/1670392239691.png">
<meta property="og:image" content="http://img.to2b.cn/blog/ljk/1615612988998.png">
<meta property="article:published_time" content="2021-01-08T03:27:49.000Z">
<meta property="article:modified_time" content="2023-05-29T08:58:05.486Z">
<meta property="article:author" content="像方便面一样的男子">
<meta property="article:tag" content="docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.to2b.cn/blog/ljk/1605854412629.png">


<link rel="canonical" href="http://blog.lujinkai.cn/%E8%BF%90%E7%BB%B4/Docker/2.docker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://blog.lujinkai.cn/%E8%BF%90%E7%BB%B4/Docker/2.docker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/","path":"运维/Docker/2.docker镜像制作/","title":"docker镜像制作"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>docker镜像制作 | LJKのBlog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">LJKのBlog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">学无止境</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F-commit"><span class="nav-number">1.</span> <span class="nav-text">手动构建镜像 commit</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.1.</span> <span class="nav-text">具体步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%9F%BA%E4%BA%8E-alpine-%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C-nginx-%E9%95%9C%E5%83%8F"><span class="nav-number">1.2.</span> <span class="nav-text">案例：基于 alpine 基础镜像制作 nginx 镜像</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="nav-number">2.</span> <span class="nav-text">自动构建镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#docker-builder-build"><span class="nav-number">2.1.</span> <span class="nav-text">docker builder build</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dockerfile-%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.2.</span> <span class="nav-text">Dockerfile 介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dockerfile-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E5%92%8C%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">2.3.</span> <span class="nav-text">Dockerfile 镜像制作和使用流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dockerfile-%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E7%9A%84%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84"><span class="nav-number">2.4.</span> <span class="nav-text">Dockerfile 文件的制作镜像的分层结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#build-%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="nav-number">2.4.1.</span> <span class="nav-text">build 构建过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dockerfile-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.5.</span> <span class="nav-text">Dockerfile 文件格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dockerfile-%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="nav-number">2.6.</span> <span class="nav-text">Dockerfile 相关指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FROM"><span class="nav-number">2.6.1.</span> <span class="nav-text">FROM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LABEL"><span class="nav-number">2.6.2.</span> <span class="nav-text">LABEL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RUN"><span class="nav-number">2.6.3.</span> <span class="nav-text">RUN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ENV"><span class="nav-number">2.6.4.</span> <span class="nav-text">ENV</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#COPY"><span class="nav-number">2.6.5.</span> <span class="nav-text">COPY</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ADD"><span class="nav-number">2.6.6.</span> <span class="nav-text">ADD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMD"><span class="nav-number">2.6.7.</span> <span class="nav-text">CMD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ENTRYPOINT"><span class="nav-number">2.6.8.</span> <span class="nav-text">ENTRYPOINT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ARG"><span class="nav-number">2.6.9.</span> <span class="nav-text">ARG</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VOLUME"><span class="nav-number">2.6.10.</span> <span class="nav-text">VOLUME</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EXPOSE"><span class="nav-number">2.6.11.</span> <span class="nav-text">EXPOSE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WORKDIR"><span class="nav-number">2.6.12.</span> <span class="nav-text">WORKDIR</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ONBUILD"><span class="nav-number">2.6.13.</span> <span class="nav-text">ONBUILD</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#USER"><span class="nav-number">2.6.14.</span> <span class="nav-text">USER</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HEALTHCHECK"><span class="nav-number">2.6.15.</span> <span class="nav-text">HEALTHCHECK</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#STOPSIGNAL"><span class="nav-number">2.6.16.</span> <span class="nav-text">STOPSIGNAL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SHELL"><span class="nav-number">2.6.17.</span> <span class="nav-text">SHELL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dockerignore-%E6%96%87%E4%BB%B6"><span class="nav-number">2.6.18.</span> <span class="nav-text">.dockerignore 文件</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="像方便面一样的男子"
      src="//img.lujinkai.cn/blog/ljk/1607154764582.png">
  <p class="site-author-name" itemprop="name">像方便面一样的男子</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">340</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">73</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ljkk" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ljkk" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/%E8%BF%90%E7%BB%B4/Docker/2.docker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.lujinkai.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="docker镜像制作 | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          docker镜像制作
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-01-08 11:27:49" itemprop="dateCreated datePublished" datetime="2021-01-08T11:27:49+08:00">2021-01-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-29 16:58:05" itemprop="dateModified" datetime="2023-05-29T16:58:05+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%90%E7%BB%B4/" itemprop="url" rel="index"><span itemprop="name">运维</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%90%E7%BB%B4/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>docker 镜像生命周期</p>
<p><img data-src="//img.to2b.cn/blog/ljk/1605854412629.png"></p>
<p>制作镜像方法：</p>
<ul>
<li>手工制作（基于容器）</li>
<li>自动制作（基于 dockerfile），企业通常都是基于 dockerfile 制作镜像</li>
</ul>
<h2 id="手动构建镜像-commit"><a href="#手动构建镜像-commit" class="headerlink" title="手动构建镜像 commit"></a>手动构建镜像 <code>commit</code></h2><p>将现有容器通过 <code>docker commit</code> 或 <code>docker container commit</code> 手动构建镜像</p>
<p>根据容器的更改创建新镜像：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># docker container commit --help</span>
Usage:	<span class="token function">docker</span> container commit <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> CONTAINER <span class="token punctuation">[</span>REPOSITORY<span class="token punctuation">[</span>:TAG<span class="token punctuation">]</span><span class="token punctuation">]</span>

Options:
  -a, <span class="token parameter variable">--author</span> string    作者 <span class="token punctuation">(</span>e.g., <span class="token string">"John Hannibal Smith &lt;hannibal@a-team.com>"</span><span class="token punctuation">)</span>
  -c, <span class="token parameter variable">--change</span> list      使用Dockerfile指令来创建镜像
  -m, <span class="token parameter variable">--message</span> string   提交时的说明文字
  -p, <span class="token parameter variable">--pause</span>            在commit时，将容器暂停 <span class="token punctuation">(</span>default <span class="token boolean">true</span><span class="token punctuation">)</span></code></pre>

<p>说明：</p>
<ul>
<li>制作镜像和容器的状态无关，停止状态也可以制作</li>
<li>如果没有指定[REPOSITORY[:TAG]],REPOSITORY 和 TAG 都为&lt;none&gt;</li>
<li>提交的时候标记 TAG，后期可以根据 TAG 标记创建不同版本的镜像以及创建不同版本的容器</li>
</ul>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ol>
<li>下载一个官方的基础镜像，例如：centos、ubuntu、alpine</li>
<li>基于基础镜像启动一个容器，并进入</li>
<li>在容器里面进行安装服务、修改配置等操作</li>
<li>提交一个新镜像 <code>docker container commit</code></li>
<li>基于自己的镜像创建容器并访问、</li>
</ol>
<h3 id="案例：基于-alpine-基础镜像制作-nginx-镜像"><a href="#案例：基于-alpine-基础镜像制作-nginx-镜像" class="headerlink" title="案例：基于 alpine 基础镜像制作 nginx 镜像"></a>案例：基于 alpine 基础镜像制作 nginx 镜像</h3><ol>
<li><p>下载最新版 alpine 基础镜像</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">root@Z510:~<span class="token comment"># docker pull alpine</span></code></pre>
</li>
<li><p>启动 alpine 并进入</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">root@Z510:~<span class="token comment"># docker container run -it alpine</span>
/ <span class="token comment">#</span></code></pre>
</li>
<li><p>另开一个终端，将 shell 脚本拷贝到 alpine 镜像</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">lujinkai@Z510:~/www/script$ <span class="token function">sudo</span> <span class="token function">docker</span> container <span class="token function">ls</span>
CONTAINER ID  IMAGE   COMMAND    CREATED             STATUS    PORTS    NAMES
b8de1bdb6c88  alpine  <span class="token string">"/bin/sh"</span>  About a minute ago  Up About a minute  funny_chatelet

lujinkai@Z510:~/www/script$ <span class="token function">sudo</span> <span class="token function">docker</span> container <span class="token function">cp</span> <span class="token parameter variable">-a</span> ./alpine-docker/ b8de:/root</code></pre>
</li>
<li><p>回到容器，运行 shell 脚本</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">root@Z510:~<span class="token comment"># docker container run -it alpine</span>
/ <span class="token comment"># cd</span>
~ <span class="token comment"># ls</span>
alpine-docker
~ <span class="token comment"># cd alpine-docker/</span>
~/alpine-docker <span class="token comment"># ./install.sh</span>
<span class="token punctuation">..</span><span class="token punctuation">..</span>
make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>: Leaving directory <span class="token string">'/root/alpine-docker/src/nginx-1.18.0'</span>
Nginx installed successfully<span class="token operator">!</span>
~/alpine-docker <span class="token comment"># exit</span></code></pre>
</li>
<li><p>提交镜像</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">lujinkai@Z510:~$ <span class="token function">sudo</span> <span class="token function">docker</span> container commit <span class="token punctuation">\</span>
    <span class="token parameter variable">-a</span> <span class="token string">'lujinkai&lt;root@lujinkai.com>'</span> <span class="token punctuation">\</span>
    <span class="token parameter variable">-c</span> <span class="token string">'EXPOSE 80'</span> <span class="token punctuation">\</span>
    <span class="token parameter variable">-c</span> <span class="token string">'CMD ["/usr/local/nginx/sbin/nginx"]'</span> <span class="token punctuation">\</span>
    b8de1bdb6c88 nginx-alpine:v1
lujinkai@Z510:~$ <span class="token function">sudo</span> <span class="token operator">!</span><span class="token operator">!</span>
<span class="token function">sudo</span> <span class="token function">docker</span> image <span class="token function">ls</span>
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
nginx-alpine        v1                  de56d80c5c8c        <span class="token number">14</span> seconds ago      340MB
alpine              latest              d6e46aa2470d        <span class="token number">4</span> weeks ago         <span class="token number">5</span>.57MB</code></pre>
</li>
<li><p>启动基于新制作镜像的容器</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">root@Z510:~<span class="token comment"># docker container run -d -p 80:80 nginx-alpine:v1</span>
ebbe778a7fe303e6a5cb840203d95a7b5e2a07208365b71f784ddc8357a664d7
root@Z510:~<span class="token comment"># curl 127.0.0.1:81</span>
hello nginx</code></pre>

<p><img data-src="//img.to2b.cn/blog/ljk/1605926835392.png"></p>
</li>
<li><p>iptables</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">root@Z510:~<span class="token comment"># iptables -t nat -nL</span>
<span class="token punctuation">..</span>.
Chain DOCKER <span class="token punctuation">(</span><span class="token number">2</span> references<span class="token punctuation">)</span>
target     prot opt <span class="token builtin class-name">source</span>		destination
RETURN     all  --  anywhere	anywhere
DNAT       tcp  --  <span class="token number">0.0</span>.0.0/0	<span class="token number">0.0</span>.0.0/0		tcp dpt:81 to:172.17.0.2:80</code></pre>
</li>
<li><p>ss</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">root@Z510:~<span class="token comment"># ss -ntl</span>
State	Recv-Q	Send-Q	Local Address:Port	Peer Address:Port	Process
<span class="token punctuation">..</span>.
LISTEN	<span class="token number">0</span>		<span class="token number">4096</span>		*:81					*:*
<span class="token punctuation">..</span>.</code></pre>
</li>
<li><p>有需求的话，可以导出镜像：<code>docker image save [OPTIONS] IMAGE </code></p>
</li>
</ol>
<h2 id="自动构建镜像"><a href="#自动构建镜像" class="headerlink" title="自动构建镜像"></a>自动构建镜像</h2><p><code>docker builder build</code> 从 DockerFile 文件中构建镜像</p>
<h3 id="docker-builder-build"><a href="#docker-builder-build" class="headerlink" title="docker builder build"></a><code>docker builder build</code></h3><p><code>docker builder build</code> 或 <code>docker build</code> 命令用来基于 dockerfile 构建镜像</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> builder build <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> <span class="token environment constant">PATH</span> <span class="token operator">|</span> URL <span class="token operator">|</span> -

<span class="token environment constant">PATH</span> <span class="token operator">|</span> URL <span class="token operator">|</span> -
上下文目录，如果设置为 - ，则从标准输入获取 dockerfile 的内容，什么是上下文目录？举个例子：COPY 指令复制文件时，源文件只能在上下文目录

OPTIONS
  	-f, <span class="token parameter variable">--file</span> string				指定Dockerfile文件，默认为上下文目录下的 Dockerfile
  		--force-rm					总是删除中间层容器，创建镜像失败时，删除临时容器
  		--no-cache					不使用之前构建中创建的缓存
  		<span class="token parameter variable">--rm</span><span class="token operator">=</span>true					创建镜像成功时，删除临时容器
	-c, --cpu-shares int			设置 cpu 使用权重，按照比例分配cpu资源，当只有一个容器时，<span class="token variable"><span class="token variable">`</span>--cpu-shares<span class="token variable">`</span></span> 选项没有意义。
  	-m, <span class="token parameter variable">--memory</span> bytes				设置构建内存上限
  	-t, <span class="token parameter variable">--tag</span> list					为构建的镜像打上标签
  	-q, <span class="token parameter variable">--quiet</span>						不显示构建过程的信息</code></pre>

<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> build <span class="token builtin class-name">.</span>
<span class="token function">docker</span> build /usr/local/src/nginx
<span class="token function">docker</span> build <span class="token parameter variable">-f</span> /path/to/a/Dockerfile <span class="token builtin class-name">.</span>
<span class="token function">docker</span> build <span class="token parameter variable">-t</span> shykes/myapp <span class="token builtin class-name">.</span>
<span class="token function">docker</span> build <span class="token parameter variable">-t</span> shykes/myapp:1.0.2 <span class="token parameter variable">-t</span> shykes/myapp:latest <span class="token builtin class-name">.</span>
<span class="token function">docker</span> build <span class="token parameter variable">-t</span> test/myapp <span class="token builtin class-name">.</span>
<span class="token function">docker</span> build <span class="token parameter variable">-t</span> nginx:v1 /usr/local/src/nginx

<span class="token function">docker</span> builder build <span class="token parameter variable">-t</span> nginx:v1 <span class="token builtin class-name">.</span>    <span class="token comment"># 构建一个镜像，指定上下文目录为当前目录</span></code></pre>

<h3 id="Dockerfile-介绍"><a href="#Dockerfile-介绍" class="headerlink" title="Dockerfile 介绍"></a>Dockerfile 介绍</h3><p>DockerFile 是一种被 Docker 程序解释执行的脚本，由一条条的命令组成的，每条命令对应 linux 下面的一条命令，Docker 程序将这些 DockerFile 指令翻译成真正的 linux 命令，其有自己的书写方式和支持的命令，Docker 程序读取 DockerFile 并根据指令生成 Docker 镜像，相比手动制作镜像的方式，DockerFile 更能直观的展示镜像是怎么产生的，有了 DockerFile，当后期有额外的需求时，只要在之前的 DockerFile 添加或者修改响应的命令即可重新生成新的 Docker 镜像，避免了重复手动制作镜像的麻烦，类似与 shell 脚本一样，可以方便高效的制作镜像。</p>
<p>Docker 守护程序 Dockerfile 逐一运行指令，如有必要，将每个指令的结果提交到新镜像，然后最终输出新镜像的 ID。Docker 守护程序将自动清理之前发送的上下文。</p>
<p>请注意，每条指令都是独立运行的，并会导致创建新镜像，比如 <code>RUN cd /tmp</code> 对下一条指令不会有任何影响。</p>
<p>Docker 将尽可能重用中间镜像层（缓存），以显著加速 <code>docker builder build</code> 命令的执行过程，这由 Using cache 控制台输出中的消息指示。</p>
<h3 id="Dockerfile-镜像制作和使用流程"><a href="#Dockerfile-镜像制作和使用流程" class="headerlink" title="Dockerfile 镜像制作和使用流程"></a>Dockerfile 镜像制作和使用流程</h3><p><img data-src="//img.to2b.cn/blog/lujinkai/1670391994648.png"></p>
<h3 id="Dockerfile-文件的制作镜像的分层结构"><a href="#Dockerfile-文件的制作镜像的分层结构" class="headerlink" title="Dockerfile 文件的制作镜像的分层结构"></a>Dockerfile 文件的制作镜像的分层结构</h3><p><img data-src="//img.to2b.cn/blog/lujinkai/1670392239691.png"></p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 按照业务类型或系统类型等方式划分创建目录环境，方便后期镜像比较多的时候进行分类</span>
<span class="token punctuation">[</span>root@ubuntu1804 ~<span class="token punctuation">]</span>$ <span class="token function">mkdir</span>
/data/dockerfile/<span class="token punctuation">&#123;</span>web/<span class="token punctuation">&#123;</span>nginx,apache,tomcat,jdk<span class="token punctuation">&#125;</span>,system/<span class="token punctuation">&#123;</span>centos,ubuntu,alpine,debian<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token parameter variable">-p</span>
<span class="token punctuation">[</span>root@ubuntu1804 ~<span class="token punctuation">]</span>$ tree /data/dockerfile/
/data/dockerfile/
├── system
│├── alpine
│├── centos
│├── debian
│└── ubuntu
└── web
├── apache
├── jdk
├── nginx
└── tomcat
<span class="token number">10</span> directories, <span class="token number">0</span> files</code></pre>

<h4 id="build-构建过程"><a href="#build-构建过程" class="headerlink" title="build 构建过程"></a>build 构建过程</h4><ol>
<li>从基础镜像运行一个容器</li>
<li>顺序执行一条指令对容器做出修改</li>
<li>执行类似 <code>docker commit</code> 的操作提交一个新的镜像层（可以利用中间层镜像创建容器进行调试和排错）</li>
<li>docker 基于刚才提交的镜像运行一个新的容器</li>
<li>执行 Dockerfile 中的下一条指令，直至所有指令执行完毕</li>
</ol>
<h3 id="Dockerfile-文件格式"><a href="#Dockerfile-文件格式" class="headerlink" title="Dockerfile 文件格式"></a>Dockerfile 文件格式</h3><p>Dockerfile 是一个有特定语法格式的文本文件</p>
<ul>
<li>每一行以 Dockerfile 的指令开头，指令不区分大小写，但是惯例使用大写</li>
<li>使用 # 开始作为注释</li>
<li>每一行只支持一条指令，每条指令可以携带多个参数</li>
<li>指令按文件的顺序从上至下进行执行</li>
<li>每个指令的执行会生成一个新的镜像层，为了减少分层和镜像大小，尽可能将多条指令合并成一条指令</li>
<li>制作镜像一般可能需要反复多次，每次执行 Dockerfile 都按顺序执行，从头开始，已经执行过的指令已经缓存，不需要再执行，如果后续有一行新的指令没执行过，其往后的指令将会重新执行，所以为加速镜像制作，将最常变化的内容放下 Dockerfile 的文件的后面</li>
</ul>
<h3 id="Dockerfile-相关指令"><a href="#Dockerfile-相关指令" class="headerlink" title="Dockerfile 相关指令"></a>Dockerfile 相关指令</h3><p><code>docker builder build</code> 命令基于 dockerfile 构建镜像，<code>docker container run</code> 命令基于镜像启动容器</p>
<p>所以 dockerfile 的指令也分为三类：</p>
<ul>
<li>在 <code>docker builder build</code> 阶段运行</li>
<li>在 <code>docker container run</code> 阶段运行</li>
<li>在以上两个阶段都运行，这种命令都是“设置”相关的，例如 <code>USER</code> 设置用户、<code>ENV</code> 设置环境变量、<code>WORKDIR</code> 设置工作目录，它们的设置在 build 和 run 两个阶段都生效</li>
</ul>
<p><img data-src="//img.to2b.cn/blog/ljk/1615612988998.png"></p>
<h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p><code>FORM</code> 指定基础镜像，此指令通常必需放在 Dockerfile 文件第一个非注释行。后续的指令都是运行于此基准镜像所提供的运行环境</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">FROM <span class="token punctuation">[</span>--platform<span class="token operator">=</span><span class="token operator">&lt;</span>platform<span class="token operator">></span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>image<span class="token operator">></span><span class="token punctuation">[</span>:<span class="token operator">&lt;</span>tag<span class="token operator">></span><span class="token punctuation">]</span></code></pre>

<p><strong>关于 scratch 镜像：</strong></p>
<p>该镜像是一个空的镜像，可以用于构建 busybox 等超小镜像，可以说是真正的从零开始构建属于自己的镜像该镜像在构建基础镜像（例如 debian 和 busybox）或超最小镜像（仅包含一个二进制文件及其所需内容，例如:hello-world）的上下文中最有用</p>
<h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p><code>LABEL</code> 指定镜像元数据，如 镜像作者等</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">LABEL <span class="token operator">&lt;</span>key<span class="token operator">>=</span><span class="token operator">&lt;</span>value<span class="token operator">></span> <span class="token operator">&lt;</span>key<span class="token operator">>=</span><span class="token operator">&lt;</span>value<span class="token operator">></span> <span class="token operator">&lt;</span>key<span class="token operator">>=</span><span class="token operator">&lt;</span>value<span class="token operator">></span> <span class="token punctuation">..</span>.</code></pre>

<p>示例：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">LABEL <span class="token assign-left variable">maintainer</span><span class="token operator">=</span><span class="token string">"lujinkai &lt;root@lujinkai.com>"</span> <span class="token punctuation">\</span>
    <span class="token assign-left variable">version</span><span class="token operator">=</span><span class="token string">"1.0"</span> <span class="token punctuation">\</span>
    <span class="token assign-left variable">other</span><span class="token operator">=</span><span class="token string">"value3"</span> <span class="token punctuation">\</span>
    <span class="token assign-left variable">description</span><span class="token operator">=</span><span class="token string">"some description"</span> <span class="token punctuation">\</span>
    <span class="token assign-left variable">other</span><span class="token operator">=</span><span class="token string">"value1"</span></code></pre>

<p>注意：MAINTAINER 指令已过时，使用 LABEL 代替</p>
<h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p><code>RUN</code> 指令用来在 build 阶段需要执行 shell 命令，一定要是继承的镜像所支持的 shell 命令</p>
<p>注意: <code>RUN</code> 可以写多个，每一个 <code>RUN</code> 指令都会建立一个镜像层，所以尽可能使用 &amp;&amp; 将多条指令合并为一条</p>
<p>相邻的 <code>RUN</code> 命令相互独立，示例：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">RUN <span class="token builtin class-name">cd</span> /app
RUN <span class="token builtin class-name">echo</span> <span class="token string">"hello"</span> <span class="token operator">></span> world.txt		<span class="token comment"># world.txt并不存放在/app内</span></code></pre>

<h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p><code>ENV</code> 定义环境变量和值，会被后续指令通过$KEY或${KEY}进行引用，并在容器运行时保持</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">ENV <span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">1</span>></span><span class="token operator">=</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">1</span>></span> <span class="token punctuation">\</span>
	<span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token operator">=</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">2</span>></span> <span class="token punctuation">\</span>
	<span class="token operator">&lt;</span>key<span class="token operator"><span class="token file-descriptor important">3</span>></span><span class="token operator">=</span><span class="token operator">&lt;</span>value<span class="token operator"><span class="token file-descriptor important">3</span>></span>

<span class="token comment"># 变量支持高级赋值格式</span>
<span class="token variable">$&#123;key<span class="token operator">:-</span>word&#125;</span>
<span class="token variable">$&#123;kye<span class="token operator">:+</span>word&#125;</span></code></pre>

<p><code>docker run</code> 运行容器，如果需要修改环境变量，使用 <code> -e</code> 重新定义即可覆盖</p>
<h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>复制指令，从上下文目录中复制文件或者目录到容器里指定路径</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">COPY <span class="token punctuation">[</span>--chown<span class="token operator">=</span><span class="token operator">&lt;</span>user<span class="token operator">></span>:<span class="token operator">&lt;</span>group<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token string">"&lt;src>"</span>,<span class="token punctuation">..</span>. <span class="token string">"&lt;dest>"</span><span class="token punctuation">]</span>	<span class="token comment"># 如果路径中有空白字符，加双引号</span></code></pre>

<ul>
<li><p><code>--chown=&lt;user&gt;:&lt;group&gt;</code>：改变复制到容器内文件的属主和属组，默认保留所有元数据</p>
</li>
<li><p><code>&quot;&lt;src&gt;&quot;</code></p>
<ul>
<li>支持通配符，通配符规则满足 Go 的 filepath.Match 规则</li>
<li>如果是目录，则其内部文件或子目录会被递归复制，但目录自身不会被复制</li>
</ul>
</li>
<li><p><code>&quot;&lt;dest&gt;&quot;</code></p>
<ul>
<li>支持绝对路径 或 WORKDIR 指定的相对路径</li>
<li>如果不存在，会自动创建，递归创建目录</li>
<li>如果<code>&quot;&lt;src&gt;&quot;</code>是多个文件，则<code>&quot;&lt;dest&gt;&quot;</code>必须是目录，且以 <code>/</code> 结尾</li>
</ul>
</li>
</ul>
<p>范例：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">COPY hom* /mydir/
COPY hom?.txt /mydir/</code></pre>

<h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>增强版 <code>COPY</code>，支持自动解压缩，如果只是复制，尽量使用 <code>COPY</code></p>
<p>支持解压缩（identity、gzip、bzip2、xz），支持解包（tar），支持像解压缩+解包，例如 <code>.tar.gz</code></p>
<p>注意：ADD 识别压缩文件，取决于文件内容，不取决于文件后缀，如果一个文本文件直接修改后缀为 <code>.tar.gz</code>，该文件将被简单地复制到目标文件</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">ADD <span class="token punctuation">[</span>--chown<span class="token operator">=</span><span class="token operator">&lt;</span>user<span class="token operator">></span>:<span class="token operator">&lt;</span>group<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token string">"&lt;src>"</span>,<span class="token punctuation">..</span>. <span class="token string">"&lt;dest>"</span><span class="token punctuation">]</span></code></pre>

<ul>
<li><code>&quot;&lt;src&gt;&quot;</code>：支持 URL，下载后的文件权限自动设置为 600，如果下载的是 tar 文件将不会自动展开</li>
</ul>
<p>示例：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">ADD <span class="token builtin class-name">test</span> relativeDir/ 		<span class="token comment"># adds "test" to `WORKDIR`/relativeDir/</span>
ADD <span class="token builtin class-name">test</span> /absoluteDir/ 		<span class="token comment"># adds "test" to /absoluteDir/</span>
ADD <span class="token parameter variable">--chown</span><span class="token operator">=</span><span class="token number">55</span>:mygroup files* /somedir/
ADD <span class="token parameter variable">--chown</span><span class="token operator">=</span>bin files* /somedir/
ADD <span class="token parameter variable">--chown</span><span class="token operator">=</span><span class="token number">1</span> files* /somedir/
ADD <span class="token parameter variable">--chown</span><span class="token operator">=</span><span class="token number">10</span>:11 files* /somedir/
ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</code></pre>

<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p><code>CMD</code> 指定启动容器时默认执行的一个命令</p>
<ul>
<li>命令运行结束后容器也会停止，所以一般指定持续运行且为前台的命令</li>
<li>每个 Dockerfile 只能有一条<code>CMD</code> 命令。如指定了多条，只有最后一条被执行</li>
<li>如果用户启动容器时用 docker run xxx 指定运行的命令，则会覆盖 <code>CMD</code> 指定的命令</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 使用 exec 执行，推荐方式，第一个参数必须是命令的全路径,此种形式不支持环境变量</span>
CMD <span class="token punctuation">[</span><span class="token string">"executable"</span>,<span class="token string">"param1"</span>,<span class="token string">"param2"</span><span class="token punctuation">]</span>

<span class="token comment"># 在 /bin/sh 中执行，提供给需要交互的应用；此种形式支持环境变量</span>
CMD <span class="token builtin class-name">command</span> param1 param2

<span class="token comment"># 提供给 ENTRYPOINT 命令的默认参数</span>
CMD <span class="token punctuation">[</span><span class="token string">"param1"</span>,<span class="token string">"param2"</span><span class="token punctuation">]</span></code></pre>

<p>示例：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">CMD <span class="token punctuation">[</span><span class="token string">"nginx"</span>, <span class="token string">"-g"</span>, <span class="token string">"daemon off;"</span><span class="token punctuation">]</span></code></pre>

<h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>入口点，功能类似于<code>CMD</code>，配置容器启动后执行的命令及参数</p>
<ul>
<li><code>ENTRYPOINT</code> 不能被 <code>docker run</code> 提供的参数覆盖，而是以追加的形式作为 <code>ENTRYPOINT</code> 的参数</li>
<li>每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有最后一个生效</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 使用 exec 执行</span>
ENTRYPOINT <span class="token punctuation">[</span><span class="token string">"executable"</span>, <span class="token string">"param1"</span>, <span class="token string">"param2"</span><span class="token punctuation">]</span>

<span class="token comment"># shell中执行</span>
ENTRYPOINT <span class="token builtin class-name">command</span> param1 param2</code></pre>

<p><code>CMD</code> 和 <code>ENTRYPOINT</code> 都定义了容器运行时的执行命令。如下是它们的一些使用规则：</p>
<ul>
<li><code>CMD</code> 和 <code>ENTRYPOINT</code> 在 Dockerfiles 中应该至少应该有一个被定义</li>
<li>当构建可执行容器时，应该定义 <code>ENTRYPOINT</code> 指令</li>
<li><code>CMD</code> 要么用于给 <code>ENTRYPOINT</code> 提供默认参数，要么用于在容器中执行一个特定命令</li>
<li><code>CMD</code> 可以通过容器启动命令 <code>docker run</code> 的参数来替换它</li>
</ul>
<h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h4><p><code>ARG</code> 在 build 阶段指定变量，和 <code>ENV</code> 不同的是，容器运行时不会存在这些环境变量</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">ARG <span class="token operator">&lt;</span>name<span class="token operator">></span><span class="token punctuation">[</span><span class="token operator">=</span><span class="token operator">&lt;</span>default value<span class="token operator">></span><span class="token punctuation">]</span></code></pre>

<ul>
<li><p>如果和 <code>ENV</code> 同名，<code>ENV</code> 覆盖 <code>ARG</code> 变量</p>
</li>
<li><p>可以用 <code>docker build --build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖</p>
</li>
<li><p>在 <code>FROM</code> 之前声明的 <code>ARG</code> 在构建阶段之外，所以它不能在 <code>FROM</code> 之后的任何指令中使用。 要使用在第一个<code>FROM</code> 之前声明的 <code>ARG</code> 的默认值，请在构建阶段内使用没有值的 <code>ARG</code> 指令</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 示例:</span>
ARG <span class="token assign-left variable">VERSION</span><span class="token operator">=</span>latest
FROM busybox:<span class="token variable">$VERSION</span>
ARG VERSION
RUN <span class="token builtin class-name">echo</span> <span class="token variable">$VERSION</span> <span class="token operator">></span> image_version</code></pre></li>
</ul>
<h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p>匿名卷，将宿主机上的目录挂载至 <code>VOLUME</code> 指定的容器目录。即使容器后期被删除，此宿主机的目录仍会保留，从而实现容器数据的持久保存</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">VOLUME <span class="token operator">&lt;</span>容器内路径<span class="token operator">></span>
VOLUME <span class="token punctuation">[</span><span class="token string">"&lt;容器内路径1>"</span>, <span class="token string">"&lt;容器内路径2>"</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>

<ul>
<li><p><code>VOLUME</code> 实现的是匿名卷，无法指定宿主机路径和容器目录的挂载关系，宿主机目录位于：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">/var/lib/docker/volumes/</code></pre>
</li>
<li><p>通过<code>docker rm -fv &lt;容器ID&gt;</code> 可以删除容器的同时删除 VOLUME 指定的卷</p>
</li>
<li><p>如果要指定宿主机目录，使用 <code>docker run</code> 的 -v 参数，参考：<a href="./docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/">docker 数据管理</a></p>
</li>
</ul>
<p>示例：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1. dockerfile，生成两个匿名卷</span>
VOLUME <span class="token punctuation">[</span> <span class="token string">"/testdata"</span>,<span class="token string">"/testdata2"</span> <span class="token punctuation">]</span>

<span class="token comment"># 2. 进入容器，测试</span>
<span class="token function">cp</span> /etc/issue /testdata/f1.txt
<span class="token function">cp</span> /etc/issue /testdata2/f2.txt

<span class="token comment"># 3. 查看宿主机目录</span>
$ tree /var/lib/containers/storage/volumes/
/var/lib/containers/storage/volumes/
├── 725f0f67921bdbffbe0aaf9b015d663a6e3ddd24674990d492025dfcf878529b
│ └── _data
│ └── f1.txt
└── fbd13e5253deb375e0dea917df832d2322e96b04ab43bae061584dcdbe7e89f2
└── _data
└── f2.txt</code></pre>

<h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>指定工作目录，即后续 <code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code> 指令的相对路径，如该目录不存在，<code>WORKDIR</code> 会自行创建</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">WORKDIR /path/to/workdir</code></pre>

<p>示例：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 两次RUN独立运行,不在同一个目录，</span>
RUN <span class="token builtin class-name">cd</span> /app
RUN <span class="token builtin class-name">echo</span> <span class="token string">"hello"</span> <span class="token operator">></span> world.txt

<span class="token comment"># 如果想实现相同目录可以使用WORKDIR</span>
WORKDIR /app
RUN <span class="token builtin class-name">echo</span> <span class="token string">"hello"</span> <span class="token operator">></span> world.txt

<span class="token comment"># 可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径</span>
WORKDIR /a
WORKDIR b
WORKDIR c
RUN <span class="token builtin class-name">pwd</span>			<span class="token comment"># /a/b/c</span></code></pre>

<h4 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h4><p><code>ONBUILD</code> 指令在当前镜像 build 阶段不会执行，会在子镜像 build 阶段执行，即：延迟执行</p>
<p>使用 ONBUILD 指令的镜像，推荐在标签中注明，例如 ruby:1.9-onbuild</p>
<h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p>指定执行后续指令的用户和用户组，后续的 RUN 也会使用指定用户，默认是 root 身份执行</p>
<p>这个用户必须是事先建立好的，否则无法切换</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token environment constant">USER</span> <span class="token operator">&lt;</span>user<span class="token operator">></span><span class="token punctuation">[</span>:<span class="token operator">&lt;</span>group<span class="token operator">></span><span class="token punctuation">]</span>
<span class="token environment constant">USER</span> <span class="token operator">&lt;</span><span class="token environment constant">UID</span><span class="token operator">></span><span class="token punctuation">[</span>:<span class="token operator">&lt;</span>GID<span class="token operator">></span><span class="token punctuation">]</span></code></pre>

<h4 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h4><p>检查容器的健康性</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">HEALTHCHECK <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> CMD <span class="token operator">&lt;</span>命令<span class="token operator">></span> 	<span class="token comment"># 设置检查容器健康状况的命令</span>
HEALTHCHECK NONE 	<span class="token comment"># 如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</span>

<span class="token parameter variable">--interval</span><span class="token operator">=</span><span class="token operator">&lt;</span>间隔<span class="token operator">></span> <span class="token comment">#两次健康检查的间隔，默认为 30 秒</span>
<span class="token parameter variable">--timeout</span><span class="token operator">=</span><span class="token operator">&lt;</span>时长<span class="token operator">></span>  <span class="token comment">#健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒</span>
<span class="token parameter variable">--retries</span><span class="token operator">=</span><span class="token operator">&lt;</span>次数<span class="token operator">></span>  <span class="token comment">#当连续失败指定次数后，则将容器状态视为 unhealthy，默认3次</span>
--start-period<span class="token operator">=</span><span class="token operator">&lt;</span>FDURATION<span class="token operator">></span> <span class="token comment">#default: 0s</span></code></pre>

<p>示例：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">FROM nginx
RUN <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token function">curl</span> <span class="token operator">&amp;&amp;</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> /var/lib/apt/lists/*
HEALTHCHECK <span class="token parameter variable">--interval</span><span class="token operator">=</span>5s <span class="token parameter variable">--timeout</span><span class="token operator">=</span>3s <span class="token punctuation">\</span>
	CMD <span class="token function">curl</span> <span class="token parameter variable">-fs</span> http://localhost/ <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span></code></pre>

<h4 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h4><p>退出容器的信号</p>
<p><code>STOPSIGNAL</code> 设置将被发送到容器退出的系统调用信号。该信号可以是与内核 syscall 表中的位置匹配的有效无符号数字（例如 9），也可以是 SIGNAME 格式的信号名称（例如 SIGKILL）</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">STOPSIGNAL signal</code></pre>

<h4 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h4><p>指定 shell，<code>SHELL</code>指令可以出现多次。 每个<code>SHELL</code>指令将覆盖所有先前的<code>SHELL</code>指令，并影响所有后续的指令</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token environment constant">SHELL</span> <span class="token punctuation">[</span><span class="token string">"executable"</span>, <span class="token string">"parameters"</span><span class="token punctuation">]</span></code></pre>

<p>示例：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token environment constant">SHELL</span> <span class="token punctuation">[</span><span class="token string">"powershell"</span>, <span class="token string">"-command"</span><span class="token punctuation">]</span>
<span class="token environment constant">SHELL</span> <span class="token punctuation">[</span><span class="token string">"cmd"</span>, <span class="token string">"/S"</span>, <span class="token string">"/C"</span><span class="token punctuation">]</span></code></pre>

<h4 id="dockerignore-文件"><a href="#dockerignore-文件" class="headerlink" title=".dockerignore 文件"></a>.dockerignore 文件</h4><p>与.gitignore 文件类似，生成构建上下文时 Docker 客户端应忽略的文件和文件夹指定模式</p>
<p>示例：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">test/*			<span class="token comment">#排除 test 目录下的所有文件</span>
md/xttblog.md	<span class="token comment">#排除 md 目录下的 xttblog.md 文件</span>
xttblog/*.md	<span class="token comment">#排除 xttblog 目录下的所有 .md 的文件</span>
xttblog?		<span class="token comment">#排除以 xttblog 为前缀的文件和文件夹</span>
**/*.sql		<span class="token comment">#排除所有目录下的 .sql 文件夹</span>

<span class="token comment">#除了README的md不排外，排除所有md文件，但不排除README-secret.md</span>
*.md
<span class="token operator">!</span>README*.md
README-secret.md

<span class="token comment">#除了所有README的md文件以外的md都排除</span>
*.md
README-secret.md
<span class="token operator">!</span>README*.md</code></pre>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="//img.lujinkai.cn/blog/ljk/1607160536339.png" alt="像方便面一样的男子 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="//img.lujinkai.cn/blog/ljk/1607160019009.png" alt="像方便面一样的男子 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/docker/" rel="tag"><i class="fa fa-tag"></i> docker</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/%E8%BF%90%E7%BB%B4/Docker/1.3.docker%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/" rel="prev" title="docker容器管理">
                  <i class="fa fa-chevron-left"></i> docker容器管理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/%E8%BF%90%E7%BB%B4/Docker/3.docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/" rel="next" title="docker数据管理">
                  docker数据管理 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">鲁ICP备18016600号-3 </a>
  </div>

<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">像方便面一样的男子</span>
</div>

    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="//s1.lujinkai.cn/libs/animejs/3.2.1/anime.min.js"></script>
  <script src="//s1.lujinkai.cn/libs/lozad.js/1.16.0/lozad.min.js"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  <script src="//s1.lujinkai.cn/libs/algoliasearch/4.11.0/algoliasearch-lite.umd.min.js"></script>
<script src="//s1.lujinkai.cn/libs/instantsearch.js/4.36.0/instantsearch.production.min.js"></script><script src="/js/third-party/search/algolia-search.js"></script>






  





</body>
</html>
