<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="//img.to2b.cn/blog/ljk/1607154764582.png">
  <link rel="icon" type="image/png" sizes="32x32" href="//img.to2b.cn/blog/ljk/1607154764582.png">
  <link rel="icon" type="image/png" sizes="16x16" href="//img.to2b.cn/blog/ljk/1607154764582.png">
  <link rel="mask-icon" href="//img.to2b.cn/blog/ljk/1607154764582.png" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//s1.to2b.cn/libs/fontawesome-free/5.15.4/css/all.min.css">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.lujinkai.cn","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.16.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":10},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"algolia":{"appID":"KN3H1V8A6V","apiKey":"c5d73d0dde2dd770ce49b505f938553d","indexName":"hexo","hits":{"per_page":20,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We did not find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}}}}</script><script src="/js/config.js"></script>

    <meta name="description" content="什么是 k8s？kubernetes：容器的管理和编排系统 k8s 由多个组件组成，部署在一群服务器之上，将所有服务器整合成一个资源池，然后向客户端提供各种接口， 客户端只需要调用相应接口就可以管理容器，至于底层容器具体跑在哪台服务器，不可见也不需要关心 针对各种特定的业务，尤其是比较依赖工程师经验的业务（例如数据库集群宕机后的数据恢复、各种集群的扩缩容），可以将一系列复杂操作代码化，这个代码在">
<meta property="og:type" content="article">
<meta property="og:title" content="基础">
<meta property="og:url" content="http://blog.lujinkai.cn/%E8%BF%90%E7%BB%B4/Kubernetes/%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="LJKのBlog">
<meta property="og:description" content="什么是 k8s？kubernetes：容器的管理和编排系统 k8s 由多个组件组成，部署在一群服务器之上，将所有服务器整合成一个资源池，然后向客户端提供各种接口， 客户端只需要调用相应接口就可以管理容器，至于底层容器具体跑在哪台服务器，不可见也不需要关心 针对各种特定的业务，尤其是比较依赖工程师经验的业务（例如数据库集群宕机后的数据恢复、各种集群的扩缩容），可以将一系列复杂操作代码化，这个代码在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.to2b.cn/blog/ljk/1615356791215.png">
<meta property="og:image" content="http://img.to2b.cn/blog/ljk/1610298132384.png">
<meta property="og:image" content="http://img.to2b.cn/blog/ljk/1615428426624.png">
<meta property="og:image" content="http://img.to2b.cn/blog/ljk/1610675848800.png">
<meta property="article:published_time" content="2021-03-10T05:55:03.000Z">
<meta property="article:modified_time" content="2023-05-29T08:58:05.498Z">
<meta property="article:author" content="像方便面一样的男子">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.to2b.cn/blog/ljk/1615356791215.png">


<link rel="canonical" href="http://blog.lujinkai.cn/%E8%BF%90%E7%BB%B4/Kubernetes/%E5%9F%BA%E7%A1%80/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://blog.lujinkai.cn/%E8%BF%90%E7%BB%B4/Kubernetes/%E5%9F%BA%E7%A1%80/","path":"运维/Kubernetes/基础/","title":"基础"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>基础 | LJKのBlog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">LJKのBlog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">学无止境</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container">
  <div class="algolia-stats"><hr></div>
  <div class="algolia-hits"></div>
  <div class="algolia-pagination"></div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-k8s%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">什么是 k8s？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8A%82%E7%82%B9"><span class="nav-number">2.</span> <span class="nav-text">节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6"><span class="nav-number">3.</span> <span class="nav-text">组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2%E7%BB%84%E4%BB%B6"><span class="nav-number">3.1.</span> <span class="nav-text">控制平面组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#kube-apiserver"><span class="nav-number">3.1.1.</span> <span class="nav-text">kube-apiserver</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kube-controller-manager"><span class="nav-number">3.1.2.</span> <span class="nav-text">kube-controller-manager</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kube-scheduler"><span class="nav-number">3.1.3.</span> <span class="nav-text">kube-scheduler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#etcd"><span class="nav-number">3.1.4.</span> <span class="nav-text">etcd</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E6%88%90%E5%91%98"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">管理成员</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">增删改查</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#watch-%E6%9C%BA%E5%88%B6"><span class="nav-number">3.1.4.3.</span> <span class="nav-text">watch 机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6"><span class="nav-number">3.1.4.4.</span> <span class="nav-text">数据备份与恢复机制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#cloud-controller-manager"><span class="nav-number">3.1.5.</span> <span class="nav-text">cloud-controller-manager</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-%E7%BB%84%E4%BB%B6"><span class="nav-number">3.2.</span> <span class="nav-text">Node 组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#kubelet"><span class="nav-number">3.2.1.</span> <span class="nav-text">kubelet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#kube-porxy"><span class="nav-number">3.2.2.</span> <span class="nav-text">kube-porxy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Container-runtime"><span class="nav-number">3.2.3.</span> <span class="nav-text">Container runtime</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Addons"><span class="nav-number">3.3.</span> <span class="nav-text">Addons</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS"><span class="nav-number">3.3.1.</span> <span class="nav-text">DNS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Web-UI"><span class="nav-number">3.3.2.</span> <span class="nav-text">Web UI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.3.3.</span> <span class="nav-text">集群监控系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F"><span class="nav-number">3.3.4.</span> <span class="nav-text">集群日志系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ingress-Controller"><span class="nav-number">3.3.5.</span> <span class="nav-text">Ingress Controller</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%A6"><span class="nav-number">3.3.6.</span> <span class="nav-text">…</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CNI"><span class="nav-number">4.</span> <span class="nav-text">CNI</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#overlay"><span class="nav-number">4.1.</span> <span class="nav-text">overlay</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#underlay"><span class="nav-number">4.2.</span> <span class="nav-text">underlay</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%84%E6%BA%90"><span class="nav-number">5.</span> <span class="nav-text">资源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.1.</span> <span class="nav-text">创建对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.2.</span> <span class="nav-text">查看对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE"><span class="nav-number">6.2.1.</span> <span class="nav-text">外部访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E8%AE%BF%E9%97%AE"><span class="nav-number">6.2.2.</span> <span class="nav-text">内部访问</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lease-%E7%A7%9F%E7%BA%A6"><span class="nav-number">7.</span> <span class="nav-text">lease 租约</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="像方便面一样的男子"
      src="//img.to2b.cn/blog/ljk/1607154764582.png">
  <p class="site-author-name" itemprop="name">像方便面一样的男子</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">340</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">73</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">99</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ljkk" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ljkk" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.lujinkai.cn/%E8%BF%90%E7%BB%B4/Kubernetes/%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="//img.to2b.cn/blog/ljk/1607154764582.png">
      <meta itemprop="name" content="像方便面一样的男子">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJKのBlog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="基础 | LJKのBlog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          基础
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-03-10 13:55:03" itemprop="dateCreated datePublished" datetime="2021-03-10T13:55:03+08:00">2021-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-05-29 16:58:05" itemprop="dateModified" datetime="2023-05-29T16:58:05+08:00">2023-05-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%90%E7%BB%B4/" itemprop="url" rel="index"><span itemprop="name">运维</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%BF%90%E7%BB%B4/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="什么是-k8s？"><a href="#什么是-k8s？" class="headerlink" title="什么是 k8s？"></a>什么是 k8s？</h2><p>kubernetes：容器的管理和编排系统</p>
<p>k8s 由多个组件组成，部署在一群服务器之上，将所有服务器整合成一个资源池，然后向客户端提供各种接口， 客户端只需要调用相应接口就可以管理容器，至于底层容器具体跑在哪台服务器，不可见也不需要关心</p>
<p>针对各种特定的业务，尤其是比较依赖工程师经验的业务（例如数据库集群宕机后的数据恢复、各种集群的扩缩容），可以将一系列复杂操作代码化，这个代码在 k8s 中就叫 operator，只要用好各种 operator，就可以方便高效的解决各种问题，这样，运维工程师的主要工作就变成了维护 k8s，确保 k8s 自身能够良好运行</p>
<p>k8s 内置了各种 operator，但是这些 operator 更重视通用性，很难完全匹配实际工作需要，所以就需要对 k8s 进行二次开发，编写各种 operator，这也是 SRE 工程师的必备技能之一</p>
<p>operator 能单独管理应用集群，实现复杂操作；controllor：控制器，只能实现简单的容器操作</p>
<p>开发人员为 k8s 开发应用程序的时候，通常不会完整的部署一个分布式 k8s 集群，而是使用一个叫做 MiniKube，它可以在单机上模拟出一个完整意义上的 k8s 集群</p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>资源池中的各个服务器叫做节点，节点有两种：</p>
<ul>
<li>Worker Node：运行 Pod，一般称 <strong>Node</strong></li>
<li>Master Node：运行控制平面组件，不运行 pod，一般称为 <strong>Master</strong></li>
</ul>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>k8s 组件分为三种： <strong>控制平面组件</strong>、<strong>Node 组件</strong>、<strong>Addons</strong></p>
<p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/overview/components/">https://kubernetes.io/docs/concepts/overview/components/</a></p>
<p><img data-src="//img.to2b.cn/blog/ljk/1615356791215.png"></p>
<p><img data-src="//img.to2b.cn/blog/ljk/1610298132384.png"></p>
<h3 id="控制平面组件"><a href="#控制平面组件" class="headerlink" title="控制平面组件"></a><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/overview/components/#control-plane-components">控制平面组件</a></h3><p>控制平面（control plane）管理 Node 和 Node 上的 Pods</p>
<p>控制平面组件可以分别运行在任意节点上，但是为了简单，通常会将所有控制平面组件运行在同一个节点上，还可以以副本的形式运行在多个节点上，然后禁止在这种节点上运行 pod，这种节点就叫做 Master Node（后文简称 Master），当集群中只有一个 Master 时，就是单控制平面，有多个 Master 时，就是多控制平面，生产中肯定是多控制平面，但是学习中一般只使用单控制平面</p>
<h4 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h4><p>https 服务器，监听在 6443 端口，它将 k8s 集群内的一切都抽象成资源，提供 RESTful 风格的 API，对资源（对象）进行增删改查等管理操作</p>
<p>apiserver 是整个 k8s 系统的总线，所有组件之间，都是通过它进行协同，它是唯一可以存储 k8s 集群的状态信息的组件（储存在 Etcd）</p>
<p>生产中，apiserver 需要做冗余，因为无状态，所以最少部署两个 apiserver，因为是 https 服务器，所以需要做四层负载，使用 Nginx、HAProxy、LVS 均可，然后搭配 keepalived 给负载均衡做高可用</p>
<p>关于健康监测，分为 AH（主动监测）和 PH（被动监测或者叫异常值探测）</p>
<h4 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h4><p>控制器管理器，负责管理控制器，真正意义上让 k8s 所有功能得以实现的控制中心，controller-manager 中有很多 controller（deployment 等数十种），这些 controller 才是真正意义上的 k8s 控制中心，负责集群内的 Node、Pod 副本、服务端点（Endpoint）、命名空间（Namespace）、服务账号（ServiceAccount）、资源定额（ResourceQuota）的管理</p>
<p>当某个 Node 意外宕机时，Controller Manager 会及时发现并执行自动化修复流程，确保集群始终处于预期（yaml 配置文件指定）的工作状态</p>
<p>k8s 可以把运维人员日常重复性的工作代码化，就是将多 controller 打包起来，单一运行</p>
<p>默认监听本机的 10252 端口</p>
<p>controller loop：控制循环</p>
<h4 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h4><p>调度器，调度 pod，它的核心作用就是运行应用，scheduler 时刻关注着每个节点的资源可用量，以及运行 pod 所需的资源量，让二者达到最佳匹配，让 pod 以最好的状态运行</p>
<p>在整个系统中起”承上启下”作用，承上：负责接收 Controller Manager 创建的新的 Pod，为其选择一个合适的 Node；启下：Node 上的 kubelet 接管 Pod 的生命周期</p>
<pre class="language-none"><code class="language-none">通过调度算法为待调度Pod列表的每个Pod从可用Node列表中选择一个最适合的Node，并将信息写入etcd中node节点上的kubelet通过API Server监听到kubernetes Scheduler产生的Pod绑定信息，然后获取对应的Pod清
单，下载Image，并启动容器

优选策略：
1.LeastRequestedPriority
优先从备选节点列表中选择资源消耗最小的节点（CPU+内存）
2.CalculateNodeLabelPriority
优先选择含有指定Label的节点。
3.BalancedResourceAllocation
优先从备选节点列表中选择各项资源使用率最均衡的节点</code></pre>

<p><img data-src="//img.to2b.cn/blog/ljk/1615428426624.png"></p>
<h4 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h4><p><a target="_blank" rel="noopener" href="https://etcd.io/">https://etcd.io/</a><br><a target="_blank" rel="noopener" href="https://github.com/etcd-io/etcd">https://github.com/etcd-io/etcd</a></p>
<p>第三方、非 k8s 内置，它的目标是构建一个高可用的分布式键值(key-value)数据库，为避免脑裂，通常部署 3 个或 5 个节点</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">完全复制 	<span class="token comment"># 集群中的每个节点都可以使用完整的存档</span>
高可用性 	<span class="token comment"># Etcd可用于避免硬件的单点故障或网络问题</span>
一致性 		<span class="token comment"># 每次读取都会返回跨多主机的最新写入</span>
简单   		<span class="token comment"># 包括一个定义良好、面向用户的API（gRPC）</span>
安全   		<span class="token comment"># 实现了带有可选的客户端证书身份验证的自动化TLS</span>
快速   		<span class="token comment"># 每秒10000次写入的基准速度</span>
可靠   		<span class="token comment"># 使用Raft算法实现了存储的合理分布Etcd的工作原理</span></code></pre>

<p>etcd 有多个不同的 API 访问版本，v1 版本已经废弃，etcd v2 和 v3 本质上是共享同一套 raft 协议代码的两个独立的应用，接口不一样，存储不一样，数据互相隔离。也就是说如果从 Etcd v2 升级到 Etcd v3，原来 v2 的数据还是只能用 v2 的接口访问，v3 的接口创建的数据也只能访问通过 v3 的接口访问</p>
<p>以下以内容以 v3 为准</p>
<p><a href="./etcdctl/">etcdctl</a> 是 etcd 的命令行客户端工具</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">etcdctl <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token builtin class-name">command</span> <span class="token punctuation">[</span>command options<span class="token punctuation">]</span> <span class="token punctuation">[</span>arguments<span class="token punctuation">..</span>.<span class="token punctuation">]</span></code></pre>

<h5 id="管理成员"><a href="#管理成员" class="headerlink" title="管理成员"></a>管理成员</h5><pre class="language-bash" data-language="bash"><code class="language-bash">etcdctl member list
etcdctl member <span class="token function">add</span>
etcdctl member promote
etcdctl member remove
etcdctl member update</code></pre>

<p>验证成员状态：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$etcdctl</span> endpoint health <span class="token punctuation">\</span>
    <span class="token parameter variable">--endpoints</span><span class="token operator">=</span>https://10.0.1.31:2379 <span class="token punctuation">\</span>
    <span class="token parameter variable">--cacert</span><span class="token operator">=</span>/etc/kubernetes/ssl/ca.pem <span class="token punctuation">\</span>
    <span class="token parameter variable">--cert</span><span class="token operator">=</span>/etc/etcd/ssl/etcd.pem <span class="token punctuation">\</span>
    <span class="token parameter variable">--key</span><span class="token operator">=</span>/etc/etcd/ssl/etcd-key.pem

<span class="token comment"># 多个成员写个遍历即可</span></code></pre>

<h5 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h5><ul>
<li><p>增 put</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">etcdctl put <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token operator">&lt;</span>value<span class="token operator">></span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>value<span class="token operator">></span> can also be given from stdin<span class="token punctuation">)</span> <span class="token punctuation">[</span>flags<span class="token punctuation">]</span>

<span class="token variable">$etcdctl</span> put /testkey <span class="token string">"test data"</span>
OK

<span class="token variable">$etcdctl</span> get --print-value-only /testkey
<span class="token builtin class-name">test</span> data</code></pre>
</li>
<li><p>删 del</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">etcdctl del <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token punctuation">[</span>range_end<span class="token punctuation">]</span> <span class="token punctuation">[</span>flags<span class="token punctuation">]</span>

<span class="token variable">$etcdctl</span> del /testkey
<span class="token number">1</span></code></pre>
</li>
<li><p>改 put</p>
<p>直接覆盖即可</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$etcdctl</span> put /testkey <span class="token string">"test data2"</span>
OK</code></pre>
</li>
<li><p>查 get</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">etcdctl get <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token operator">&lt;</span>key<span class="token operator">></span> <span class="token punctuation">[</span>range_end<span class="token punctuation">]</span> <span class="token punctuation">[</span>flags<span class="token punctuation">]</span>

<span class="token variable">$etcdctl</span> get --print-value-only /testkey
<span class="token builtin class-name">test</span> data2

<span class="token variable">$etcdctl</span> get <span class="token parameter variable">--prefix</span> --keys-only /		<span class="token comment"># 获取所有key</span>
<span class="token variable">$etcdctl</span> get <span class="token parameter variable">--prefix</span> --keys-only /calico
<span class="token variable">$etcdctl</span> get <span class="token parameter variable">--prefix</span> --keys-only /registry
<span class="token variable">$etcdctl</span> get <span class="token parameter variable">--prefix</span> --keys-only /registry/services
<span class="token variable">$etcdctl</span> get /calico/ipam/v2/handle/ipip-tunnel-addr-k8s-master.ljk.local</code></pre></li>
</ul>
<h5 id="watch-机制"><a href="#watch-机制" class="headerlink" title="watch 机制"></a>watch 机制</h5><p>etcd v3 的 watch 机制支持 watch 某个固定的 key，也支持 watch 一个范围，发生变化就主动触发通知客户端</p>
<p>相比 Etcd v2, Etcd v3 的一些主要变化：</p>
<pre class="language-none"><code class="language-none">1. 接口通过grpc提供rpc接口，放弃了v2的http接口，优势是长连接效率提升明显，缺点是使用不如以前方便，尤其对不方便维护长连接的场景。
2. 废弃了原来的目录结构，变成了纯粹的kv，用户可以通过前缀匹配模式模拟目录
3. 内存中不再保存value，同样的内存可以支持存储更多的key
4. watch机制更稳定，基本上可以通过watch机制实现数据的完全同步
5. 提供了批量操作以及事务机制，用户可以通过批量事务请求来实现Etcd v2的CAS机制（批量事务支持if条件判断）</code></pre>

<p>watch 测试：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 在 etcd node1 上watch一个key，没有此 key 也可以执行 watch，后期可以再创建</span>
<span class="token variable">$etcdctl</span> <span class="token function">watch</span> /testkey

<span class="token comment"># 在 etcd node2 修改数据，验证 etcd node1 是否能够发现数据变化</span>
<span class="token variable">$etcdctl</span> put /testkey <span class="token string">"test for new"</span>
OK</code></pre>

<h5 id="数据备份与恢复机制"><a href="#数据备份与恢复机制" class="headerlink" title="数据备份与恢复机制"></a>数据备份与恢复机制</h5><p><strong>v2 版本数据备份与恢复：</strong></p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 备份</span>
etcdctl backup --data-dir /var/lib/etcd/ --backup-dir /opt/etcd_backup

<span class="token comment"># 恢复</span>
etcd --data-dir<span class="token operator">=</span>/var/lib/etcd/default.etcd --force-new-cluster <span class="token operator">&amp;</span></code></pre>

<p><strong>v3 版本数据备份与恢复：</strong></p>
<pre class="language-bash" data-language="bash"><code class="language-bash">etcdctl snapshot <span class="token operator">&lt;</span>subcommand<span class="token operator">></span> <span class="token punctuation">[</span>flags<span class="token punctuation">]</span>

subcommand：save、restore、status</code></pre>

<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$etcdctl</span> snapshot save snapshot.db		<span class="token comment"># 备份</span>
<span class="token punctuation">..</span>.
Snapshot saved at snapshot.db
<span class="token variable">$file</span> snapshot.db
snapshot.db: data

<span class="token comment"># 恢复，将数据恢复到一个新的不存在的目录中</span>
etcdctl snapshot restore snapshot.db --data-dir<span class="token operator">=</span>/opt/etcd-testdir</code></pre>

<h4 id="cloud-controller-manager"><a href="#cloud-controller-manager" class="headerlink" title="cloud-controller-manager"></a>cloud-controller-manager</h4><p>略…</p>
<h3 id="Node-组件"><a href="#Node-组件" class="headerlink" title="Node 组件"></a><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/overview/components/#node-components">Node 组件</a></h3><p>Node 组件运行在<strong>所有</strong>的节点上，包括 Master</p>
<h4 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h4><p>与 api server 建立联系，监视 api server 中与自己 node 相关的 pod 的变动信息，执行指令操作</p>
<p>在 kubernetes 集群中，每个 Node 节点都会启动 kubelet 进程，处理 Master 节点下发到本节点的任务，管理 Pod 和其中的容器。kubelet 会在 API Server 上注册节点信息，定期向 Master 汇报节点资源使用情况，并通过 cAdvisor（顾问）监控容器和节点资源，可以把 kubelet 理解成 Server&#x2F;Agent 架构中的 agent，kubelet 是 Node 上的 pod 管家</p>
<h4 id="kube-porxy"><a href="#kube-porxy" class="headerlink" title="kube-porxy"></a>kube-porxy</h4><p><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/concepts/services-networking/service/">https://kubernetes.io/zh/docs/concepts/services-networking/service/</a><br><a target="_blank" rel="noopener" href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-proxy/">https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-proxy/</a></p>
<p>守护进程，管理当前节点的 iptables 或 ipvs 规则，而且管理的只是和 service 相关的规则</p>
<p>监控 service，把集群上的每一个 service 的定义转换为本地的 ipvs 或 iptables 规则</p>
<p>kube-proxy 是运行在集群中的每个节点上的网络代理，实现了 Kubernetes 服务概念的一部分<br>kube-proxy 维护节点上的网络规则。这些网络规则允许从集群内部或外部的网络会话到 Pods 进行网络通信<br>kube-proxy 使用操作系统包过滤层（如果有的话）并且它是可用的。否则，kube-proxy 将自己转发流量</p>
<h4 id="Container-runtime"><a href="#Container-runtime" class="headerlink" title="Container runtime"></a>Container runtime</h4><p>通常是 docker，其他类型的容器也支持</p>
<h3 id="Addons"><a href="#Addons" class="headerlink" title="Addons"></a><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/overview/components/#addons">Addons</a></h3><p>附加组件扩展了 Kubernetes 的功能</p>
<p>插件使用 Kubernetes 资源(DaemonSet, Deployment，等等)来实现集群特性。因为它们提供了集群级的特性，所以插件的命名空间资源属于 kube-system 命名空间</p>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>CoreDNS，k8s 中，DNS 是至关重要的，所有的访问都不会基于 ip，而是基于 name，name 再通过 DNS 解析成 ip</p>
<h4 id="Web-UI"><a href="#Web-UI" class="headerlink" title="Web UI"></a>Web UI</h4><h4 id="集群监控系统"><a href="#集群监控系统" class="headerlink" title="集群监控系统"></a>集群监控系统</h4><p>prometheus</p>
<h4 id="集群日志系统"><a href="#集群日志系统" class="headerlink" title="集群日志系统"></a>集群日志系统</h4><p>EFK、LG</p>
<h4 id="Ingress-Controller"><a href="#Ingress-Controller" class="headerlink" title="Ingress Controller"></a>Ingress Controller</h4><p>入栈流量控制器，是对集群中服务的外部访问进行管理的 API 对象，典型的访问方式是 HTTP。</p>
<h4 id="…"><a href="#…" class="headerlink" title="…"></a>…</h4><p>附件千千万，按需部署</p>
<h2 id="CNI"><a href="#CNI" class="headerlink" title="CNI"></a>CNI</h2><p>CNI：Container Network Interface，容器网络接口</p>
<p>kubernetes 的网络插件遵从 CNI 规范的 v0.4.0 版本</p>
<p>网络插件有很多，最常用的是 flannel 和 Project Calico，生产环境用后者的最多</p>
<p>跨主机 pod 之间通信，有两种虚拟网络，有两种：overlay 和 underlay</p>
<ul>
<li>overlay：叠加网络 ，搭建隧道</li>
<li>underlay：承载网络，设置路由表</li>
</ul>
<h3 id="overlay"><a href="#overlay" class="headerlink" title="overlay"></a>overlay</h3><p>OverLay 其实就是一种隧道技术，VXLAN，NVGRE 及 STT 是典型的三种隧道技术，它们都是通过隧道技术实现大二层网络。将原生态的二层数据帧报文进行封装后在通过隧道进行传输。总之，通过 OverLay 技术，我们在对物理网络不做任何改造的情况下，通过隧道技术在现有的物理网络上创建了一个或多个逻辑网络即虚拟网络，有效解决了物理数据中心，尤其是云数据中心存在 的诸多问题，实现了数据中心的自动化和智能化</p>
<p>以 flannel 为例，默认网段 10.224.1.0&#x2F;16，flannel 在每个节点创建一个网卡 flannel.1，这是一个隧道，网段 10.2441.0&#x2F;32 - 10.244.255&#x2F;32，而每个节点上的容器的 ip 为 10.244.x.1&#x2F;24 - 10.244.x.254&#x2F;24，也就是说 flannel 默认支持最多 256 个节点，每个节点上又最多支持 256 个容器</p>
<h3 id="underlay"><a href="#underlay" class="headerlink" title="underlay"></a>underlay</h3><p>UnderLay 指的是物理网络，它由物理设备和物理链路组成。常见的物理设备有交换机、路由器、防火墙、负载均衡、入侵检测、行为管理等，这些设备通过特定的链路连接起来形成了一个传统的物理网络，这样的物理网络，我们称之为 UnderLay 网络</p>
<p>UnderLay 是底层网络，负责互联互通而 Overlay 是基于隧道技术实现的，overlay 的流量需要跑在 underlay 之上</p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>Pod、Deployment、Service 等等，反映在 Etcd 中，就是一张张的表</p>
<p>kube-apiserver 以群组分区资源，群组化管理的 api 使得其可以更轻松地进行扩展，常用的 api 群组分为两类：</p>
<ol>
<li>命名群组：<code>/apis/$GROUP_NAME/$VERSION</code>，例如 <code>/apis/apps/v1</code></li>
<li>核心群组 core：简化了路径，<code>/api/$VERSION</code>，即<code> /api/v1</code></li>
</ol>
<p>打印 kube-apiserver 支持的所有资源：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">kubectl api-resources</code></pre>

<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>资源表中的每一条数据项就是一个对象，例如 Pod 表中的数据项就是 Pod 对象。所以资源表通常不叫 Pod 表、Deployment 表…，而是叫做 PodList、DeploymentList…</p>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>三种方式</p>
<ol>
<li>命令式命令：命令，全部配置通过选项指定</li>
<li>命令式配置文件：命令，加载配置文件</li>
<li>声明式配置文件：声明式命令，加载配置清单，推荐使用</li>
</ol>
<p>配置清单：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 配置清单的规范叫做资源规范,范例：</span>
<span class="token key atrule">apiVersion</span><span class="token punctuation">:</span> v1
<span class="token key atrule">kind</span><span class="token punctuation">:</span> Pod
<span class="token key atrule">metadata</span><span class="token punctuation">:</span>
	<span class="token key atrule">name</span><span class="token punctuation">:</span> myPod
	<span class="token key atrule">labels</span><span class="token punctuation">:</span>
		<span class="token key atrule">app</span><span class="token punctuation">:</span> mypod
		<span class="token key atrule">release</span><span class="token punctuation">:</span> canary
<span class="token key atrule">spec</span><span class="token punctuation">:</span>													<span class="token comment"># 期望状态</span>
	<span class="token key atrule">containers</span><span class="token punctuation">:</span>
	<span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> demoapp
	  <span class="token key atrule">image</span><span class="token punctuation">:</span> ikubernetes/demoapp<span class="token punctuation">:</span>v1.0</code></pre>

<p>资源清单是 yml 格式，api-server 会自动转成 json 格式</p>
<p>如果实际状态和期望状态有出入，控制器的控制循环就会监控到差异，然后将需要做出的更改提交到 apiserver，调度器 scheduler 监控到 apiserver 中有未执行的操作，就会去找适合执行操作的 node，然后提交到 apiserver，kubelet 监控到 apiserver 中有关于自己节点的操作，就会执行操作，将执行结果返回给 apiserver，apiserver 再更新实际状态</p>
<h3 id="查看对象"><a href="#查看对象" class="headerlink" title="查看对象"></a>查看对象</h3><h4 id="外部访问"><a href="#外部访问" class="headerlink" title="外部访问"></a>外部访问</h4><pre class="language-bash" data-language="bash"><code class="language-bash">domain:6643/apis/<span class="token variable">$GROUP_NAME</span>/<span class="token variable">$VERSION</span>/namespaces/<span class="token variable">$NAMESPACE</span>/<span class="token variable">$NAME</span>/<span class="token variable">$API_RESOURCE_NAME</span>
domain:6643/api/<span class="token variable">$VERSION</span>/namespaces/<span class="token variable">$NAMESPACE</span>/<span class="token variable">$NAME</span>/<span class="token variable">$API_RESOURCE_NAME</span>

<span class="token comment"># 范例：</span>
domain:6643/api/v1/namespaces/default/pods/demoapp-5f7d8f9847-tjn4v</code></pre>

<h4 id="内部访问"><a href="#内部访问" class="headerlink" title="内部访问"></a>内部访问</h4><p>以下三种访问方式是一样的：</p>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 方式一，这种方式最方便</span>
kubectl get pods net-tes1 <span class="token parameter variable">-o</span> json<span class="token operator">|</span>yaml
<span class="token comment"># 方式二</span>
kubectl get <span class="token parameter variable">--raw</span> /api/v1/namespaces/default/pods/net-test1
<span class="token comment"># 方式三，这种方式适用于监控</span>
kubectl proxy	<span class="token comment"># 搭建代理</span>
<span class="token function">curl</span> <span class="token number">127.0</span>.0.1:8001/api/v1/namespaces/default/pods/net-test1	<span class="token comment"># 另起一终端</span></code></pre>

<p>注：1.20 之前的版本可以直接<code>curl 127.0.0.1:8080</code>，并且通过<code>--insecure-port</code>可以修改默认的 8080 端口，1.20.4 之后的版本取消了这种不安全的访问方式，只能通过以上方式三，先<code>kubectl proxy</code>代理一下，默认端口也改成了 8001</p>
<blockquote>
<p>The kube-apiserver ability to serve on an insecure port, deprecated since v1.10, has been removed. The insecure address flags <code>--address</code> and <code>--insecure-bind-address</code> have no effect in kube-apiserver and will be removed in v1.24. The insecure port flags <code>--port</code> and <code>--insecure-port</code> may only be set to 0 and will be removed in v1.24. (<a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/pull/95856">#95856</a>, <a target="_blank" rel="noopener" href="https://github.com/knight42">@knight42</a>, [SIG API Machinery, Node, Testing])</p>
</blockquote>
<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$kubectl</span> get pods net-test1 <span class="token parameter variable">-o</span> yaml
 apiVersion: v1
 kind: Pod
<span class="token operator">></span>metadata:
<span class="token operator">></span>spec:
<span class="token operator">></span>status:</code></pre>

<p>以上返回的数据，每个字段表示的意义可以通过 <code>kubectl explain</code> 查询帮助</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">kubectl explain <span class="token operator">&lt;</span>type<span class="token operator">></span>.<span class="token operator">&lt;</span>fieldName<span class="token operator">></span><span class="token punctuation">[</span>.<span class="token operator">&lt;</span>fieldName<span class="token operator">></span><span class="token punctuation">]</span></code></pre>

<pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$kubectl</span> explain pod.apiVersion
KIND:     Pod
VERSION:  v1

FIELD:    apiVersion <span class="token operator">&lt;</span>string<span class="token operator">></span>

DESCRIPTION:
     APIVersion defines the versioned schema of this representation of an
     object. Servers should convert recognized schemas to the latest internal
     value, and may reject unrecognized values. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md<span class="token comment">#resources</span>

<span class="token comment"># 范例</span>
<span class="token variable">$kubectl</span> explain pod.kind
<span class="token variable">$kubectl</span> explain pod.metadata
<span class="token variable">$kubectl</span> explain pod.spec</code></pre>

<h2 id="lease-租约"><a href="#lease-租约" class="headerlink" title="lease 租约"></a>lease 租约</h2><p>lease 是分布式系统中一个常见的概念，用于代表一个分布式租约。典型情况下，在分布式系统中需要去检测一个节点是否存活的时，就需要租约机制。</p>
<p><img data-src="//img.to2b.cn/blog/ljk/1610675848800.png"></p>
<p>上图示例中的代码示例首先创建了一个 10s 的租约，如果创建租约后不做任何的操作，那么 10s 之后，这个租约就会自动过期。接着将 key1 和 key2 两个 key value 绑定到这个租约之上，这样当租约过期时 etcd 就会自动清理掉 key1 和 key2，使得节点 key1 和 key2 具备了超时自动删除的能力。</p>
<p>如果希望这个租约永不过期，需要周期性的调用 KeeyAlive 方法刷新租约。比如说需要检测分布式系统中一个进程是否存活，可以在进程中去创建一个租约，并在该进程中周期性的调用 KeepAlive 的方法。如果一切正常，该节点的租约会一致保持，如果这个进程挂掉了，最终这个租约就会自动过期。</p>
<p>在 etcd 中，允许将多个 key 关联在同一个 lease 之上，这个设计是非常巧妙的，可以大幅减少 lease 对象刷新带来的开销。试想一下，如果有大量的 key 都需要支持类似的租约机制，每一个 key 都需要独立的去刷新租约，这会给 etcd 带来非常大的压力。通过多个 key 绑定在同一个 lease 的模式，我们可以将超时间相似的 key 聚合在一起，从而大幅减小租约刷新的开销，在不失灵活性同时能够大幅提高 etcd 支持的使用规模。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="//img.to2b.cn/blog/ljk/1607160536339.png" alt="像方便面一样的男子 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="//img.to2b.cn/blog/ljk/1607160019009.png" alt="像方便面一样的男子 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/k8s/" rel="tag"><i class="fa fa-tag"></i> k8s</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/%E8%BF%90%E7%BB%B4/ELK/logstash%E6%94%B6%E9%9B%86%E6%97%A5%E5%BF%97%E6%A1%88%E4%BE%8B/" rel="prev" title="logstash收集日志案例">
                  <i class="fa fa-chevron-left"></i> logstash收集日志案例
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/%E5%B7%A5%E5%85%B7/ubuntu/wireshark%E5%9C%A8ubuntu18.04%E4%B8%8B%E6%97%A0%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90/" rel="next" title="wireshark在ubuntu18.04下无执行权限">
                  wireshark在ubuntu18.04下无执行权限 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">鲁ICP备18016600号-3 </a>
  </div>

<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">像方便面一样的男子</span>
</div>

    </div>
  </footer>

  
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="//s1.to2b.cn/libs/animejs/3.2.1/anime.min.js"></script>
  <script src="//s1.to2b.cn/libs/lozad.js/1.16.0/lozad.min.js"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  <script src="//s1.to2b.cn/libs/algoliasearch/4.11.0/algoliasearch-lite.umd.min.js"></script>
<script src="//s1.to2b.cn/libs/instantsearch.js/4.36.0/instantsearch.production.min.js"></script><script src="/js/third-party/search/algolia-search.js"></script>






  





</body>
</html>
